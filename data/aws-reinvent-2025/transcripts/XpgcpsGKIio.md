---
video_id: XpgcpsGKIio
video_url: https://www.youtube.com/watch?v=XpgcpsGKIio
is_generated: False
is_translatable: True
summary: "This session, titled \"Accelerate development with Kiro's new agentic AI capabilities,\" serves as the launch event for \"Kiro Powers,\" a transformative feature designed to elevate generic AI coding agents into highly specialized experts by intelligently bundling Model Context Protocol (MCP) servers with \"steering\" instructions, effectively solving the pervasive \"context rot\" problem where agents become less reliable when flooded with excessive or irrelevant context. The presenter, Nikhil, argues that while AI agents have rapidly evolved from simple inline code completion tools to capable autonomous builders, they frequently fail at specialized tasks—such as using a new SDK or adhering to a specific framework's best practices—because they lack the necessary \"onboarding manual\" to apply their general knowledge effectively in a specific domain. Kiro Powers bridges this gap by offering a modular, plugin-like architecture that packages the tool access (via standard MCP servers) alongside a markdown-based \"steering file\" that dictates the workflow and rules, ensuring the agent acts as a domain expert without requiring the user to constantly engineer complex prompts. The presentation is anchored by three robust demonstrations that showcase the practical utility of this system across the software development lifecycle. First, Nikhil introduces the Figma Power, which solves the \"design-to-code\" friction by connecting directly to a Figma design file; the Power automatically extracts design tokens and generates a local \"design system rule\" file, enabling the agent to synthesize frontend code that is pixel-perfect and strictly compliant with the project's existing CSS architecture and component library. Following this, Harry Mauer from Postman takes the stage to demonstrate the Postman Power, which revolutionizes API development by allowing the agent to scan the local codebase, infer the API structure, and autonomously generate comprehensive Postman collections and functional mock servers; this capability allows for \"test-driven\" agentic workflows where the agent can validate its own code against a simulated backend before deployment. The final and most extensive demo features Tyler from Supabase, who uses the Supabase Power to build a complete \"personal banking\" application from scratch. This Power guides the agent through a complex sequence of backend tasks: initializing the Supabase project, defining SQL tables with appropriate columns and relationships, applying critical Row Level Security (RLS) policies, generating precise TypeScript definitions that mirror the database schema, and even seeding the database with realistic dummy data, all before asking the agent to scaffold a React frontend that visualizes this data. The session concludes with a look at the open ecosystem, demonstrating how easily developers can craft custom Powers using simple configuration files, and outlining a roadmap for organizational governance where companies can publish private Powers to standardize development workflows across their teams."
keywords: Kiro Powers, Model Context Protocol, Agentic AI, Steering Files, Context Rot

We're going to be talking about Kiro powers. So I'm doing the He-Man power move so similar for you. How many of you, quick, quick show of your hands, how many people here have used hero? All right, cool, um, handful. How many people have heard of Quiro? Yeah, I think we did our job, uh, when I, I, I had a session day one and I asked the audience and it was like 30% and like by day 4 now it's, uh, everyone knows about Kiro, so we're hoping that, you know, we, a lot more of you try Quiro over like once you get back to, uh, over the holidays actually and hope all of you took advantage of the 1000 free credits you can get at the uh Kiro haunted house back at the Venetian. So today we're going to talk about powers. This is a feature that we launched just yesterday morning. I will get into what it is and and what problem it solves, but here's the rough agenda. We'll start with the general problem that we were trying to solve with powers. How we're going about solving it. And then I will, I'll do a live demo, so hopefully the demo gods are with me. Uh, and, oh, I, I totally forgot. I forgot to introduce, uh, we, we have two partners here. I have Harry Mauer, who's the CTO of Postman, and then, uh, Tyler Schuckert, who's a Devre engineer at Superbase, and they're gonna talk about, uh, their use cases about how they're using powers to really streamline the onboarding for, uh, API development and backend development. Now I'm sure you've seen a variant of the slide over the last 4 days over 1000 times. Uh, AI has transformed software dev. Uh, what started with inline code suggestions that would give you a function has now evolved to full blown agents that are able to. Build large features in your code base. But one of the problems is that AI agents are still generalists. Jack of all trades, if you will. So every time you go to do something specific like you're, you're working on a front end or you're working on an API or a back end, there's a lot of massaging you have to do with the, with the agent, providing the agent a lot of context. To get the right outcome you want. For specialized tasks, agents do face challenges. The first one really. Is that Software is evolving every day. Every day there's a new SDK. Every day there's like a new, new tool or technology that's launched. The models that power the agents are often trained on data that isn't up to date. So, if you want to work with an SDK like the strands TypeScript SDK for agent development came out at reinvent. You're gonna have to figure out how to get the model to, or the agent to build strand stuff. You could link it to the docks, but it's just gonna go ahead and Decide what it wants to do. And the second problem is that even when the agent does, uh, know about or even when the agent does know about a particular piece of technology or a framework. It can miss steps and it can, it can not follow, it doesn't really have an onboarding manual for that, uh, for that for a technology. MCP was built to solve that problem. How many of you are familiar with MCP? OK, so MCP is a model context provider. It was a, it's a, it's a convention that was built so that you could share, so it allowed for agents an extensible model when working with agents. So for example, both our partners here today, Postman and Superbase, have MCP servers. The MCP servers really talk to their APIs, so they're able to do things like list projects, update tables, create collections. Um, but the MCP alone, um, is also not enough. The, the problem that happens with agents is as you add more and more agent MCPs to your agent. The agent gets overwhelmed with con with context. And a real problem that's emerged in the industry as a whole is context rot that as more tools get added and and are made available to the agent. Performance degrades, so and quality output declines. Additionally, with the even with the MCP server in hand. There's often guidance and onboarding instructions that are completely missed that the agent just does not follow. So what you often need to pair is almost a combination of MCP. And context Now a lot of solutions have popped up even beyond MCP in the market now. You have, uh, cloud Skills, you know, they recently launched anthropically recently launched, it's called Tool Search Tool, kind of a weird name, um, that, that allows you to like dynamically discover tools. Uh, you have cursor rules, you have agents. MD, but they're sub-agents. But they're all different ways to get to the same thing and just if you go look online in the forums and on Reddit, people are very confused, like, what do I use, when do I use, what, like, and there's a, there are tons of YouTube videos about MCP versus skills versus sub-agents, and they all kind of do the, the, the end goal is really you want to generate code for your to match your intent. And so we really took a step back with with powers and we thought about how do we one. Get the agent to learn something specialized. And 2, do it in a way where it doesn't actually overwhelm the agent with context. And that's kind of why we launched Hero Powers. So what hero powers do is that they give they're a bundle that is a that give the agent extensible specialized capabilities, right? So it really makes your hero agent extensible so you can add a power, uh, and then the agent knows about that power. And when you, you do it, you take on a task that is related to the power, the agent can just automatically discover it. The unique thing here is that as you add these powers. They're not just, ah, they're not going to overwhelm your agent with context, because the agent is getting very minimal information. About the specific technology. So in this case if we add Postman and Figma sorry, Postman and Superbase, the agent just knows about that that it has these postman capabilities available and if you ask questions about APIs, it'll automatically just say hey I need to use the Postman power and they'll actually start going ahead and um following the instructions in the power. What the power really contains, and I'll show this in the demo, is a combination of it has, it's a front matter, it's got front matter and markdown, so there's a power. MD file that defines basically onboarding instructions and a workflow for the agent to follow, and that's the that's the only required piece of information. But what you can also do is, is combine that with MCP tools to really make it powerful. So power is the is the only available solution out there right now that combines steering and MCP in one bucket and what we do is we have a we have a template really for the Power MD that allows you to do things on install uh and on activation. Allow you to install hooks and ah steering files, which we'll, I'll I'll kind of show you in the demo. We've partnered with um partners, so we've got a curated set of partners. Yeah, we've, we've, uh, partnered with partners across the life cycle of application development. So from UI development with Figma to API development with Postman to backend development with Superbase and Neon to payments with Stripe. And It's not just curated powers we've built it in a way so anyone can build a power. So in fact, in my demo what I'm gonna do today is start with one of the curate powers and then actually like live build a power and and bring it into my project. What that allows is really the community to build a whole variety of powers. Just yesterday at my last session I had 3, individuals come up to me and say, Hey, I've got this really cool use case for a power. They, they were doing Java upgrades and apparently that's really hard. I'm not a Java developer, um, and. Uh, we already have, there's like multiple repos. Someone created a Kiro Powers repo overnight, and they've got like a playwright power, right? So it's really gonna open up an extensible model of working with Quiro. Cause I trust me you're gonna have a power for that. And what we've done is we've, our UX is also uh very simple. So within the Quiro interface, so Kiro, the ID interface, we have a new power spane. Where you just click on the power. It loads our curated powers, and you can just one click install it. And you will, you see this very shortly. And as I called out, even from the same interface, you can build your own power or import a power. So if you got a public GitHub URL, someone on the Internet shared this power being like, hey, this is a super cool playwright power I built, you can just add that and your agent will have awareness of that. The 2nd use case is a start of phase 1 of our journey towards more governance for teams around powers. Uh, but it'll enable it alone will already enable teams. So let's say you have a team and you want, you define, you know, coding, coding conventions, you define rules around how you work with, uh, particular technology. You can define that in a repository with powers, and you can actually import the power from a folder so each developer can clone the repository to their individual environments and actually import powers. We're going to make that a lot better in the future. And finally, this, this kind of organically came up as we were working with partners because every partner was saying, hey, like now I've got to maintain like these unique files for every for every provider because as, as we all know, there's a lot of agentic tools out there. And uh what we wanted to do was not build something that's proprietary in nature so hopefully once we've with the way we built this under the hood is that uh powers is is itself an MCP server. So hopefully once we make this public, we didn't make this public, uh, immediately, but you can use powers with, you know, Klein, the hero CLI cursor, maybe even clot code. And hopefully when we, once we do that, um, you know. Harry and Tyler here will be able to keep that one file and actually if when working with multiple providers they can just provide that bundle as context. And so I think I've spoken enough about powers here. So let me actually go ahead and switch to a live demo. Since there were many people in the audience who have not actually used Quiro. Let me give you a quick, quick tour of the interface. So Quiro is an ID fork of code OSS, and what we really have, uh, is this, so this Kiropane here. Has 4 features that we launched with, so the application that I'm showing you today is an application I've built in my last 2 demos. It's a job seeker's app. So, uh, the, the pitch here and, uh, and my, my plan is after this I'm gonna quit, quit my job and go build, build the next billion dollar unicorn is, uh, the, the, but the pitch here is that. People looking for jobs often like there's tools and there's enough information available to practice questions, but there isn't really a way to practice, uh, like tone and style and how and diction and how you're answering something so we built, we live built this app in a one hour session where essentially the flow is like. A user starts an interview. You voice record the answer. We transcripted the answer, and then after you go through the interview, we send the results to an, uh, an AI SD cloud SDK that then generates a qualitative and quantitative score of your, of how you did. And we use specs, uh, so if you're not attended any of the sessions on Quiro, Specs is the, the unique feature that we added to the space. It gives a structured approach to building with AI because you can really plan effectively before you go and implement work. So, to give you a, can everyone see the interface OK? I can, um, I'll just make it a little bigger. Sorry. To give you an overview of the interface, so you start with a prompt, and what we break that prompt into user stories and acceptance criteria that actually define like your requirements. Um, so in this case you see things like as a job interview, as a job seeker I wanna answer interview questions using voice recording so that I can practice speaking. Then we, we switched to a design and the design really like if you look at it, it starts with an architecture diagram, so this is a this is a React application and it's got all the components and interfaces within it. And then you get to a task list, and the task list includes optional, like optional tasks and required tasks that you then you can then execute. Now this entire flow we did this flow in a in a whole session where we built this application and uh I'll do a quick demo of the application as well because you can start with an interview. And Agentic development. Involves working with MCPs context and tools. Uh, it's, it's a hard problem to solve, which is why we launched Powers. Powers was it uh Powers was a technical problem we solved recently. Uh, we did this in a way where we, we used the concept of progressive disclosure, uh, to make the agent effective. I research things on the Internet and using social media. And then what what this app does is that it then sends this data over transcript transcribes that data and sends it over the web, the web to, uh, cloud to the to an to a model. The model analyzes the results and gives me a score. Uh, looks like I, I'm not ready to get my, get, get a job. It's a lot of work I gotta do. Uh, and, and gives you qualitative feedback as well. Cool. So that was a quick tour of the application. I, I didn't really talk about the other features, but we have hooks. Hooks are a way, hooks are life cycle events, so they actually like watch the IDE for different events like file save, file create, uh, we're adding more like on agent com chat complete. And you can actually do things, uh, you can do actions so you can ask the agent to do something or you can run commands it's kind of uh an enforcer if you will, when you're working with agents. And then as we talked about MCP and steering are like ways to guide the agent to give the agent rules to follow when they when they build things. It's a very quick overview of just the core hero interface. Um Now, what we launched with Powers is this new tab here. So adding a power here is really easy. So what, what I'm gonna do in this demo is that I have this interface here that I've built this, this was the interface I built just in the, in my last session. But I also have a Figma file that, let's say my designer built, and this is, this, this kind of looks much nicer than what you just saw, right? So what I'm gonna do is I'm, I'm gonna try and get Hiro to take this to, I'm gonna install the Figma power and try and have Quiro to go and implement this. So let's actually go ahead and install the Figma power. All right, um, so that that was installed and if you want to take a look at what a power looks like. The power itself is just it's a markdown file with the power. MD. Let me open the front matter because it's the markdown version because it's easier to understand. So this is what front matter looks like, right? And you, as you can see, we have keywords related to Figma like UI design, code, layout, uh, that help the agent decipher when it should actually invoke this power. And with this power there's like a workflow defined, you know, execute this file to generate the right context for Figma and so it's, it, it's gonna create something called a system design rule and then also a hook which uh which we can watch. And then with the power there's an MCP. Jason. So this is, this is the MCP configuration. So Figma has an MCP server and so you can add one or more MCPs within, within a power, but working with FIGMA, the FGM, they have one MCP. So now what I'm gonna go ahead and do is I'm actually gonna say. Try power. And see what happens. So as you can see, it, it, it activated the figma power. And tells you what you can do with the figma power. And the first thing it it's doing, is doing, it's doing this thing called, it's saying it needs to create design system rules. Now what create design system rules is a tool in the MCP for Figma, but if you were to just download the the Figma MCP and start working with it, it wouldn't automatically get invoked. In fact, you like there's documentation embedded in some Figma link which says like copy this prompt, paste it in, and generate this file. What this file does is actually gives the agent really good context on like how to, uh, it gives Figma and the agent really good context about what the specific project set up, uh, what, what the specific project has in terms of a design system. So, uh, this should generate shortly. But it'll have things like what, what is the, the CSS styling, what's the like design tokens like the what's the, what are, what are layout rules. Um, so colors, right, these are all things that Figma finds very useful and the agent also finds very useful when, when it generates code. Now, it's, so it created the steering file and it it it's got the steering file with this inclusion mode as always. So what this means is now I have the steering file included right here. That every time the agent runs, it will use this file as context because Figma really thinks that this is an important file for the agent to have access to. And second, it created something called, uh, this is slightly more contextual to like an audience that's familiar with Figma, but it created a hook called Figma component code connect. Now what that does is that Figma has this concept of components. In your UI you have conceptual components, and you can really map the two together. So, what, the way this hook runs is that it says that on every, it should, it should be in every file create. It'll basically map try and map the component to the Figma version of the component. So that's really what you can get with this power. So right at the box, you get an onboarding experience that's fully guided, that isn't just, OK, go install an MCP server from the docks and figure out how to work with it. And as a developer, there's nothing more important than staying in the flow. Right, so All right, so it's saying, OK, great, my Sigma power is now up and ready to use. And it's giving me some examples again, so this is, this is all very useful because it gives you, it's almost like documentation that you'd have to follow but without leaving your editor. Now, if I were to go to Figma, Figma has this feature called Dev mode right here, which allows me to select a component. And I can just copy this example prompt. That says implement this design from Figma. And then I go in here Um, and I'm gonna just go ahead and paste that. And let's see what the agent does. Hopefully this works. Yep, so it's trying to get this tool from Figma. I'm just gonna go ahead and auto approve. The tools would never ask me for permission again. Um. OK, great. OK, so now it's connected to the Figma I fetched that frame and what you can see it says I've found this topic. Let me convert this design to match your project CSS approach. So it's taking like the Figma context and it's got context because it includes that design context file at the beginning. It is going to say, oh wow, like it's now I can understand what you've got in your project and what Figma has, and it's now gonna go ahead and create a new enhanced topic card component. Let's see how it does. So the interesting, the funny thing here is like I've, I did this like 2 times before the demo and both times the results were slightly different and that is just the nature of working with uh AI systems right now, uh, but they were close enough so I'm hoping this is this this version is also gonna be um pretty good. So this is the other cool thing we've launched with Quiro this in the last couple of months. When we first launched Quiro, the agent would have a lot more errors in the actual interface, and it requires some back and forth to fix them. But we launched diagnostics tool support which actually can look at find like linting lint issues, linting errors, and we launched support for like dev server so it can read like compile time errors and, and the agent just like auto recovers itself so it's, it's, I was able to do most all my demos this, this reinvent uh this is my 4th session without the agent really making mistakes which has been super cool. And now I'm gonna jinx myself for sure. While this is happening, let me just show you how I can, how easy it is to create a power. So I have this power that I've built, um, I, I really like so Chrome has a devtools server that what what it lets you do is it it it actually will run Chrome and be able to do things like click on components test for responsiveness. Check, like, make hover effects, uh, it can do a lot, um, so I've set up this, uh, Chrome Dev Tools power and, uh, it's essentially got two files. It's got a power. MD file. With like instructions for what to do and an MCPJS and an MCPJN file. Now, for me to add this to Quiro, it's gonna be um super easy. I would just go into Quiro here in the cust say add custom power. Import a power from a folder. Uh. And there, now I have a Chrome Dev Tools UI testing power available to me as well. OK, so it implemented something. Let's see how it did what it did. All right. Oh, not bad. It's pretty good. And let's, let's actually now go ahead and see if like I can invoke the Chrome Dev Tools power, OK, uh, now run Chrome Dev Tools to make sure. Everything is OK. OK, so it's running a background power. And let's see if it OK, great. Oh, did I have my MCP on? Oh, I'm, I cheated a little bit. I unfortunately had not disabled the the actual MCP server, but that's fine, um. So what, what this is gonna do now is that you see how it opened its own instance and now check out what it's gonna do. It's gonna see, so Dev serve is running now. There's a, the new design is rendering great. Let me check the console for any errors. So look at the runtime, look at the actual console runtime, see if the errors. OK, no errors. Now let me test the hover effects. And so it's gonna allow actually like hover on the UI component I believe the UI component has some hover states to see if the hover works. And now it's doing OK, how is this gonna work on a mobile device? It's gonna resize the, the, the page. And yeah, so this, so I think you, you, you get the gist of it. So the, the powers really give you the ability, the agent ability like a toolkit abilities, a Swiss Army knife of abilities without overwhelming it with context, and I, I kind of walked you through the Figma use case. I'm gonna, uh, ask Harry to come on and, and, uh, talk about Postman. Awesome. Uh, where I'm at here. Hi everybody. My name's uh Harry Mauer. I'm the Field CTO of Postman, and in my role, I help our largest customers improve their overall software development process. Um, how many of you familiar with Postman? How many of you use Postman? Yeah, there you go. So for those that haven't, um, Postman is the most widely used tool to test and design and to manage your APIs. We're used by over 40 million developers. Over 500,000 organizations have adopted us, and we've become one of those, uh, indispensable tools in the developer toolkit, sort of like, you know, Git and VS code, strong coffee, and, uh, noise canceling headphones, right? We're part of the, the tool chest that every developer typically uses. Um, for those that aren't familiar with me, I had a long history in developer tools. Um, I spent a long time at Microsoft in Developer Tools. I ran, uh, Dev Tools for Red Hat for a long time. I actually worked on Dev Tools at AWS, and now I'm here at Postman, and I've never been more excited about software development. I feel like my entire 20+ year career has led to this point where my code is finally able to write my code, right? And it's just awesome how much you can get done in just a short amount of time with these tools, but. For as powerful as they are, uh, they still need a lot of guidance, right? So as Nikil was saying, they're very much generous, and they need a lot of guidance and knowledge to help them do the job in the way that you want them to do it, right? So you gotta tell them what kind of framework to use and what kind of language to use, and importantly for Postman, which APIs you want to use to build in your application. Um, and this is where we see Postman continuing to play an indispensable role, right? As I mentioned, millions of developers use Postman to collaborate and build their APIs and test them and manage them. And increasingly those developers are being joined by countless numbers of agents, right? So agents now are wanting to do the same thing that developers did. They want to test their APIs, they want to, uh, share the APIs, and they want to do that not only with other developers, but with other agents as well. And today we enable that through our Postman MCP server. So there's an MCP server out there today that you can use within whichever coding agent or assistant that supports MCP that you wanna use, but there's some limitations to it, and this is why we're so excited to be partnering with the Quiro team, right? You know, for instance, we want to provide a lot of capabilities to those MCP servers, so we have over 100 tools, but most of them really can't deal with that many tools, right? So we have a slimmed down version which only has 40 tools, which can also sometimes overwhelm them, right? So one of the things we're really excited about in here is the ability for that to automatically load after we install uh the, the MCP server, right? And the other thing that we usually stumble upon is when someone goes to use our MCP server, we're relying on them to actually write the system prompts to make it more effective, right? And so now with Kira, we have these steering files, and we can package all this up into a power that makes our MCP server much more powerful for the agent to use. And so rather than me talking about it, I wanna give you a quick demo. Uh, I am not as fearless as Nikhil, so I recorded mine. Um, let's see if we can get the video going. So I've got a, uh, sample application. It's a personal finance application. It's interesting, me and Tyler both started working on the same thing. Um, it's pretty robust. It's got a lot of the same things that you would expect to have in a large enterprise scale application. It's got a query PI. It's got an SDK, it's got a CLI. And I use Postman to help manage all of the different versions and share those APIs with my team. So in my pipelines, I automatically generate a collection and a spec for each version, and I do that as part of my pipeline process. But when I want to build an API that I can collaborate on, one that's still in development, I also want to create a collection and be able to share that with my other development teams. So through the new Quiro Power, um, I can do that with, right with inside my IDE. Here's a sample prompt I put together. I'm asking Kira to create a collection based off an endpoint within my API for just reporting. And one of the things that we tell in the steering file is we tell Kira to keep a Postman.json file for all of the metadata about the workspace and the collection and the user information that we use, and we build upon that as we go because it's gonna help some of our more advanced features like the hooks work later on. So as Kira goes through the process here. It's going to use my API key to collect, to connect to Postman. It's going to read my code, understand the endpoints that I need to make, and then it automatically creates this collection inside of my workspace that now I can share with my team, right? So it's got everything it needs here. And you should see that here. So there, there's my new uh endpoint in development. This is pretty cool, but if someone went to go to use this, it wouldn't really work. It would tell them what the input was supposed to look like, but there's no real way to test this. And so one of the cool features inside of Postman is the ability to create mock servers and environments for APIs that aren't quite finished yet, right? So I can mock out this environment. I can share that with the team who needs it downstream while I'm continuing to develop the implementation. And so I can do that now inside directly inside a hero instead of having to do that inside a Postman. I don't ever have to leave my IDE, so. Another prompt I asked, I tell Kira, hey, let's take that collection you just built, the one you just saved inside of that JSON file, and now let's build a mock environment and server for that, so that we can test these directly, or we can test these without the implementation being completed. So it's gonna go through the process here of doing that. And again, as it does this, it keeps adding to that metadata, and the reason it can do that is because we told it to do that in the steering file, right? If I had to rely on the end user to do that, you, I don't, I couldn't rely on you all to do that, right? So we automatically package that up for you to do that. Uh, so the mock server was automatically created. And again, this, the only thing I had to tell Kierra to do was look at my code, right? I didn't have to write a spec. I didn't have to do anything like that. I said, investigate, look at my code, create this collection. Once you create the collection, now you know everything about that, go create this virtual environment inside of Postman. which has a mock server in it, and all the environment variables that I need. And now I can actually go and test this and get, oh, and get test data back to be able to run that collection, right? Um, and as I said, this is really great because, you know, now I don't have to, the other team, if I'm a downstream team, I don't have to wait on me to finish it, and I can also just start to test that right here inside Akira, so I wanna make sure it works for the other team. Now why this is cool and why I wanted to show this is. This is a standard test that we're gonna run, not only just to validate the collection work and the mock environment worked, but it's also gonna be called every time I make a change to the source code, because I automatically packaged a Quiro hook inside of it. So one of the things that you would do as you're developing your APIs, you want to go back and test it and make sure everything works. So now automatically when I change the source code and save it, Kiiro knows that because there's a hook inside of there, and it's going to run that same collection in that mock environment that we created and make sure everything still works, right? So now we've got this closed loop system. So this is one small example. Like I said, we have over 100 tools inside of our MCP server. You know, you can do everything from creating collections and workspaces and sharing them and also generating other code. So we're really interested and excited to see what y'all are gonna do with it. It's available today. You can go install it from the Quiro marketplace, and we also have a Discord server. We'd love to get your feedback. Uh, so if you could take the time to join, we'd love to hear it, and, uh, you know, hopefully you'll get a lot of value out of it. So thank you. Tyler. Let's see your personal finance app. Thanks, Harry. Cool. Hi everyone. I'm Tyler and I'm, uh, Deverel at Superbase, and today I'm gonna talk to you about Superbase and the Koower that we're launching. For those who don't know what Superbeast is, Superbeast is a back-end platform loved by many developers across the world. We have 5 million developers shipping over 90,000 databases every single day. And we have shipped in total 60 million databases. Today Earlier this year, we shipped our MCP server. The Superbase MCP server includes numerous tools for building applications on top of Superbase. You can do things like list out tables. Manage your database migrations. Manage your storage bucket, really anything that you can do within the Superbase platform. This MC MCP server forms the backbone of our QO power. And I am happy to announce. The QO power for Superbass. We are announcing two QO powers from Superbase. 1. To work with your local Superbase database. And another to work with a hosted Subabase database. So that you can start locally. And deploy your Superbase database to your cloud. It uses a Superbase MCP and the Superbase CLI to build, manage, debug, and scale application with the help from an LLM. Not just having access to these tools, but the superbase KO powers. Understands the best practices. of how to use Superbase and how to use Eposcus database. So you don't have to be a database expert. In order to get building on a Poscu database. Now let's see it in action. It's all good. So I'm gonna start With a plain beat up. I'm gonna go ahead and install the superbase local kilo kilopower. I'm gonna hit install and hit try power, and off we go. We're going to start up by the. Onboarding flow, and it's going to check things like whether I have docker running, whether I have the Super BCLI installed. And whether I have initialized the Superbase project uh within the working directory. Now, I hadn't initialized Superbeast in here, so it went ahead and initialized Subabeast for me. And then now it's fetching the Superbase credentials and creating an environment bearable environment file for me within this project directory. Now, once all the initial setup is done, we are going to jump into building some tables. So, I'm also gonna work on a personal financing, personal banking app. So I'm telling Keo here to create all the tables that you need in order to build a personal banking app. And Keo is able to understand all the best practices to build tables, best security practices when it comes to Superbase, and incorporate all that in here. So it has created the tables, it has created all the necessary security safeguards. To make sure we create a nice and safe banking app. Now one of the key powers that we're shipping is this security check. It's part of a Sub core feature, and what it allows you to do is it. It's able to take in all the best security practices and make sure all the tables and various configurations are following those security best practices. I'm gonna go ahead and run it And it actually found something, some problems. So Ko was able to quickly fix that up. By running another SQL segment. Now, another favorite thing about Superbase, another favorite thing of mine about Subabase, is that it can generate type script types that matches your table schema. And Keo's doing that for me, without me having to tell it to generate all these type, TypeScript types. It's able to understand that we're working in a TypeScript environment. And Subabase has this TypeScript generation feature. And we should probably generate some type script types. And there you go. Here it has created the TypeScript types and now installing the Superbase JavaScript client library. So generating all these TypeScript types, installing the Superbase client libraries, these are standard practices that we follow. And he was able to do that um without me having to interfere with any of the prompts. It understands all these best, best practices, uh, that it needs to do in order to get started with a super-based project. Now, finally, once all the tables are created, all the configuration is set, Keo's generating all the database migrations. And after a while, let's check out the migration file that I created. So you can see, QO has created a nice account stable for us with all the comms that you would need for a personal banking apps, like user ID, account type, balance, currencies, It also generated other tables too, like budgets, categories, transactions. All the tables that you would expect in a personal banking app. And then you can view that within the Superbase dashboard. You can see the transaction tables, budgets tables, all being associated to the Aha user ID table. So it has taken all the best practices that Superbase offers. And put it all together. Now let's come back to QO. And keep going So it's now generating some front-end code to connect to our Superbase database. This is a TypeScript type that I mentioned earlier. And as, as you can see, we have all the matching typescript type that matches the table schema. Now, let's go ahead and create a new chat session. And work on the UI. So the prompt here that I'm giving it is basically saying, hey, I have these tables in my Superbase project. Please create a UI that matches what I have in the tables. This is one of the neat tricks that I like to work on, uh, neat. This is one of the neat tricks that I like to use when building apps using Superbase and large language models. I like to start from the tables. And then once I'm done with the tables, I have it generate the UI because having a nice airtight table structure is very important. And once all the tables in place, LLMs are generally really good at understanding what's going on and figuring out the best UI that goes with those tables. So Ko is analyzing all the schema that we generated. And it's generating all these UI code to display. What we saw in the database on the front end code. And just like that, We have some nice set of proto code. Let's run the local dev server. And check it out. So The UA looks good, it looks like a personal banking app, but we don't see any data, right? Well, that's because we just created the tables, but we haven't inserted any data into it. Obviously. So, Let's go back and ask Keo to add some dummy data into the database. And Keo, again, is able to figure out how to insert dummy data into Superbase, what the best practice is. And it's running some SQL command to insert. Some dummy data into all the tables that we created earlier. And after inserting all these data in 4 different tables, It double checked, double checks that all the data has been inserted. And then I've asked you to create a local seed file to keep all these dummy data. Persisted within this project. Looks great. Let's go ahead and check it out. Now, Within the superbase stable, we had those dummy data, but it looked like. We haven't signed into the app yet. So, I'm asking Kyo to add authentication to the app. And Keel's able to figure out. The structure of the Superbase project, the fact that, um, obviously the passwords are encrypted, so you wouldn't be able to insert just 123456 into the passwords column, you need to properly encrypt or hash the passwords. It's able to figure out how Superbase does it. And Able to do that. It's able to self-correct it. So on the first shot, we missed it, but I've gone ahead and uh asked you to. Make some fixes And It's on its own, was able to figure out that, OK, the Superbase local dev server needs to relaunch. So without me telling it, he was stopping the Superbase dev server, relaunching it, loading in all the see data that we created again, and resetting the scene so that the proper authenticated user is created within the database. And so far, I have done minimal steering. It's all the Keog's steering file that's doing all the heavy lifting. And with some edits from Ko. We are able to sign into the app, and as you can see, you can view all the dummy data that Qo created in this nicely authenticated, proper personal banking app. So that was QO Power from Superbase. Again, we have the local version and hosted version. And I hope you like I hope you liked what you saw, see, and I cannot wait to see what you build with it. Thank you so much. Thank you again Harry and Tyler. That was really great. Uh, we really appreciate both of, both of you coming here and talking about the powers and, and this both powers are super useful. I've been using both of them for, for my own application development, so I, I, I've, I've really benefited from actually learning a lot about Postman and Super Bass over this last month. Cool. So what's next? There's a lot of, uh, a lot of questions, uh, I think available in the CLI we wanna actually make we have a hero CLI if you don't know, uh, we also wanna make it available more broadly. Uh, more use cases, more partners, we've, we have a, uh, on our website we have a way for you to submit, uh, a form and actually send us powers, and we, we're reviewing them weekly and if we find interesting ones we can curate them. You can do it as an individual as well, by the way. It doesn't have to be your organization. If you have uh a specific use case that you wanna highlight and it and we're we're it meets our bar for adding him on we we're happy to do it. Um, I think organizational use use cases are gonna be a big one. So being able to govern like powers around what powers teams can install is gonna be, uh, another feature that we add, and I think our, our goal here is really for Quiro. The, the keyro agent has powers, and over time, like, uh, a key agent should be able to discover powers and say, hey, you're trying to do this. I know there's a power to do to solve this problem without the user actually having to like explicitly go and say anything. Yeah, so, as I, as we said, you can go ahead and start using it right away on Quiro, and thank you so much again everyone for taking your time. I appreciate everyone joining at 4, you know, at 4 p.m., and, uh, I'm happy to take, uh, questions if you have questions. Happy to kind of if you come up and we can, uh, take take questions. Thanks again.