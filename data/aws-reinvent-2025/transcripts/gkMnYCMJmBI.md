---
video_id: gkMnYCMJmBI
video_url: https://www.youtube.com/watch?v=gkMnYCMJmBI
is_generated: False
is_translatable: True
summary: |
  Ram Maharajpuram and Vaishnavi Merugu unveiled outbound identity federation for AWS workloads, giving builders a native, standards-based way to exchange AWS credentials for third-party tokens without managing passwords or long-term keys. Ram demoed the end-to-end flow from an EC2 instance: enable outbound federation (which creates a tenant-specific issuer URL and signing keys), call sts:get-web-identity-token to mint a short-lived JSON Web Token (default five minutes, extendable to one hour) with an audience claim for the relying party, then present that token to Azure’s token endpoint using the JWT-bearer grant to obtain an Azure access token. With that token he invoked Azure Graph APIs, and he showed how Azure validated AWS-issued tokens using the well-known OpenID configuration and JWKS endpoints hosted at the account-specific issuer URL.
  The decoded JWT illustrated two classes of claims. Standard OIDC claims (iss, sub, aud, exp, jti) convey the IAM role or user federating out. Custom AWS claims, all namespaced under sts.amazonaws.com, add context: AWS account ID, source Region, organization ID and OU path, principal tags and session tags, compute context (e.g., EC2 instance metadata or Lambda function details), and the upstream federated provider if one was involved. Callers can also inject request tags as additional claims for downstream authorization. The token uses asymmetric signing (RS256 or ES384), and Ram noted that connections to the issuer endpoints are over TLS; any JWT library can validate the signature using the published public keys.
  Vaishnavi framed the benefits: removing long-term credentials addresses a major source of security incidents (about two-thirds of AWS customer IR cases start with a leaked key), simplifies operations by eliminating secret rotation and bespoke presigned-URL flows, and works across clouds, SaaS providers, on-prem services, or even between an organization’s own applications. She detailed the permission model: only principals with sts:GetWebIdentityToken can mint tokens, and new IAM condition keys enforce guardrails—identity-token:audience restricts allowed audiences, sts:DurationSeconds caps token lifetimes, and sts:SigningAlgorithm pins acceptable algorithms. The feature is available in all commercial, GovCloud, and China Regions at no additional cost.
  Best practices include keeping token lifetimes short, validating signatures and authorization context before trusting claims, leaning on AWS-provided context claims for fine-grained downstream authorization, avoiding logging tokens, and always using TLS. The team suggested using the feature as a general-purpose way to introspect session context (e.g., tags) and highlighted that AWS operators themselves expose only public signing keys, never private material. They closed with links to a blog walkthrough and full documentation, positioning outbound identity federation as the secure default for connecting AWS compute to external APIs without ever provisioning static secrets.
keywords: outbound identity federation, JSON Web Token, Azure integration, short-lived credentials, IAM condition keys
---

Oh, it's one o'clock. Hey everyone I hope you're having a great time at Reinvent. So before we get started, um, quick show of hands, um, how many of you hate managing passwords? Access keys, long term credentials in general. All right, that's pretty much everybody in the audience here. Uh, so we have some great news for you. Um, a, a, a new launch. My name is Ram Maharajpuram. I am a senior software development manager and head of engineering for, um, Security Token Service, and with me here today is Vaishnavi Merigu, a senior product manager on the team. And we're here to talk to you about our latest launch that makes it easy for you to connect your workloads to external services. Oftentimes builders have to trade off between security and ease of use, and with this new solution you no longer have to face that dilemma. You now have a native way to exchange your AWS credentials and use them to connect to any third party. Services, so this could be other cloud service providers. It could be on-prem workloads. It could be SAS providers. So cloud service providers like Azure, GCP, SAS providers such as Databricks, Snowflake. And you could do this natively using the AWS credentials that are already available to you for any role, any IAM user. These credentials more often are actually delivered natively to the compute that you're using AWS Lambda, EC 2, Amazon EKS, you name it, we have a secure way for you to connect those workloads to these external services. And we do this using standards aligned JSN web tokens or JORTs for short, and with this you no longer have to use complex workarounds, and you certainly do not have to manage any long term credentials. So I'm actually going to do a quick live demo of this feature. What I'm going to be doing is I'm going to be connecting my EC2 instance to Azure and make calls to Azure APIs without ever having to create an Azure access key like a long term credential or setting up a password. So what I have here is an EC2 instance. Um So you can see here that it is live, and um I'm gonna kick this off by running a script that I've prepared for you. Uh, we're going to go through 7 steps. The first of these is to basically just check what credentials I have. I ran the command AWS STS get caller identity. It's basically the who am I command that we have on AWS. And what you see here is I have credentials that belong to an EC2 instance role. So when you spin up an EC2 instance, we actually have short term credentials, session tokens that are delivered for you. These are valid only for a few hours, and these credentials can be scoped down however you want, and I'm going to be using these credentials for federating out into Azure. So in order for you to use this feature, you would first have to go ahead and enable the outbound identity federation feature. I already have this feature enabled on my account, so I'm just using the get version of this command AWS IAM get outbound Web Identity Federation info, and what I get here is a JSON with two elements. The first element is an SCR identifier. So when you enable this feature, we create a set of asymmetric keys for your account. We also create a unique identifier for your account, and we host the public keys corresponding to it on this URL. And your relying party can then call this URL and get those keys. We'll get to that in a bit more detail later. And it also says that JART vending enabled is true. That's exciting. So let's actually go look at what that JART actually looks like. So I now ran the command AWS STS get web identity token. The response that I got has two elements in it a web identity token and an expiration time stamp. I truncated the token just so that we don't, it's, it's easier for us to kind of talk through it, but essentially this token has three parts to it. There is a header that's shown in green color here. There is a payload, and there is a signature associated with that token. There's also an expiration time stamp. The expiration here by default is 5 minutes. You could also extend that beyond 5 minutes up to an hour if you would like to do so by just passing an API parameter to this. And you can also see that I passed an audience parameter into this call because we're going to be using this token to exchange with. And um we also have a signing algorithm here. I chose RS 256, but there are other options available for you as well. Um, so let's just actually look into what is inside this token. Um, so all I did is I um Did a base 64 decode on this token and ran it through a uh JSON parser. um so what you see here is a subject and the subject here is nothing is is basically the same as my EC2 instance role that we used in order to get this jot. Um, you can also see a bunch of other standard claims including the issuer that we talked about earlier, an expiration time stamp, an issuer time stamp, and so on. And there is also a bunch of interesting credential specific or workload specific claims that we have names space to sts.amazonaWS.com. This includes things like properties of your EC2 instance. It includes information about your arg if you have one. It also includes things like the tags that you actually have on the roll, and if you have session tags and so on, those will also appear here. There's an interesting kind of off label use case here. You could use this feature to go introspect your authorization context and get additional information on like what tax you have and so on if you are kind of going through troubleshooting and what have you. Um, so here's the moment of truth. What I did is I took that credential and I exchanged this to an Azure access token. So in order to do that, I posted that token to the Azure token exchange endpoint. I passed the grant type as client credentials. I said that the assertion type is Jatt barter. And I got essentially a token back. Now what I can do is then use these tokens to go call other Azure APIs, and what you see here is that I'm using this token to call the graph API for an application that I've already set up. And the API that I'm calling is Federated Identity credentials. Interestingly, this is all the setup that I had to do on Azure in order to connect my application. So I gave Azure the subject, which is the easy to instance role. I gave Azure your URL, the unique URL for my account that we talked about earlier, and the audience, and I created a federated credential using that, and that was enough for me to securely connect to AWS. Now we spoke about those if your URLs, so you may be wondering how did Azure actually validate the token that we gave to it. So what we publish is a couple of well known endpoints on that if your URL. The first is called the well known open ID configuration endpoint. This basically tells you what kind of claims we support, what kind of token algorithms we support, and a URL for the JSN web key set. This is where our public keys are actually hosted, and then. What you see here is I'm also curling the Jason web key document, and you see here that the public keys corresponding to the RSA algorithm type and an ECDSA algorithm type are available. So what Azure did behind the scenes is they went to the configured point. They then figured out what the JWKS endpoint was, and they then subsequently call that endpoint to get the public keys and validate my token. Now if you're using this for your own workloads, we've made it super easy for you. You can pick any library that understands parses chas and web tokens, and those libraries would be able to natively do this for you. We have some example libraries on our documentation. And to tell you more about the claims and additional fine-grain controls that we have, I'd invite Vaishnavi on stage. Thank you, Ram. Um, So now that we've all seen an exciting demo of this feature, let's talk about what are the primary benefits of using this feature. The first one's obvious, right? This is enhanced security because you're now eliminating long-term credentials from your environment. So, quick interesting fact, 2/3 of the cases that come to the customer incident response team are due to an initial access by an unintended actor using valid long-term credentials. So take advantage of this feature and replace your long-term credentials with short-lived Jason Web tokens for secure access to external services. The second one is reduced operational complexity. You no longer have to manage these long-term threads or rotate them frequently. You don't, if you were using pre-signed URLs and complex authentication flows to integrate with these external services, you can replace all of that with a simple few lines of code, a simple API call to get web identity token API, and get a jot for authentication with external services. Third is the interoperability. So this feature was designed to be interoperable with many of your external cloud service providers, SAS providers, and even used for authentication between your own applications hosted on cloud or on premises. Now let's actually do a quick recap of the claims that you just saw in the demo. So the claims can be broadly categorized into two. The first one is your standard OIDC claims. So these are again designed to be interoperable. So we have the standard subject claim which identifies the role or the user or the IAM principal that's being federated to the external service. We have the audience of the token, we have the expiration time, a unique identifier for this jot, and the issuer URL. Then we have a set of custom claims that AWS puts in the token on your behalf. All of these claims are names based under STS. Amazon AWS.com, and this includes identity context, session context, compute context, and even your principal tags, the request tags that you can add to the token. Let's actually pay special attention to the issuer URL here. So when we were building this feature, we thought what would be a a good way to deliver a secure by design experience for customers? And we decided to go with an issuer URL that's specific to your AWS account to guarantee tenant isolation. So now let's look at the custom claims within the token. The AWS account ID is included in the token. This helps the downstream service validate that the token is coming from the account that you trust. We also include the source region, which is the AWS region from which the token generation request was made. If your AWS account is part of an organization, we include the organization ID and the OU path in the token as well. Then we have principal tags. So if your IAM principal, like your role or your user has tags attached to them, those tags show up under the principal tags. And if your assumed role session has session tags attached to them, the session tags also show up in the principal tag section. Both of these can be used for fine-grained authorization in the downstream service. Then we include some context that's particular to your compute. So in Ram's example you may have seen that there were some claims pertaining to the EC2 instance. So for example, if it was a lambda function that's actually federating its identity, you would see lambda function specific claims in the token. And if the identity originally federated from an external provider, we also include the federated provider on. And there are a lot of other claims that are very specific to your session context and your compute context. You can go through the full list on our documentation. Now, if you wanted to add your own claims to the token, you could do that by passing the tag parameter to the API call and specify the key value pairs. All of these would show up under the request tag section in the token, and you can use these again for fine-grained authorization in the external service. Now, let's talk about how you can control access to this feature for your IAM principals. So the permission to keep in mind here is the STS get web identity token. Any IAM principal who has this permission in their policies will be able to generate JSON web tokens for authentication with external services. So you can use this permission in any and all relevant policy types like your SCPs, RCPs, identity-based policies, VPCE policies. We're also introducing 3 new condition keys as part of this feature. The first one is the identity token audience. Using this condition key, you can restrict the list of audiences and ensure that your IM principals only generate tokens for these audiences, and if they try to generate a token for any other audience, the request will fail. We also have the STS duration seconds, so this condition key can be used to enforce maximum token lifetimes. So tokens are valid for 5 minutes by default, but the token lifetime can range anywhere between 60 seconds to 1 hour, and you can set maximum token lifetimes that suit your operational needs and your security requirements. Finally we have the STS signing algorithm. So we currently support two signing algorithms, ES 384 and RS 256. So you can use this condition key to specify the signing algorithm to be used to sign the token. Now, let's talk about a few best practices. Before that, let me tell you that this feature is available in all AWS commercial regions, GovCloud regions and China regions at launch, and this feature is available at no additional cost to customers. So like I mentioned before, the primary goal of building this feature is to eliminate long-term credentials from your environment. So please replace all your API keys, your passwords with short-term, short-lived jots. And make them as short as possible to prevent unintended access. Look at the authorization context in your token after you validate the signature, so ensure that the token's actually issued by AWS and it's valid before you look at the authorization context. Also look at the custom claims in the token that AWS populates whenever possible to do more fine-grained access control in the downstream service. Make sure you don't log these tokens. You can request for a fresh token anytime you need and also make sure you send these requests over TLS. You can refer to these QR codes for more resources. The first one is our blog post, which talks about a walkthrough of how to use this feature, and for an in-depth guide, you can look at our documentation as well. So thank you so much for joining us today. All right, and, and please do take the session survey once it pops up on the app. Thank you very much once again.
