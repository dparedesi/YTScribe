---
video_id: LPo4kI656bY
video_url: https://www.youtube.com/watch?v=LPo4kI656bY
is_generated: False
is_translatable: True
summary: "This session, titled \"AWS Security Agent: Proactive AppSec from Design to Deployment\" (SEC348), introduces the AWS Security Agent, a transformational tool designed to shift application security from a scarce, \"rationed\" resource (described as the \"Candle Age\") to a plentiful, ubiquitous commodity (the \"Electricity Age\"). Speakers Neha Rungta and Neha Goswami demonstrate how this agentic workflow integrates proactive security checks into every stage of the software development lifecycle—design, coding, and testing—without slowing down developer velocity. The session begins with the Security Design Review capability, automatically validating design documents against two types of security requirements: foundational industry best practices (e.g., \"Secure by Default\") and custom, company-specific policies (e.g., mandating Post-Quantum Cryptography or specific IAM integration libraries). Rungta showcases the agent's flexibility by running reviews not just on standard design docs, but also on raw feature requests and even meeting transcripts. In a live demonstration using \"AWS Suits Manager\"—an internal \"dogfooding\" application—the agent analyzes a feature request for resource policies and instantly identifies a violation of the \"Block Public Access\" requirement before a single line of code is written. It also flags unsecured credentials hidden within a meeting transcript, illustrating how proactive security can now cover unstructured data inputs previously impossible to review manually. The presentation then transitions to the Security Code Review feature, where the agent acts as a diligent peer reviewer on every Pull Request, checking code changes against the exact same governance standards defined during the design phase to prevent implementation drift. Finally, Neha Goswami unveils the Automated Penetration Testing capability, describing it as a \"Frontier Agent\" capable of autonomous reasoning and complex task execution. Unlike traditional, slow-scheduled pen tests or superficial DAST scanners, this sophisticated agent utilizes a multi-step workflow: a \"Pre-flight\" step to build a sitemap, a \"Planning Agent\" to orchestrate parallel attack simulations, and a \"Validation Agent\" to rigorously filter false positives. A key differentiator highlighted is the agent's transparent execution log, which details its step-by-step \"chain of thought\" and reasoning strategies (e.g., how it attempted privilege escalation), allowing security teams to verify and trust its conclusions. Crucially, the agent goes beyond merely reporting bugs; it acts as a full-cycle remediation engine by automatically generating Pull Requests to fix identified vulnerabilities—such as critical business logic errors—thereby closing the loop and allowing security teams to keep pace with the exponential velocity of AI-assisted software development."
keywords: AWS Security Agent, Proactive Security, Automated Penetration Testing, Security Design Review, DevSecOps, Post-Quantum Cryptography, Verify False Positives, Agentic Workflow

Hello and welcome everyone. My name is Neha Runta, and with me today is Neha Goswami. So you have not one but two Nehas, and we'll be showing you what's the latest and greatest in proactive security. It's something that we've been building for the past few years and also past few months, sorry about that, and also been using within AWS, and I'm super excited that we are finally getting to share this with you. And here's our agenda today it's all about proactive security. It's all about enforcing your security requirements earlier and earlier in the development life cycle, and I do wanna call out a development life cycle is not linear, it's this chaotic cycle, nonlinear process, but the key is it's still gonna be early in the process. And what that's concretely means is bringing your security requirements into the design review code review as well as the penetration testing. But first, before we talk about that, we're gonna go way back, way, way back when light at night was a luxury good, when it was expensive and therefore rationed out carefully, only the rich had access to light at night. And even then it was used sparingly. That was until electricity was invented. Today light is a commodity it's everywhere and that's changed what light means to us. It's no longer something that's exclusive, no longer means that it's something that needs to be rationed out. Until recently, proactive security has still been in the candle age rationed out, used sparingly, but the invention of large language models has fundamentally changed that. It's now the electric age for proactive security. Today we're going to see what a world of plentiful proactive security looks like. How and what can we do when proactive security is as common as lights in Vegas when security design review is cheap and fast that you can do it any time anywhere you want it when security code review happens on every pull request, when penetration testing is on demand instead of a scheduling headache, can I get my 3P to actually do the schedule? That is the AWS security agent. Security requirements are the foundation of proactive security. And we like to think there's broadly speaking two types of security requirements. First, there's industry best practices. These are things everybody should follow. These come from our collective knowledge as software developers, and they evolve slowly over time. And second, there are company specific requirements that come from a particular domain. It comes from the industry domain. It comes from the countries that you operate in or the policies of the company itself. So as we begin, let's start with this industry specific one because it will apply to everyone broadly. There are these are examples of general purpose security requirements, for example, secure by default this ensures that the system's default configurations are secure. And that it requires extra work, extra steps to move outside of the safe default. Traditionally this is a design goal, but it's not enforced anywhere it's hard to check during design time is the system secure by default. And here what we rely on is the knowledge and best intentions of our developers to stick to the goal because they have to know that secure by default is a goal and then have to know how do I check whether my system is being designed to be secure by default. In the security agent we codify these best practices as AWS managed security requirements. Here you can see there's about 10 managed security requirements which we ship in the AWS security agent. You can take a look, you know, when you go into the console, and here's the one we have for secure by default in addition to a name and description, which are two of the critical fields, there is an applicability of this. Why does it matter? Why is it relevant? And one of the things that we found is that there's no shortage of security requirements. They're a dime a dozen. They're like, hey, you should eat your vegetables, you should eat your broccoli, they should eat your cauliflower or, you know, your spinach. Great. But why does it matter? Why does it matter to the particular, uh, application? And that's what this tells us. Second, we have a compliance criteria. What does it take for the service or the application to be compliant with that security requirement? This is a part of the AWS managed security requirement. Now let's take a look at how the agent uses these security requirements and to do that today we're gonna use this fictional AWS service. You ready? We call the service the AWS Sus manager. And let's run this design doc through the security design review process. Now what would normally take hours, days, perhaps even weeks can now be done in minutes. We start by creating a design review, uploading our design doc, and clicking start design review. In minutes we have our results we can see which of the security requirements are compliant, which are not applicable because context matters not all security requirements are gonna be applicable to all applications. Which ones have insufficient data? Here it doesn't have any, but for many your doc may not have enough data to say does it even matter? And which ones are not compliant. There's one here that is not, so let's dig into the details here it says the secure by default requirement is not compliant. Let's find out why. It is because one of the user created resources, a box, is shared publicly by default. Here it is. It tells you why. It tells you why it is not secure by default. But then the agent also gives remediation guidance on how we can update the design doc to satisfy the security requirement. The advantage is now you've caught this early in your design phase before a single line of code is being written. Another feature is the code review. You can connect your GitHub repositories and the security agent will review every pull request against the same set of security requirements because some of the requirements may be applicable to the design part and others may be applicable to the code and where they're applicable to both your evaluation will happen on both of them. Let's say a developer. Or any of you had a great idea for a new feature. Maybe it's so great that you don't even need to begin with a design review. I mean, I feel all my ideas are so great that I never need a design doc and I can just start coding and now with the coding assistance it's become even easier you can get started so easily. The security agent will read the pull request of this feature and flags an issue where only the recreated resources are shared by default instead being secured by default. Great. Those are that was an example of how we could do industry-specific best practices. The similar thing applies to company-specific requirements. These are very important because they are relevant to your organization. Now your specific ones will depend on your organization. What's your business? Maybe you have requirements about how identities are granted access to applications or maybe you require a multi-party authorization contingent authorization for sensitive resources. You may have specific encryption requirements. Audit logging, you can have a whole bunch of them, what types of data should be logged versus not logged. Whatever your particular security requirement, the security agent is designed to capture them. Let's look at an example of how you can specify one of your examples. Let's say you want to have encryption. Your particular security requirement is that post quantum cryptography must be used. You can create this, and there are 4 main parts very similar to the AWS managed ones. First, you need a name and a description. These are for your benefit so that it can help you identify the requirement and explain the high level purpose. The second very similar is the applicability. Why does it matter? What types of systems does it apply to? Does it apply to all systems? Is it a global type of requirement? Or is it, hey, for this class of systems these should be true? Third is the compliance criteria. What would it take for this requirement to be met? And this really is to help the end developers to know, you know, what should I do to fix it? If you just say this is broken, great, what do I do? How do I fix it? How do I get this to be compliant? And with, with, with that you can say maybe you can provide links to the internal documentation or even recommendations for particular libraries or services to use. I'm developing a web application. How do I know what credit card processing libraries is approved by my system? This can be a place where you can specify it once and every developer in the company can just use it out out of the box. Once you've created your custom requirement, they will sit along right side the right alongside the managed security requirements provided by AWS, and they will apply to all your design and code reviews going forward. Let's see how it does on a fictional service, the suits manager. Same as before, we upload our design document and start a new design review. Uh, in this case, we have one additional noncompliant security requirement. We are failing the new post quantum cryptography requirement. What do we do? It's the same as before you click on it you, you look into the details of why the security requirement is not compliant and what we should do to fix it. It's telling me now I can do it. What about code review? Same thing as before. The new security requirement applies as much to the code review as it does to the design review. Here we can see it flagging a pull request which is using traditional cryptography instead of the post quantum algorithm. Finally, I want to give you a look, you know, behind the curtain how at AWS for the past few months we've been using the security agent. I've told you about company specific requirements. Well, AWS is a company. We have our own internal security requirements, lots of them, and we've been using the security agent to capture these requirements and increase the velocity of our developers applied to their design reviews, applied to their code reviews. Here's examples of AWS specific security requirements. That these are about how we build services to ensure that they're safe and secure for all of you, all of our customers. I want to highlight the last one here. This is how we. Uh, I wanted to highlight, sorry, I'm gonna back. We launched an IM integration library. Now this is only applicable to AWS because services in AWS need to integrate with IAM. All services need to integrate with IAM. To help those service teams, we launched a new automated reasoning based proven correct library to integrate with IM. This is a remarkable piece of software. Uh, it's a core security primitive that we have developed internally for our teams to be correct, move faster. But how do we ensure that teams end up using it? The AWS security agent is a mechanism to ensure that all our service teams end up using this. It turns an intention, hey, all of us should really be using this library that's verified correct that helps us move faster and gets everything done correctly to a. How in an organization, large organization with multiple teams, the AWS security agent says, oh, you should be using this library. And there it is, the daffodil library, it's an internal thing. It's only applicable to teams in AWS. And now it's an easy way for all teams to know about hey I need to integrate with the daffodil library to make it easy for me to do my IAM integration. We've made some improvements to our design doc, but now it's failing this particular security requirement. Just like before, we can view the details of the security requirement and what we need to do to fix it. This Quick, easy, automated design review has been a boon for our internal teams. Here is a quote from one of these teams after using the security agent on their most recent design review. It's really highlighting the power of proactive security. It's catching the issues early we can fix them early, which means it's a lot faster and cheaper to catch issues before they hit production. We know as it gets harder. More expensive the later you find an issue and the when you fix it. We have integrated this also within our internal code review systems. Now in AWS most teams here don't use GitHub, so we've integrated the agent into Amazon's internal code review system so the teams can get feedback during their code review process as well. We've seen tremendous benefit from catching these issues early. It's helped the velocity of our developers, and these are not just some generic security issues. These are issues tailored to AWS's specific security requirements that we impose on our own internal teams. So, are we there yet? Have we left the candle age of proactive security? Not yet because we're still replacing existing security reviews 1 to 1 with the security agent and it's a good start but it's still thinking of proactive security as a luxury good to be rationed out. It's like living in the age of an electric candle, an improvement, but it still leaves the world a very dark place. So let's look at how we're doing proactive security in ways we had never considered before. How is it actually transforming the whole space? Here is a feature request for a suits manager, the ability to share resources using resource policies. Maybe one of our engineers will go off for a week or two and write a design doc that we run through the security review afterwards. But why wait? And I know some of you, some of you are thinking this is nuts. Or I'm crazy, which could be both true, but I am serious. Why can't we do a security design review of this feature request as is? OK, let's try it. Let's upload this to the security agent. Look how tiny it is. Is there anything even worth reviewing here? Apparently so. Now most of our security requirements are either not applicable or do not have enough data, which is to be expected given what what's the input we gave it. But one of our security requirements is already not compliant. This is block public access. Looking deeper We know AWS requires that all new resource based policies require block public access for any of you who've used S3BPA, you can turn it on with one click to ensure your resource is not public today. It's not gonna be any public anytime in the future. Most, a lot of the services support it, and it's a requirement for all new resource policies to support that. Now this is huge Instead of spending weeks designing the feature before finding out that this critical requirement we now know before we even get started this is what proactive security means in the electric age. I'm gonna look at one more example. The previous example was about a super short form content. So what about super long form content? For this I wanna tell you a funny story, and it's a funny story that is true. I've been talking about the suits manager example as this fictional AWS service. But the truth is, we built it back in 2023. It was used as a demo application. We are all about dog fooding our own services and features, so we built the Suites Manager as a way to see how easy is it to use our own services, how can, what would we do to build an application for various features and integrations. And it actually works. You can create a box of sweets, share it with people you can even share the box of sweets with Andy Jasse, our CEO. That's what the application does. It's a full application. And as part of this, one of our engineers had an hour and a half hour meeting who had and walked through it, how it was created, what were the different services that were used, what, what services worked well, what were the pain points as an end user while developing the application, explained where the where the pain points were, what was easy, what was hard, so we had an idea. Why not see what the security agent thinks of this meeting? So we uploaded the transcript. And created a design review for it. There we go, the transcript for that meeting. And here are the results. Most of them didn't apply. Again, not surprising. But I was interested to see what actually failed. The meeting was noncompliant for best practices around secrets protection. Let's see why. It looks like there's direct usage of sensitive credentials without proper protections in place. Now this is not unexpected for a demo meeting but a fair point nonetheless. These are not things that we would have thought of to do a security review, a feature request, a meeting. This is creating the transformation in proactive security as strange as these cases may sound, this is what moves us out of the electric candle age to the one that we live in today. Into the electricity age when proactive security is used in ways that none of us had even imagined yet. That is the power of the AWS security agent. Now I talked about two parts of it the design and the code review. And to keep the electricity flowing, I wanna invite Neha Goswami to tell you about how the security agent does penetration testing. Thank you Neha. Um, hello everyone, I'm Neha Goswami. I worked with Neha, uh, on this security agent for the last, uh, few months, not few years, and it has been a fun journey and, uh, continuing the theme of, uh, electricity age going from a candle age to an electricity age, I want to talk about pen testing and describe how that, uh, candle age to electricity age transition has happened for pen testing. So Even in Amazon pen testing happens very late in the development cycle today. Developers have already done the work to identify what they want to build. They've written the code. The code's checked in, and your features ready to go live, and that's when the security team is engaged to do pen testing today, and it's done by a dedicated team. Love our security team. I love our security engineers. But we always hate the fact that we now have to wait a few weeks for them to finish their work. So why do we have this process today? This is what I'm calling the candle age. Uh, the expertise for pen testing is limited, so a lot of companies are outsourcing this work to other companies which are specialists to do this. Um, what else is the candle age? It's a really slow process, as I said, it comes at the end of your development cycle. And you have to engage another team to do it. These pen tests need to be scheduled really early. There is a lot of calendaring time that gets absorbed in this. And the last thing is, uh, even the pen testing companies themselves, uh, end up giving you some very basic vulnerabilities that you could have maybe easily caught ahead of time. So the value themselves, the value itself, uh, by the pen testers is not as high as deaf teens are expecting. And this is something we hear from customers too, so it's not just an internal Amazon observation. This is, uh, this comes up in our conversations with real customers as well. They have to do all the scheduling ahead of time and they're finding that the value again is very limited because DAS scanners are doing a lot of this work already and the connection between the vulnerabilities detected and the kind of logic that is in the application. Is not always great. So let's talk about the electricity age. The AWS security agent makes pen testing easy and on demand, so you don't have to wait for another team to actually conduct these tests, you know, call them ahead of time, schedule them, get on their calendars. You don't have to do any of that. You can actually run it as and when you need it. It's very fast so it's not going to take months or weeks for us it's been weeks, uh, forever, uh, that this process takes for complex applications and now we can execute it in hours and days and that's very, very powerful. And the third one which I talked about, the DAS tools which are giving you very generic vulnerabilities, you get a lot more relevant results when you use the pen testing agent because it takes in the application context, it takes in the design document that Neha talked about, and you can upload all sorts of details about your application for this agent to use. I think uh for any of you who heard uh Matt Garman talk about agents yesterday, he talked about uh frontier agents, frontier agents that run autonomously that handle very complex tasks and that need little steering. AWS security agent is one of those frontier agents and uh I will take you behind the curtains on how we do pen testing and you will see how and what makes it really a frontier agent. So Here's how it works. So the pen testing agent will take inputs. Uh, one is your API endpoints that you are trying to test. The other is the credentials that you need to log into that API endpoint, a bunch of documents which are relevant to your application, and code repositories. It will take all of that and run through the pre-flight step. What does the pre-flight step do? It basically just checks that endpoint to make sure it can authenticate and log in, uh, and it makes it creates a site map because you've given it a lot of application context. Based on that, it creates an understanding of the application, feeds all of that information into the planning agent. The planning agent is nothing but an orchestrator and a coordinator of sorts. It starts to execute multiple pen tests in parallel. All the pen testers that are running in parallel will take the findings and feed that into a validation agent. Uh, the validation is a super important part, uh, of our workflow over here, uh, that actually checks to see which are real vulnerabilities and which are the ones which, uh, don't seem like false positive essentially. So it does a lot of filtering to make sure that the findings are relevant and the findings are correct. And uh here is where our agentic loop begins uh we feed our findings back into our agent and we look for corrections till we arrive at a state where we are fairly convinced that our findings are real and our findings are relevant. Then we feed all of them into the remediation agent which has the job of basically telling you know what to do to fix these vulnerabilities and we feed that back into your code repositories so that the PR is generated for your deaf teams and they can just review it and check it in. So now I want to show you what this really looks like if you're using the pentest agent. So this is the target URL screen where you can describe uh whatever the end point is that you're trying to test. It's pretty straightforward. We ask for a bunch of information here, but you'd noticed most of that is optional. We've tried to keep it super low, you know, low weight, very easy to invoke, so you can literally just give it the target URL and get the agent to go to work. You do have to give it the credentials because most of the applications require some sort of a login uh to go uh and access uh the endpoint that you're giving. And the design documents that I talked about so often times your applications has some, some design document, even the requirements document that your engineers might have written anything which is, uh, which you think is going to be useful for the agent to draw its conclusion, uh, we allow you to add that as an optional resource. And the last thing here is really the code repositories. Uh, this is to get more application context but also generate full requests for you at the end of the cycle. And this is it. This is all you need to configure it, and now you just press the run. As the pen test agent runs, as I said, it is a long running agent, uh, so it can take hours, sometimes it can take days. In our experience, mostly it's run for hours to find the vulnerabilities, and here you can track it in real time. You can see how long it has been running and, um, once it's complete, it will show you the status right here. On that screen, so. Here you can see the results that the pen testing agent publishes and what is interesting here is that it will categorize the results for you so it will tell you how many are high risk medium risk and that category. ization is super helpful because um typically again in a security review you get a bunch of findings and your engineers are then focusing on what is the most critical one that I absolutely must fix before we deploy this to production. What is the low level risk that I am OK taking which I can fix as a fast follow? So this sort of categorization is super helpful for not just the security team but also for the engineers who are then making the fixes for these. And over here you can see uh what the agent has done in order to do pen testing. It's actually gone through a bunch of other URLs and basically exercised what your application is doing uh in order to really execute the pen testing so you you kind of get a flavor of uh what it has done behind the scenes and you'll get a much more in depth look into that in the next screen here. So here is the the summary that the pentest agent has produced and. Let me just share with you that this is the page where we got the most positive feedback from our own internal security team and from the customers. This, and even if you read the log, uh, I mean it's hard to read on this screen, but it's just raw logs, but it shows you how the agent conducted the test. How did it arrive at the fact that this is a critical finding and that step by step breakdown has been super useful for customers. Uh, they take, uh, hints from here and sometimes they will go and conduct some other tests and that has been a great workflow that we have seen and other times they're just like, OK, it is super clear to me how this agent has done its thinking, and I can now validate it and feel more confident that the results it is giving me are truly the right results. Now I, I think if you just focus on the particular one we are highlighting here which is the privilege escalation uh task. The logs which uh again you'll see on the top they will just tell you I execute the agent will uh tell you the way it proceeded. I executed this step, then I did this next thing and then I did the next thing as this step so I, I think just that level of detail is pretty remarkable to see and uh I was talking about the DST tools earlier. I think if you really look at what has been done here this is just a reasoning which is happening behind the scenes. None of the DAS tools do that today so this for us was the truly remarkable part as the builders of the tool when we could see the agent doing this work. Again, something which our customers and internal teams really, really loved. The steps to reproduce this, so the agent has done this work, but what if our team wants to rerun what the agent has done to build that confidence and and we really needed that early on in the process with our own security team because they were building the confidence that they can start to use this tool in production. So this set of steps again was super useful for our own team to just start to get confidence that the agent is working as expected and this was part of our validation steps so the agent actually has a bunch of other things that is executing to make sure that the findings are the right findings and we are able to reduce the false positives as much as we can and there's just a lot of work that has gone in in this part of the system to make sure the right findings are surfaced. You get a very detailed level of risk reasoning over here. Again, part of the things that people really loved about the two. And my favorite part, uh, was the remediation part. So yes, you have found out what's wrong with the application now what do I do with it? And this is where, uh, the magic is you can see the magic. This is what makes it electricity if, uh, if you were to ask me. You have pull requests generated right here to say how to fix the problems that the agent has identified. And you know this is how you meet the development velocity of your engineering team and with more and more code that is being written by coding agents you've seen uh that part of the SDLC, the actual coding building part has really taken a leap in terms of just, uh, the speed. So teams are generating code as a pretty high velocity now internally for us. Same thing has happening in the industry. So we don't want security to become the bottleneck. So the fact that this agent can actually do the remediation, you can run it on demand, and it'll generate pull requests for you, you are able to keep up with the development velocity of your engineering teams. And here you can see the runs um that the pent testing agent has done so whatever has been done in the last week is visible to you here again uh one of those things which our teams have found very useful as a visibility mechanism. And coming back to what I was saying this to me, the design review, the code review, and the pen testing part combined is the electricity for proactive security. You get very, very application or business aware results from all three tools. You can run these on demand. You can run code reviews right when you, uh, check in the code. You can run pen testing at a certain point in your workflow. You don't have to schedule these ahead of time. You will get to see the work of the agent in detail as the agents do their work, and, uh, the results are very comprehensive based on our own internal testing. And here are some quotes, uh, just on that part, uh, what have teams found when they have used the pen testing agent specifically and, uh, again it took us months to get here it took us a lot of work to make sure the agent was, uh, accurate and giving us findings that were truly correct and we're very happy that we arrived at this stage where we can share this on stage with you, uh, but it took a lot of cycles for the team to do that. Also some quotes from uh SmugMug and Henge which are our external customers. SmugMug was actually super interesting for us because they ran the pentest agent and uh. The agent found uh actually a business logic bug is what they called it in their code production code, and they were super excited about that because it's just one of those things that had gone unnoticed. Alright, to wrap up today we covered all three aspects of security, proactive security, uh, that AWS security agent provides today. Again, I'm super excited to bring this to the world. We, uh, jumped on this endeavor earlier this year. High ambition team and uh a very hard task in front of us so we're very proud of the work the team has done and there's just a lot of uh knowledge that has gone in to uh making this product as robust as it is today. You can actually give it a try. It's fairly easy to get started on this, uh, very minimal configuration steps needed, so I'll highly encourage you all to go and give this a shot and give us any feedback that you have. We would love to hear that. All right. Thank you all.