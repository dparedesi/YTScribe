---
video_id: p0BLnE9CJcA
video_url: https://www.youtube.com/watch?v=p0BLnE9CJcA
is_generated: False
is_translatable: True
---

Um, hey, everyone. Good afternoon. Hope you're having a great reinvent so far. Um, welcome to today's breakout session on spec-driven development, uh, shaping the next generation of AI software. I am Jay Raul. I'm a senior solutions architect with the Quiro team. And I'm joined by Al Harris, uh, principal engineer and one of the founding engineers for Quiro. So we're super excited to talk to you guys about spec driven development today. Exactly, yeah, um, but before we dive right in, uh, let's get a sense in the room, uh, how many of you, um, I have heard about spec driven development or are familiar with it or have used it in some sort of way. It's like maybe 25% to 1/3. Yeah, yeah, that's awesome to see. OK, great. And the next follow up is how many of you have heard about Quiro or have got a chance to use it? I'll say before today. OK, before today. Cool. Maybe half. OK, awesome, awesome, yeah, yeah, whether you've raised your hand, whether you've not, um, don't worry, uh, at the end of the next hour we're, we're hoping that you can take away a lot of, um, good takeaways on what spec driven development is, how it can be used to improve your developer productivity end to end in the software development life cycle, and you get, uh, a, a, a, a mental model of some sorts of how you can work better with Quito's agent, um, to get protected. Will results um in a more structured way for coding. So, um, that's what we aim for and uh we are quick take a look at the agenda for the next hour or so. Um, it's jam packed. We, we, we have a ton of things to talk about, even showcase it to you, um, so we'll talk about what spec driven development is, um, how or why specs make a difference to your software development life cycle, um, how it works, so the set of heart of. Facts it generates um end to end uh we'll talk about that and then with Al being here we'll you'll get firsthand experience of how the Quiro engineering team works with Quiro to build and ship features. So we'll do a few case studies of some features that have been shipped and then finally we'll do a live demo of how spec driven development can be leveraged with MCP uh to ship a feature, uh, from scratch. So that's what we have in store for you. Yeah, let's dive in. Yeah, let's dive in. OK. So, you've all been there, prompt, prompt, prompt, and voila, you have a working application. So, ah, it's fun and, and, and feels like magic, right. Um, but it, it requires much more to kind of get to, uh, production. So basically we, we, there's, there's a few questions that, that are unanswered when, when you're working in, in the white coding, uh, paradigm where what, what are the assumptions does the model make while generating code? Um, what were the requirements completely ironed out? Were they fuzzy? Uh, what kind of design decisions were made? Where do those documents live? uh. They're easily accessible. uh, what kind of implementation was the final decision taken upon and implemented? Uh, how do you review those changes once they're done, uh, once you find a bug in the existing feature that you that you've built? How do you go back and trade over it again and again? So there's a lot of questions out there, and this is what we call the, the prompt and pre loop where you come up with, say, um, I need a feature, say let's say you want to add authentication. To to your existing web app, uh, and then you, uh, get a very enthusiastic response from the AI, uh, agents saying you're absolutely right, um, and then eventually, uh, you realize that the generate the code that's generated is, um, not easy to understand. There's a lot of edge cases that have been missed and also the approach taken is wrong. Now what do you do at that point? So at that point you'd basically go back to the drawing board, say, OK, let's undo this, let's take a new approach, and then start building the feature all over again. So this is the exact um. Feature uh that that you've been building and we we really want you to take a look at how in the upcoming slides spectrum and development can enable you to do this. So, um, a quick introduction of what spectrum and development is. So it's a set of artifacts, uh, so I'd say it consumes of three main things. So it's a set of artifacts. It's, it's a structured workflow and also. You get reproducible results out of it, so we want to our mission and our vision is to bring more structure uh to AI coding so that you can get from prototype to production, um, in, in no time basically. So we'll we'll, we'll get right into it. So the set of artifacts, so there's, there's 3 main things, uh, involved here. So as you see right here on the slide as well, um, the first part here is the requirements. So very often in the product or let's say software development life cycle, the, the ingress point where you'd start building a feature would be that let's say as a persona of a product manager you'd reach out or the product manager comes up with requirements, um, which could be in, in an external data source. Of, uh, let's say you're building, uh, using Jira, uh, Linear, Asana, and so on. So that's where everything starts. So that's the first part where Quiro comes in and helps you iron out the entire requirements before you even write a single piece of code. So that's part one. Now the second thing that's, uh, part of that is also the design. So once you come up with the requirements that that are required to build the feature that you're trying to build. Um, what's the technical implementation? What, what does the tech stack use? So are you building a, a, a green field application from scratch? Are you building a brown field application where you're iterating on your existing legacy code base, uh, or are you trying to refactor, etc. And finally, so the design phase basically consists of all the technical implementations that are required, the decisions that have been made based on the rationale with the agent shares. With you and finally once you've come up to a conclusion that this is the design I want to go ahead with these uh this is, these are the decisions that we've made to come to that conclusion, you then get the the flow of wipe coding I would say with, with the task implementation so we we we didn't want to take that away. We wanted spec driven development to be um like an overlap of the flow of wipe coding but with the clarity and. Structure of specifications so you get that with tasks so tasks are basically discrete, um, uh, ironed outs of very granular fine tuned um prompts that the agent will then start to implement uh based on whatever design decisions or technical implementations that you've, uh, made so that's basically what the set of artifacts is. So, uh, we'll quickly take a look at the demo here for. The first step in spec driven development, so let's say you come up here and, and this is the Q ID if, if someone's not looked at it and are looking at it for the first time, so you'll come into the chart. So there's two modes basically. Uh, there's a wide mode, there's a spec mode. So in this case you'll start off with a prompt in the chart with the spec mode and it says here that let's. Build a CLI which can be used to track meals and meal times. It will support basic crud operations as well as a report operation which gives a pretty weekly report of meals on the command line. So once you enter this prompt, uh, what the agent does is it now determines that you're trying to build a feature and now the first step included in that is building the. Requirements so right now it's in the process of creating the requirements and once it is created we'll walk you through what the requirement consists of. It's mainly requirements where there are different user stories what kind of application that you're building, who's your target audience, um, also each user story is tied to an acceptance criteria which will be actually very helpful towards. The last part of the process, which is tasks because you really want the agent to ensure that the code that it generates is relevant to their requirements, so a relevancy, and b, that you would be able to also validate at the end that the code that agent generates is actually relevant to your actual requirements. So. So that's the first part of the process. So here that you see there's um a user story. As a user I want to add meal entries to track what I eat so that I can maintain a record of my eating habits and then eventually you'll see the acceptance criteria tied to it. We'll, we'll take a look at it in depth when we go through the demo. So moving on, so basically, uh, one thing I'd like to include while we are at the requirements phase. Is that the requirements uh do use an industry standard for defining these requirements uh uh the acronym for that is EEARRS, so Easy Approach to Requirements Syntax um so we'll talk a little more about why that's important later on um it looks like kind of a random decision early on but we cared a lot about bringing structured natural language in your requirements um and again we're we're just touching on that now but I'm excited to talk about. Yeah, yeah, perfect. So, the next part in the spec process, once you find out what your requirements is, is the design phase. So, here, um, before I get into any details, I'll, I'll just show you. What the process looks like in the ID. So once you start after the requirements are done, so we want the agent to work with you, um, as a collaborative tool. We don't really want the agent to go ahead and build stuff um straight away without having the human in the loop. So we always want the agent to work with the developer or uh the end user to get feedback and a trade based on that throughout the spec process. Once you're building with the requirements, uh, the agent will come back to you saying, Hey, we've now built the requirements. Do, do they look good? Do they, uh, need to be refined further based on the input that you give? And then once you're good to proceed, you'll move to the design phase. So here, once you select that, the agent will now start to generate the second file, uh, in the spec process. So both of these files, both the requirements and the design files are in markdown format. So here that you see now it's come up with the architecture that is required to build this command line tool and once it does that it also outlines all sorts of commands that you need to run, uh, what's the underlying architecture that is required so that the agent is aware of all these decisions that it needs to make while implementing it in code so all of this is done before even a single line of code is written. Mind if I dive in really quick? Yeah, go for it. So one thing that's really important here and not really demoed in this video that we're showing is the fact that at any point in time the agent can both ask you clarifying questions because a lot of what we're dealing with here is the resolution of ambiguity. We wanna make sure we identify ambiguous requirements. Honestly, this, the requirement that's initially given is fairly ambiguous. I want a CLI app that has CRD. It's like, you know, that could mean a bunch of different things. Um, the agent just sort of made some decisions and went along. So it might ask you questions, but you can also at any point just chat with the agent and say, oh, actually I wanna change requirement to to be like this. You can do that via text. You can, you know, just type in an update to the requirement and tell the agent I updated requirement 2, or you can say via chat, I want to make these updates, etc. etc. Um, so throughout. This process we we do want this to be flexible. We try to stay slightly opinionated with our starting templates, but if for example you have concerns in your design document that we do not capture today, I think we have, we, we sort of can in the template things like what are the, what's the architecture, put a system diagram in. What are security considerations, performance considerations, there's a few of those, but if there's something that matters a lot to your business, this is just natural language, right? You can come in and say, oh, I actually wanna add this to the document. Let's flesh out these decisions. So our goal really is that this is an inter an interactive and sort of um. You're, you're working with the agent throughout this process, correct? And, and to add to that one additional thing, both with the requirements and now the design phase that we saw, both of these are marked on files. Both of these are supposed to be, um, shared between teams. So these are, um, artifacts that you'd come into your Git repos uh Git repositories so that at any point of time, let's say you're reviewing a PR and then come across that, OK, why was this decision made? You could directly correlate it to the spec. That's already part of your repository. So at that point you have all of the source of truth in a single place, um, and that way can go back to the decisions that were made and evaluated as required. So the agent, oh yeah, exactly, yes, um, so that's kind of part of what the design phase does. So now once you do that, the same feedback loop continues where the agent comes back to you and says, hey, I've built this design. What do you think of it? Does that, does it require any further refinements? Do we need to take a different approach? The best part or one of my favorite features um in the design phase is when it comes up with, so there's a section in there which we'll see uh during the demo that it says, um, here are some technical. Decisions I've made, but the best part is it comes with rationale. It comes with points to back that up, so there is data for you to say, OK, this is why this approach is better than this. So that's really important when you're building features from scratch using the spec process. So once you do that, um, you then move on to the final phase, uh, where Quiro creates these discrete implementation-based tasks for you. So I'll quickly show you how that looks. So I'll say, OK, once the design is created, move to the implementation phase. And then uh it starts to create the 3rd file and the final file uh for the spec process which is the tasks. MD so. Once the task file is created here you'll see that each of these tasks, so in this case there's 5 primary root tasks that are created, um, each having detailed, um, instructions for the agent to follow a specific, um, reason to build that code. So here in this case it says let's say focus on the last task where integrate components and finalize the CLI functionality, for example, um, so. It says wire together all these different components, the CLI, the services, the storage layers together with the requirements included in there. So you'll see the task above it says requirements 1.1, 1.2, 1.4, which basically means that it's referencing whatever is there in your requirements file. To the task that is actually created, so all you have to do is you can come in here you can run either from the file so you see the text hovering over uh the root task saying start task to start the implementation of the task that's one way to do it or you could just interact with the agent via the chat experience um and just say OK run this particular task or go ahead and run all tasks for me so um that is really helpful for you to get started um and once you do that actually I think we don't. Capture it here, uh, but I'll talk again when we do the demo for this is once you implement and uh implement a specific task, it does show you a couple of different options as well, so which shows, uh, view the execution. So basically you could see the trace of entire changes that the Quiro agent makes for that particular task. So at any point of time if you need to go back and revisit the spec, uh, even locally, uh, you could just go back and say, OK, show me the changes that were made for this specific. Task or revert a task or reverter task using um checkpointing so um that is super helpful um and let's see um at the end of task creation so again the feedback loop continues even with tasks uh the final thing that happens there is and this is a feature that that we've shipped I believe a couple of months ago uh which we call the spec MVP uh mode uh so if you're in a prototype phase or you're running a pilot and all. You care about is I want to get MVP up and running for my stakeholders or for my business. How can I get to that faster? So during spec creation in the design phase, it does take into consideration all the testing strategies that are also required to build your feature in your project. So if you want to, let's say, move fast and if you want to just build a demo, build a prototype, and then care about implementing the testing strategies later on, you. the option of going the spec MVP mode and all that it'll do is it'll create the necessary tasks that are required even for the testing strategy. It will mark them as not required, so those tasks will be marked as optional. As a developer, you still have the option of going ahead and going back and implementing those tasks once the MVP is up and running. So you still have all the control that you require as part of that spec process. So, OK, um, so the second thing in the spec process, so we've looked at the set of artifacts it generates the requirements file, the design file, and finally the task file. Now why, why is it relevant now, um, I at the beginning of the session mentioned that we want to bring structure to AI coding. So one of the main core reasons that we want to. Do is we want to enable developers, teams, organizations to plan first and not get into that play and uh the prompted play uh play um loop. So basically this is exactly related to that um so plan first, then ship and build the right thing the very first time rather than having iterations on iterations uh for the future that you're building. So, um, I've already talked through this, but this is what the structured workflow looks like. So you start to create a spec for the feature that you're building. You then say, OK, define requirements for my feature, um, and then the feedback loop continues where the agent works with you to implement the changes, if any required. And then it does the same process for the design phase, the task phase, and eventually once you're happy with everything, you then start writing even the first line of code. So at that point in time you've not actually interacted with the code altogether. All you've been doing is, um, working with the agent, helping the agent make the right decision, uh, based on your requirements of the project and the technical implementation that you've gone ahead with. So the next phase or next key aspect of spec driven development is reproducible results. Do you wanna take over? Definitely, yeah. So this is the thing I'm very excited to talk about and this is some of the work we're really looking forward to in 2026 as well. So the promise of spec driven development is that in the, the cost of vibe code is quite low, uh, from a time investment perspective, right? It takes me seconds to create a prompt and just send it to an agent and get that fired off. Uh, with the increased investment up front in the time you're spending, getting your spec right, thinking about requirements, iterating on requirements, reviewing your acceptance criteria, you know, looking at a design, we'll talk a little bit more, um. Later on in the session about how the Quiro team for example uses specs as almost a replacement for the design review process we used to go through, but we really wanna make sure that the more time you're investing up front, the better the results you're getting at the other end are and so our key really is on correctness and reproducibility and the results that you're going to get, um. So what does this mean? It means a lot of things actually. It means that we can help you remove ambiguity from requirements by looking for requirements, for example, that are in conflict with each other or requirements that are overly ambiguous and cannot be resolved by the agent. We really don't want any coin tosses at run time. We wanna make sure that what you, what you think is going to happen is what is actually going to happen from the agent, um. It also makes sure it means to us that critical decisions that will impact the system like the functional system you ship at the end of the day, key interfaces, you know, external, um, APIs, uh, performance considerations, uh, correctness concerns are really documented up front and we're not leaving these things to chance down the road where, you know, whether or not my database right is strongly or weakly consistent shouldn't be a decision that an LLM makes for me in 3 hours' time. Um, so those are really important. And then finally breaking, uh, work into bite size chunks. This is just mostly a function of sort of the quality of LLMs today, but so we wanna make sure that when the agent is working on implementation, it's able to work on an atomic piece of, uh, an atomic unit of work that can be independently verified, independently, you know, reviewed by a teammate, all these good things, right? These are just best practices for development though at the end of the day. So from this perspective, uh, I think in this video I just say do the tasks, um, but effectively we've now produced this set of tasks, uh, in the, the task list here. The agent is gonna start kind of churning through them one at a time, um, depending on my steering files. I think it might create commits along the way and sort of checkpoint it's work with, um, get commits, which is something I like but not something you necessarily have to do, um, yeah, so this is where we were as of 3 weeks ago. Um, 2 weeks ago, Kira1GA generally available, which for you, for the purposes of this room means now property-based testing exists. So we're leaning really hard into this reproducible results, uh, paradigm. Um, so there's, there are a ton of standards that exist today. Things like, um, GraphQL, Swagger, there are full blown IDLs like Smithy, uh, again, if you're somewhere like reinvent, you've probably heard of those. Um, there are also very like, uh, platform specific or application specific standards like, uh, cloud formation, CDK. Etc. We don't want to, we, we don't wanna propose yet another standard. We wanna be able to use these bind them together and use existing industry best practices to bring you the, the, um, reproducible, uh, reproducible results that are so important to you as a software developer. And so this is where we're introducing properties now. Property based testing or not is not new. It's in fact fairly old. Um, this builds on a lot of the work from folks like John Hughes and, and Haskell and QuickCheck, and there are libraries in kind of your favorite language to do property testing, but, um, most teams don't do property testing. It can be kind of painful to set up, but the benefits for teams who use these, these techniques is, uh, profound. So here I've taken a random, this is pulled from uh the Kira blog, uh, a random requirement. So this was for a traffic control system, um, and one of the requirements is that while the, uh, one of the, I guess acceptance criteria of the requirements is that while the traffic control system is operational, the traffic, uh, I'm sorry, the control module shall maintain that at most one direction is green. It's a fairly simple statement. It's saying that at any point in time I've got an end-way traffic light. I do not want more than one green light at a time. This is perhaps overly simplistic because maybe I want, you know, two left turners to be green at the same time, but for now we're saying I don't wanna think about that. I want one direction to be green because then I know I have no crashes. So what Quiro will do for you as of our V0.6.0 release, which was our GA version. Is it will produce properties as part of the design. So Kira will first spit out the design document that we showed a sample of earlier, but it will also then reflect on the design, reflect on the requirements, and extract properties of the system you want. Now in this case, a property is one of several types of invariants. The property extracted in this example is a safety invariant, which is to say that, uh, and it basically takes the structured natural language we have from EERs. We're able to parse that out with, um, a combination of LLMs but also standard, uh. Neurosymbolic processing which says the safety and variant says that at most one green signal for any sequence of operations, which is state transitions across direction, emergency modes, etc. uh, any of these things can happen and I'm still guaranteed that at no point in time did I have more than one green. Uh, signal and so this we also similar to what uh Jay was mentioning earlier, uh, tasks are tied back to requirements. This property is tied back to a requirement. So if this property can be verified in the, uh, implementation, then we have high confidence that requirement 2.3 is met in your system. This is really critical to ensuring that you have reproducibility because I don't at the end of the day care about the implementation if I know my requirement is met, uh, via some test mechanism. Now, before you freak out, I'm gonna flip to the next slide. There's a bunch of code on there. Don't worry about reading it. Um, this is effectively just a sample property test. It's fairly lengthy, um, but this is effectively the test for what we just talked about. If you look at the input up at the very top, we have, uh, input on the test which takes in this list of timing config. Don't worry about that. We'll talk about that in a minute. And then the operations, and this is a set of like sequences of, you know, switch to east, switch to north, go into emergency mode, come out of emergency mode, whatever. Um, it then stimulates that control module we talked about, uh, sending each of these operations in. It takes a look at the green status and then it asserts that at no point in time over the sequence of operations were there more than one green. It's fairly simple. It's how you'd write a unit test for this with the exception that we have, uh, a flexible input, a set of input parameters. So let's talk about how you would test this sort of classically, right? Let's say I'm a developer. I wanna test my control module. I wanna test that if I'm, you know, north, south, east, west or northeast, southwest, let's say, um. That at all, at all points in time I have, I do not have more than one green. Well, that's a straightforward test to write. I create a new control module. I create my list of operations, transition east, south, west, north, uh, I pass it in and I do an assertion on the outputs in all those states. Great, you know, I did it. My, my PM is happy. I'm happy. We, we believe we're safe as long as that sequence of transitions happens. Oh. But I should probably make sure that if there's duplicates, uh, duplicate state transitions because I don't know, some external system is stimulate, you know, stimulating the control module that it still does the right thing. OK, well, I'll add that's easy. I'll add another test. I'll copy paste it. I'll add another, what do we do? south-south in this case and still validate that I don't get more than one green. When I do south-south, you know, north doesn't turn green or whatever. Great. Oh well, what if the system goes into emergency, right, we've all done this and you get long, long laundry lists of test cases to cover every corner case that you've thought of so far, but not the ones you didn't think of. Um, so enter property tests. And so with property testing, I as a developer I no longer the human in the loop. I use a property testing framework. Uh, I think the sample code I had above uses hypothesis, which is a Python library. In node you would use I think fast check, um, Haskell's got quick, you know, choose your favorite library, but effectively the way these libraries work and the way property tests in general work is that we compute the full state of possible input usually via fuzzing, um, so you'll send, you know, dozens, hundreds, thousands, tens of thousands of sample inputs that can be generatively produced, um, locally, so these tests can be sometimes slow. Slower I'll say, but, uh, they give you confidence that if all these random permutations of inputs are met, you've you've produced no counter examples to say that your system is not working, um, so in this case we end up with, I will actually just go back briefly, um, maybe. In this case, I don't care about the fact that you know I wrote one test effectively or in this case Kira wrote one test and my system is going to make sure that I don't need to think about all the possible inputs. This case will always be met, uh, and I will be notified if that ever fails, so. Why is this important? Well, I can run comprehensive tests without having to think too hard. Uh, I have traceability that goes from this particular property test all the way back to a concrete requirement I had originally in the system. And 3, if there is a failure, most of these testing libraries will do something called shrinking where maybe it found some crazy, you know, 3000 step sequence of events that produced a failing state. Um, it will actually continue to explore the space and find the minimum reproducible result there. So maybe I do have a, a bug somewhere in my control module and it happens not on South-South but only on west-west. Ideally you could get a very simple test that says, hey, here's a counterexample that proves that your code doesn't work in this scenario. Go fix the bug. Um, so this is super powerful and this is something we've leaned into heavily as a team. In fact, PBTs have already found, I think, 3 key bugs in the Quiro codebase since we started using them in earnest about 2 to 3 weeks ago. Um, so highly recommended, give them a shot and uh let us know what you think. So this is step one though. We, we have a lot more work in the pipe, um, coming down over the next year basically for how we improve reproducibility of the system, helping you resolve ambiguity, those, those tent poles I mentioned earlier. So this is something we're super excited about, um, and I could talk at, at, uh, length about it. Um, So let's talk a little bit about why specs, right? Why do we wanna use specs? Why do we think specs are valuable? This is a bit of a rehash of what we just talked about earlier, but the software dev life cycle vibe coding we think sort of covers the implementation phase. It's spreading out a little bit, uh, you can use it a bit more, or it can do a few more things now that, you know, you have MCP, you have some additional tools at your disposal, but effectively vibe coding is really this inner loop thing. And we want to expand that in loop to say I wanna be able to move very quickly for planning and design. I wanna be able to move quickly for implementation, Q&A, etc. And so this is where with the implement with the introduction of PBTs or property-based tests, we believe that we have taken, uh, a meaningful progress towards tackling that testing in Q&A, uh, part of the SDLC, um, so. There's a couple of things that we can do today. We do spec generation which we walked through. I'll kind of brief through that, but you know, you provide as much context up front as you can. This is really going to help the system work, um, you know, it, it takes in your feedback. It distills requirements. It provides the high, you provide high quality feedback, and then the system is going to work much better. Um, and here I'll kind of dive into some of the tips from very successful spec users. Um, Jay's got a few, I know. Yeah, yeah, that's a, that's a good one, I think, I think for as, as people who now use these different agent, um, tools for building code and software, um, I think there's two things that these, um, users really have in control of. So the first thing is, um, the prompt. The second one is context, so. Um, as much upfront context as you can provide the agent, the better the decisions it comes up with, the better, um, the, the, the reduction in, um, code hallucination, um, and also, um, it does a great job at, uh, adhering to the standards or patterns or paradigms that you already have built for your existing code base. So, um, just looking at the first part of the highly successful spec users external context now this could be. Using Quiro's own steering feature which allows you to, um, so the first time I'll I'll I'll briefly walk through it during the demo, but the first time you come into a project, it's basically persistent knowledge for the agent to take decisions based on the code base that you're working with. So whenever you bring in or import a project in Quiro, you can create 3 foundational files as part of the steering setup. Um, it, it mainly encompasses the tech. Or the tech stack of your project, the structure which helps the agent identify where each functionality of your project, uh, exists or how can it better do or do a better job at finding code that's relevant to the feature that you're building or existing code base. So, um, that those, those are some aspects which are covered by steering, um, and then it also consists of a product file which just basically means, uh, what kind of data flow does your application. Adhere to, uh, what's your target end user, um, what are how are how are the different components talking to each other and so on, um, an additional part of that is also MCP so you can bring in additional context from external data sources and knowledge bases, um, right into the IDE, um, and also there's inbuilt, um, context providers so you could use, um, the hashtag files to specifically ask the agent to, uh, review a file for, um, for. Making a change or executing a uh a thing that you're trying to do, uh, followed by docs there's there's a good list of docs that are also embedded um into Quiro that you could leverage uh while making let's say, um, an implementation decision. So, um, you could ask Quiro to say hey reference these docs and then come up with uh a technical implementation for me to review. So that's one and then, um, evolving specs so you could do this. Uh, where you could directly work through it during the chat experience or, um, the best part is you could use natural language, uh, to at any phase of the spec, so be it a requirements design task at any point in any of these markdown files you could write natural language and then there we have an option for you to refine the task or, uh, refine the, uh, the spec and it'll automatically adhere to the standards that we've mentioned it to so uh. Let's say in your syntax and then once you update the requirements file it will go ahead and not only update the requirements file but also determine whether it needs to update any of the design decisions that we've made, any of the tasks that need to be changed so that's a very powerful feature for you to have and um evolving with specs. So, um, I, I would actually add something to that which is I think when you're when I think of evolution with like evolving a spec over time it is, uh, we have an example I'll come to a little later in the talk but. Um, a spec is not a closed book once you've, once you've executed the task, right? It lives in your code base. You can, you can iterate on it. You can change your requirement, um, and on the Cura team, at least we found that to be super powerful because we can say. Reopen a decision we made two months ago and say we actually wanna change our mind. We, we don't like that requirement anymore. We don't think it's serving users. We're going to change the requirement. We're gonna re-synthesize the design based on this changing requirement and we'll add new tasks. And now I have a get commit that actually documents that change. It's effectively an ADR, um, for those of you who have used those, um, but yeah, that's super powerful. I'll let you, yeah, yeah, for sure. Yeah, um, yeah, it basically takes away the pain of, yeah, uh, creating a new spec altogether, I guess that actually it dives right into committing specs, right, right, um, yeah, which is like putting your specs in the code base and committing them with, you know, get whatever your version control system of choices, uh, we, we put all of our specs in the code base. We actually have started archiving some of the, the older ones, um, just to sort of say. Space and reduce on context size, but, uh, anything that is sort of an in development in progress feature we will leave in the code base in the doc hero slash specs directory and um we commit them both on on initial review but then as tasks are executed we basically just are able to say yep this is task whatever 1.2 is checked and here's the code and test that go along with that. Um, and then I think, yeah, you were talking about chatting with specs as well, but yes, exactly, yep, you could, um, use the chat experience by default, um, to chat with any phase of the spec. Um, we have a dedicated spec context provider as well, so if your, uh, project consists of multiple specs, you could pinpoint and use the exact spec that you'd like, um, to iterate on, uh, so that's a, a functional and a useful feature to have while building with specs, yeah. And I think that comes back down to refinement basically, right? You're not a passive user as a, as a user of Kira, you're not a passive passenger on the spec experience, right? You're you're partnering with the agent to deliver your spec, to deliver your software solution, to do whatever you're trying to achieve. At any point in time you can ask Kira to change what it's doing. Um, in natural language, of course, um, but the expectation on, on my end at least is that we've given some starting points, we've given a rough, uh, work, workflow we want you to run through, but you can, you can stop and say actually before I finish up the design, I wanna go and do research on all these things and I wanna produce. Research docs and oftentimes depending on the task you're trying to achieve, putting that work in up front can have a pretty profound impact on the quality of the resulting um output. So you know at any point in time you can go through and refine this you can change your requirements, change your design, um, yeah, and then finally task execution, just click go, um, but you know you can, you can say run all tasks. I want these to all be run. I prefer just to say run all tasks assuming I have the context length for it. Um, I find that the quality is actually better when I have some carryover from task to task. Uh, but these are, these are tricks we ideally don't want you to have to need to think about. Um, we want this to be as basically fire and forget as possible. Uh, yeah. Yeah awesome yeah yeah yeah yeah yeah uh let's let's dive now into some exciting insights of how uh the Quiro team ends up using the specs to build, um, features on Quiro. So yeah, yeah, well, uh, there's this I've chosen kind of three arbitrary things. These are just 3 features we've shipped in the last couple of months that we use spec almost exclusively for. The first one is fun because we were approaching our public preview launch date. Um, you know, everyone's heads down, everyone who's been sort of laser focused on a launch probably knows those last few days and weeks you're, you're really just trying to polish off the rough edges, right? You, you don't have time for new features. You don't have time for the, the like to like to haves. It's really just the must-haves. So we had somebody sit down on the team, uh, developer on the team who said, hey. I've gotten a lot of feedback from people. They want agent notifications. They want some sort of a pop up on their desktop if they, if this, if Quiro, I should say, is waiting for them. Let's say it wants approval to run a shell command or something like that, um. And uh Quiro is a fork of code OSS, which is a 15 year old code base. It has, uh, it's a very well organized code base, but you need to understand the organization. So, uh, at this time nobody really understood how, uh, notifications sort of work, but I haven't spent a lot of time looking at it because we're building this agent thing over here, um, and he said, OK, Kiiro, just go figure it out. I wanna put native notifications. I wanna use the underlying electron notifications API. I don't know the right way. I don't know the code OSS way to plumb this through, but go figure it out for me. And um he produced two specs, one in our extension space and one in sort of the platform space to do this. Uh, we reviewed it, said, looks good to me, or what, what do, what does Kira always say? Sounds great. Yeah, you're absolutely right. Let's do it. Um, let's do it and just see how it works and we were able to ship this in I think 48 hours from sort of deciding we should ship this thing to it being, uh, to it being shipped, um, and so this was an area where we had not a lot of experience. We didn't have a ton of time to become deeply knowledgeable about how all the message passing in the system worked, but we were able to ship this quickly and easily for customers and actually. Um, we recently added some new native notification config, and this is another example where we were able to just sort of reopen that spec and say we're changing the requirement. We used to just have notifications for I think action required, agent execution succeeded, and agent failed, but. We actually want to change the user space config and we want to add configurations if you're like let's say running you're coming up to your credit usage uh cap we wanna notify you sort of in advance of that so if you wanna change behavior or whatever you know focus on critical work you can do that um that's another one where we just kind of change the spec as we went. Another one is uh remote MCP support. So MCP support is basically essential in any um. Agentic tool these days we love MCP. We build new MCPs all the time on the team for little tools we need, um, but remote MCP was something we needed to ship very quickly. We wanted to ship it well and we wanted to make sure that we were aligned on the behavior. So in this case we actually sat down. Um, we did a full design review where, you know, the engineer working on this feature said, hey, I'm just gonna point Kira with the, the, uh, MCP2 or sorry, the MCP 2.0 spec I think it was to understand how, how remote MCP works, how does the OA protocol with, uh, DCR work, all these, all these details that we sort of needed to understand. We printed the dock up, reviewed it as a team, had a conversation, chatted about it. We had effectively Kiro in the room because somebody's sitting there on his laptop, uh, typing. And um we were able to feedback, uh, provide feedback to the agent very quickly on the design. So we effectively had a real-time review with Quiro uh on the design and then we went through to synthesize and ship it out, um, and the last is dev server support. Uh, I, a lot of the things I do because I'm we're doing a lot of things quickly is I look at tools that I like and I say this is great, let's figure out how to, you know, maintain sort of the ergonomics of this thing. We looked at an MCP server that provided long running dev tool support and said, I, I love this. Let's start with this because we can ship that in a coup in a week or something very quick. Uh, Dev took a look at it, provided the fetch MCP, said go look at how this thing works. I, I don't know, we didn't copy the implementation, but we did take the API because it was a very ergonomic API for the agent and go implement it. And again, in about a week of sort of testing, tinkering, we got it integrated with our own sort of native terminal system, um. And so that's one where we really just sat down and did the requirements review as a team and the design and implementation just kinda race ahead and go implement it. By the way, this was one of the really nice features we finally got for long running dev. Yeah, exactly. I think, I think the main, um, feedback that we've received from developers and the community is, um, that long running processes was a pain point for a lot of them, um, where, um, let's say. If you're running a dev server, um, the first thing was that, the output, when the agent hands off the, the, the command to the terminal, the output wasn't streamed back into the chat, um, so the dev wasn't aware of what the response was, whether it succeeded, whether it failed, were there any errors during, uh, runtime, etc. So now with this feature, I think it's, it's really good that once I can. Ask Kiro to, OK, run a dev server and then just forget about it. Uh, it runs in the background at any point of time, if it, um, runs into errors, it lets me know so that I am not distracted or, uh, interrupted during the, the development, um, that happens. So yeah, really good feature. Yeah, all of this is to say that the, the Quiro team is evangelizing sort of this spec native way of developing where, you know, review your specs, commit your specs, talk about the specs as a team, um, yeah, and you'll have a great time. Yeah, exactly, yeah, um, yeah, so I see we have, um, yep, uh, we have, so Jay's got a live demo. This is super cool, um, I don't know, I don't know how he found the time to build this, but, uh, he's gonna share some really cool stuff he's been doing with Spector and Dev. Cool. Um, so yeah, this is, um, a bike sharing application, um, which I built using Qiro. So what we want to do here is we want to showcase how you can go from, um, an idea to a fully functional feature, um, using specs. So just to give you a lay lay of the land, this is an XJS application, build with tailwind. Um, and right now it's completely front end. Um, I do not have any back end components, uh, to it right now. So one of the things that I want to add to this bike sharing app, so here, uh, right now, there's multiple cities that you can select with, uh, when working with this application. So I've intentionally tailored it for Vegas. So the current location here is the MGM Grand where we are, uh, for the session. Um, and let's say you wanted to navigate to a different session and use a particular bike type to get there. So you have a few options to get there. So, um, there's the standard bike type, electric, mountain, road, and hybrid, and then you could also select a filter for the price range that you'd like to use for the rental. So, um, once you're ready with that, let's say, um, you can select the option of, let's say find nearest. I, I don't want to take any decisions. I just want to get from point A to point B. Um, without worrying about what bike type it is, so you could come in and say, OK, this is, uh, select find nearest and say, OK, this is the closest bike to me, and I'd like to rent this. So you'll come here, you'll select rent, let's say I'm gonna use it just for 30 minutes. So once you do that, uh, you'll select confirm rental and the. rental is activated. So, once you have activated the rental, um, let's say you get to your destination, you come in here, return bike to one of the locations that are included here, um, and select the location, let's say I'm gonna do Bellagio, that and say return bike. So that's how the rental Ends uh when you uh select the return location. So just to give you an idea of what the functionality of the feet of the app looks like right now, um, so it uses Apple's map kit framework to render the maps along with the markers for, uh, different bike locations in there. So if I zoom out real quick, you'll see that I believe there were 50 bikes in total in the city. So, um, now what I want to do is, I want to showcase or add a feature to this application to say, right now this application is unauthenticated. So, I want the users, um, as guest users to get a view of this map to see, OK, what kind of availability for bikes look like. And then once you're authenticated, I get the ability to rent the bike. Uh, so right now, if you see on the top right here, I don't have any sort of authentication involved. So what I'm gonna do is I'm gonna go back into the IDE now and showcase. So this is the IDE experience. Uh, let me zoom in a little bit in case it's Smaller? OK, cool. um, so I'm gonna go back into the spec mode. So what I'm gonna do is I'm going to, I have, uh, so for, for, uh, demo purposes I have simulated an example where I'm using, uh, Atlassian's, um, Jira product where this is my, uh, uh, task tracker of choice. So here there, here you'll see there's a lot of tasks which are in progress, uh, or to do's and then a lot of them which are done so. Once, um, I come in here as, as a developer, so as a PM persona, um, the p.m. comes in into the Atlassian uh board and it says, OK, add authentication with, with Amplify. Uh, so once this is done, so this task basically involves some sort of requirements, the email, password, sign up and sign in. Um, the, uh, the application feature should show username in header when logged in. Only logged in users can rent bikes. That was one of the main requirements. And here's the acceptance criteria user can create an account with email. User can sign in, sign out. The rental button is disabled for guests, and then user stays logged in during multiple sessions. So. This is what the requirements look like and right now it's not all the way in depth. These are requirements which are a bit fuzzy, which can be um iterated over time. So there is some ambiguity in the requirements and this is intentionally kept. So what I'll do is I'm gonna use the Atlassian MCP server which I've already configured for the app. So, I'll come in here, I've uh while um the session was going on, I just put in a prompt, pulled the requirements from this Jira ticket, um, which is for authentication, create a spec for implementing authentication, and then use the doc server to understand uh what, how are you'll build the amplified gen to authentication feature. So, once I do that, uh, it'll say that, OK, I'm appending all the steering documents that are part of your project, which gives it even more refined details about uh what tech stack I'm working with, what's the um The directory structure for my application. What kind of um libraries am I using? How would I test or validate builds? So all of this information, the agent gets from steering file. So right now it's making tool calls via the MCP server to fetch the exact requirements that are required for this task. So here, as you see, uh, it's now looking into the documentation, uh, but first it was able to fetch the, the issue at hand. So you're, as you see. Um, it was able to fetch the details for that. And the next thing it does is go through the documentation for AWS Amplifier. Once it does that, now it's ready to build the specs. So it says, let me create the requirements document with all the research that I've done. Um, so right now it's in the phase where it's creating the file. OK, there you go. It's already created. Let me expand this a little bit. So here, um, it gives you, uh, an overview of what your project is, what you're trying to build, uh, what are the different terms, uh, for you to understand as part of this, um, feature implementation. So I'll dive right into the user stories. As a new user, I want to create an account with my email address so that I can access the bike rental features, and then it now expands upon the acceptance criteria which were not very thoroughly defined. In the original story that was defined by a PM let's say, um, in the Atlassian server, uh, in the Atlassian board I should say, so, um, that kind of helps the agent to now make even more granular decisions for specific ambiguities during feature implementation. So now let's look at the next story. As a registered user, I want to sign in with my email so that I can access my account and rent bikes. Um, as an authenticated user, I want to sign out of my account as well so that I can secure my session. Um, I'll skip the 4th 1 and then move as a product owner. I want only authenticated users to rent bikes, um, so that we can track rentals and ensure accountability. And finally, as a returning user, I want my session to persist when closing the browser. And lastly, as a developer, I want authentication state accessible throughout the application so that components can conditionally render based on user status. So looking at this file and the requirements that were defined in the original. Um, uh, Jira task, there's kind of a night and day difference between the level of details that are included as part of the spec, and all of this now gives the control back to the human, uh, to review and then make decisions as to what the feature would look like. Like, do you want to add anything other than this, um, for feature building? So here it says let me know if you like any changes or if we should proceed to the design phase, I'll say proceed to the design phase. And once you do that, um, it says the requirements are approved and now I'll proceed to create the design file, uh, which should initiate shortly. So once that is created, uh, I will walk you through the setup of how the design looks like. So there's technical implementation architecture, there's movement diagrams as part of that, so you could get a visual representation of the architecture that is being proposed, followed by the design decisions, and so on. Um, you wanna talk a little bit about the formalizing requirements for PBT, that goes in through, yeah, so this is effectively, uh, part of the PBT new features we added. It's not just actually formalizing, um, this is not just generation of PBT. This is actually analyzing the requirements, and this is part of the reason that ear syntax is so important. Uh, we have parsers on the back end that take that take this structured natural language set of requirement. I think there's like 7, there's 7, Ears requirement rule shapes, uh, we parse those out and then we're able to build effectively a, um, a full AST over your requirements and so then we're able to look for requirements that, uh, overlap or don't. It looks like good news you had good requirements because you didn't get asked any follow-up questions, but if you had requirements that for example, uh, interacted with each other in a negative way, they were incompatible, overly ambiguous, the system would have asked you at this point in time if, um, this is what you meant. This is fairly new and hot off the presses, so we're still iterating quite aggressively on this part of the. DX and it's something we we do wanna make faster as well um if we have time at the end, I also wanna see if you can just have one thing I love to do, especially if I'm using something like Jira or Asana is once you've um bottomed out on the requirements here have Kiro actually write back the updated requirements back into a SANA. I see that's effectively like synchronizing your data, right, right, right. I'll let you carry on. yep, yep. So now that the design file is created, uh, you actually get an option to render it right here. So I'm gonna select that so that you could read this better. Um, so I'm actually going to disable chat for a moment. So, basically what it does is it gives you A description of what the feature does, uh, what, what kind of libraries it's using in this case with AmplifyG 2, it uses, uh, a UI react library. Um, since we are working with NGS, it fits right into the project. Um, here are the different components for the front end, the. Uh, the amplify layer, which is the back end and the browser local storage, um, here's the authentication flow. Here's the entire data flow that happens based on the, the user, uh, or the client all the way back to an AWS service from Amplify and Cognito. OK, even better. Um, so based on this. You could now visualize what the implementation of the architecture would look like. Once you do that, you can then scroll down and review the components involved, the interfaces for that, what kind of hooks or react hooks that will be required. Uh, to achieve this implementation and then finally, uh, different types of data models, auth user auth state, uh, the correctness property here, uh, so the first one that we see here is the authentication, the sign out, um, password validation feedback. So, uh, let's talk about the authentication for any successful authentication operation. The application shall reflect the authenticated user status with a valid user object containing user ID and email. So, uh, these are a few properties that are defined, um, and in the interest of time I'm just gonna quickly move on to the next phase, um, and while that builds, I'm gonna go back. We might need to do the cooking show, uh, swap out. Yeah, yeah, yeah, yeah. I think what we can do is while this builds, I'm gonna go to the end state which has implemented all the tasks that are associated with this. So this is just on a different git branch. Um, so this is. The design file with the error handling, the testing strategy that is defined here, followed by the task list. So here it involved, uh, let's see, tasks 7 and 8. OK, so 8 tasks, and here you'll see that there's some tasks that are marked as optional which gray out. So these are tied to the PBTs and I had. Enabled the spec MVP mode to achieve like a pilot of the feature uh in the first case. So now that all of these tasks are implemented, so what you can do is you can select start task to implement execution of each of these tasks view changes, uh, we'll show you all the changes that are associated with that specific discrete task, um, so you'll see all the changes that have gone through with it. And finally, uh, you could also view the execution so that you could go back into the chat experience, um, and understand, uh, what the entire trace looks like. So, now let me go back to the browser real quick with the new implementation that I have. Um, so with this, now that I go back, I see right away that if I select a bike right now. I don't get an option to view or rent it. So, um, here it says sign-in required to rent bikes. So let's say I come in here, I'll quickly sign in, um, and once I do that, It says welcome to the bike share app and voila. You can directly go in, select and rent. Um, so it now has implemented the authentication part, um, end to end um and now allows you as an authenticated registered user to select and rent bikes. So this is how in a nutshell, this is very concise demo of what um. Uh, spec driven development looks like end to end from scratch for a feature, um, and you can build on top of it, uh, and customize it a lot, um, so, uh, in the interest of time I'll just, I'll just say for those who haven't built, uh, an off solution, he just glossed over weeks or months of pain in about 10 minutes, which is absolutely wild and he flipped. Yes, yeah, yeah, let's, let's scroll back, um. So yeah, that is what we had in respect to the demo. Um, if you've not got a chance to play with Quiro, uh we would highly recommend. Go to our website quito.dev. Uh, it's available across all platforms Mac, Linux, Discord community, Windows, sits on, yes, yes, come join our Discord community. Um, it's, uh, discord.g/keto.dev. Uh, we have 13,000+ members in there. Um, we, we also facilitate office hours every other. Week so you get a chance to talk to the Quido service team directly me, I, we have partners across all different teams within Amazon as well joining the office hours to share their insights. So, um, do that. Uh, here's just a bit more information about uh Quiro if you'd like to further discover uncover um how you can. Play around and learn more about Quiro. There's a bunch of things that are happening at Reinvent. and, OK, quick thing, who has not yet visited the house of Quiro? Other, oh, check it out. Go check it out. That's my number one recommendation. Um, it's just opposite the AWS, uh, just outside the expo in Venetian. You'd be amazed at how good that is. It's super fun. It is super fun. So that's my number one recommendation. I know we're just over time. Thank you very much, uh, for listening to us. Um, yeah, and we had so much fun. Yeah, yeah, we'll be around for questions afterwards as well. Yeah, yeah, everybody, yeah, thank you.