---
video_id: UxjPAufBuVQ
video_url: https://www.youtube.com/watch?v=UxjPAufBuVQ
is_generated: False
is_translatable: True
---

How to build a multi-agent role-playing game master with trans agent. Um, quick question right before, uh, starting. Uh, do you know, like, uh, raise your hand if you know what is a, a role playing, uh, tabletop game. Who's played it? OK, a few people don't, so if you want to make most people know that's cool. Sometimes we, we play this presentation in, in different countries and depending on cultures, sometimes people don't know. Some people didn't raise their hands, so if you want to make a brief, yeah, yeah, so. A tabletop role playing game is you might have heard of Dungeons and Dragons or games like this. So basically this is a Um, how can I, like this is an open world, uh, with a, a, um, universe that, uh, uh, that already exists that has a playbook, like a rule book that you can read, read, it's like 400, I think, pages long. And basically you can play in this universe where you can you can play like for example elves, orcs, um, yeah, dwarves and have your own characters and you can play a campaign and for example you have what we call a dungeon master. So uh the role of the dungeon master or the game master is to build a campaign to um. To embark the players into a story in this universe and the the idea of this project uh was because I am myself a Dungeons and Dragons player and I sometimes have troubles finding game masters uh because uh it's it's really hard to be a game master actually you need to know all of the rules of the game. You need to know a lot of things to be able to. Um, to drive your players, uh, to, to, uh, into a campaign and, um, I was thinking that maybe artificial intelligence could, could be cool, a cool tool to help, uh, game masters, uh, in assisting them, and we'll see today how, how we can build a multi-judging workflow for this. So first, um, I will introduce you to the concept of agents. Um At the very beginning of when uh generative AI became very public, uh, I don't know if you remember because I remember the announcement was made during reinvent, uh, it was 3 years ago for, um, oh yeah, yeah. For the well known like chat GPT, but generative AI existed before that, but it became well known by the public by this day because it was a tool that suddenly everybody could use and see the power of it. So you, you could chat with those LLMs. You can have a conversation with them. Um, but this is about it. When you chat with an LM, you can have a conversation. This is very powerful, but what you'd want is also this LM to be able to perform actions for you. And this is where agents come into play. Agents have agency. That's what we call them agents. They're able to make actions for you and the way they do those actions is because they have access to tools. Tools can be a lot of different things. They can be APIs, they can be functions, they can be databases. Um, they can also be other agents that also themselves have access to other tools. So you can see how this can build up pretty quickly. Uh, usually in like in there, there's no standard really, but at the moment. Uh, when you have multiple agents working together, you usually have one orchestrator that has access to multiple agents that each are specialized and experts into a certain task or a certain field. Um, one example that I like to, uh, give sometimes is when you want, for example, a coach, a studying coach for a student. Uh, you'll have the coach that might be connected to a team of different agents that are all experts in different fields in math, in physics, in history, and geographics, and so you have all of your different agents that are all of the teachers, for example, and whenever your student has a question to the coach, um, or maybe is asking for a set of exercises or maybe questions about something. Then the the orchestrator redirects the questions to the right expert to the right agent to be able to perform to answer the the query so. Um, Yes, uh, to connect those tools, oh, so sorry, to, to connect the tools with the agent, uh, we have what we call the protocol MCP. So MCP stands for model context protocol. Um, You might have heard of it because it's uh it's been it's been doing this this boom for this entire year so basically um this protocol standardizes the way your agents can discover tools. Basically, it's like. Uh, rest for AI agents, um, if you've tried to build agents before with tools, uh, before the MCP protocol, maybe you remember, but it was, it was pretty, um, complex. You had to maintain the way you, you'd connect to the, to the tool, for example, a function, uh, there was no standardized way of doing it, so I mean you, you were the only one who was maintaining this whole workflow. And in the same time you weren't able unless you were talking to that person, but you weren't able to connect to a tool that someone else would have built. And the power of MCP is that now if someone builds a tool and puts on, puts it on a server, uh, on a certain endpoint and give it to you, then you on the other side with your agent is able to connect to that tool. This is making things very powerful because now a lot of people are creating a lot of tools and with your agent you are capable of using their tools. Um, And also there is another protocol that has been very famous also for this year. It's A2A, which stands for agent to agent. And uh this protocol standardizes the way agent connects to other agents. So, Two very different things. One protocol is to connect to tools, and what the other protocol is to connect to agents. Why are those protocols different? Because the way they communicate is different. Between agents, you need to be able to, uh, build a conversation. They both have a thought process. They both have, um, um. How do you say planning and so they need to be able to have this conversation. Meanwhile, for a tool, you nec you don't necessarily to talk with it actually they don't have this thought process. The tools are just like functions or API calls or databases, so they're just gonna give you an information. They, they're going to perform an action for you, but that's pretty much it. So, for, oh yeah, so basically, oops, sorry. So basically. To sum it up, MCP versus A2A, MCP is to communicate between tools, uh, agents and tools, and A2A is for the communication between agents. So today we are going to work on this little project. Actually Olivia is going to build it live in front of you, which is really cool to see it, yeah, a part of it. So when I was when I was building my project for my, my, uh, dungeon and dungeon master, uh, AI assistant, um, I wanted it to be able to do a lot of things actually if you start thinking about it, the task is pretty tremendous if you want an AI assistant for game masters, um, so the first thing I did is that I had. Um, The orchestrator, so that's the AI game master that is talking to me, but as I said before, it has access to other tools and other agents that are each specialized into their different tasks. So this agent that I'm talking to. Has access to another agent that will be the character manager for example so the character manager is able to create characters on the fly for you. It has access to a database of characters so it can also get characters for you from the campaign, um, and it also, it also has access to, oh, it just has access to the database, right? It has tools to access the database, yeah, yeah. And a second agent um is the rule uh agent. So the ruler agent has access to the, the, the full book of rules of Dungeons and Dragons. So it basically is a rag. Um, so to make sure that whenever I want to do something in the game, then my orchestrator is actually able to ask the rule agent, is this possible? or in the mechanics of the game, this is this logic. And finally, uh, there is, um, an MCP, uh, server that we have where we run a tool. So it's a very simple tool. I will show you. I just needed my agent to be able to roll dices for me, you know, like a dungeon, uh, master usually takes decisions as he rolls dices for you, like do D20 or other types of dices also. And so I put this function into a MCP server and use the MCP protocol to connect it to my agent. Um Yeah, so that's what we'll build. Yeah, it's good. OK, that's at the end of it we'll show you a more complex, uh, uh, version of that demo, but just to show you, oh yeah, to build it, it's, yeah, of course we are going to build this in the time frame of this session thanks to an SDK. So Strends Agents is a software developer kit. Uh, that, for Python, but we'll announce maybe this week, yes, uh, for building agents in just a few lines of code and you'll see that this is literally just a few lines of code, which is really cool if you've built agents and multi-agent workflows before you'll see how much simpler this is now with strands and it supports MCPNA2A. Which is great because we've been waiting for this for a while. So this is what we use at AWBS internally, trans agents. This is, yeah, if you've been using like Amazon Que, that's used using like trans agents in the back. That's when we open sourced it like a few months ago, but we've been using it on Amazon Que for quite some time now. Yeah, there's a lot of internal tools that actually have been, uh, uh, built with strands internally. Um, so this, this also gives you an idea of how robust this can be because we, we run on, uh, huge projects with multiple agents. And it's very easy to install. Yeah, so the first thing you need to do is to install this library. Pip install trans agents, and then you're good to go. Let's do this demo demo time. Oh, nice. Are you ready? Yeah, OK, if you're already there, I'm gonna do it for you. Alright, so here I have my, uh, so it's Quiro, it's like, uh, my IDE, and basically I have basically nothing. I have like a, a AM PY, an empty file, and a requirement that take where I have my strate agents and strange engines and tools. We're gonna see later what it is, uh, used for. But I wanted to like start with like a blank project so you can see from start how, how it works. So first thing I'm gonna do is. I'm going to import strands, OK? I'm going, so I import the agent class, so I'm going to create an agent. Object, and then I'm gonna call it, I say. Good morning, Vegas. OK, let's do it. So I have 3 lines of code. Let's see if I execute them. So now what's happening now is like replying, good morning, I'm actually Claude, an assistant, blah blah blah, not in Vegas. OK, you're an AI, you're not in Vegas. But what you can see here is like in 3 lines of code, I've created an agent and called an LLM of my agent. So now you may wonder, so what kind of LLM is called in the background, so you can actually print that out. Uh, I can check my model. Here, and if I cut it again. You'll see that by default rend used Amazon Bedrock, and here by default is the Cloud Sony for um LLM. But we can change that actually, if I, if I import the Bedrock uh model class, I can create a new, a new object. Bedrock model where I can specify any bedrock model you can find on Amazon Bedrock. If I do that, I'm just gonna tell my agent, so, um, as a model, instead of using the default one, you can use please the bedrock model I just created. So now if I execute it again, you can see that now it's using uh Amazon Nova Premier, and you can play with all the configuration if I want to change. The temperature, for example, I would say like 0.7 whatever. And you can change that and you see that the temperature is changed for my call. And so if you look at this trends documentation here, trends agent.com in the user guide, you have the model providers here, and actually you have access to a lot of models. We, we saw that there's Amazon Bedrock. You have entropic, so if you're like an entropic, uh, entropic API key, you can use it. So strands is, uh, model agnostic and even provider agnostic. You have like a Gemini, Lama, you have a mintral. We're French, so let's promote that. You have an API key for minstrel. You can use it directly here. Uh, you can use basically everything you want. You can even use like Olama here. You say you have a, a provider for Olama. Do you know Olama? If you, if you don't know Olama, basically it's a, it's a tool that allows you to download a lot of models. If you go on the models here, you have literally. A lot, a lot, a lot of models, and what it allows you, it allows you to like download these models, they can go from like a few megabytes to like a lot of gigabytes, and to run them locally and it gives you access to like an endpoint, like an API endpoint, so you can call these models. So you can even use that, for example, if I If I import like the Olama class instead and I say OK. I'm just like gonna create like an olama object uh I need to give it the host so here uh I have um uh holama running on this here. So it's running locally on my computer and I, and then you specify the model idea. So in Olama to Run a model. If I do that, it's going to download the model I'm running on my computer. So I have a bunch already installed. These are all the ones I have, so you can see they can go from a few megabytes to a lot of gigabytes and even like way bigger than that. So let me take like the LMA 3.2 for example here. Oops. Here you go, and here I'm gonna tell him, OK, use the Olama model I just created here. So if I run my code again. You can see that now it's using LAMA 3.2. It's taking a bit more, a bit longer because it's running on my computer, so there's no cloud involved there, and it's still replying to me. So now I'm using like a um a model locally on my computer. So, OK, cool, yeah, that's cool, but it's not yet an agent. It's not like it, it's, it's an agent, but it's just running the L. Yeah, it's a, it's an instance of a class agent, but now what's interesting is that you can add tools to it. Yes, because the good thing with LLM is that they know a lot of things. They've been trained on a huge amount of data, so you can ask them pretty much everything, and they will have an answer. But sometimes you have like very simple questions like if I ask what time is it? Very simple, right? But if I ask that to my agent, he's going to reply to me. We don't need that anymore. OK, I don't have access to the real-time information, so check your device, check your clock, thank you. Ask an assistant, search on your web browser or like look at your watch. Thank you very much. So a very simple question, but LLMs can't do that. And that's where agents are are actually useful. So you can give them access to tools, and when they don't have the answer, they will check if they have tools that can help them answer this question. And the good thing is trends is that res comes with a package of tools. So if you go on the documentation again, you have these tools menu here, you have a community tool, tools package. So that's the, uh, you don't even remember, that's the other package I had in my requirements at TXT. And if you scroll down here, you have access to a lot of tools. Some to manage memory, to read and write files, to do Chrome tasks, use computers, going to move your mouse for you, uh, doing HTP requests, read images, generate images, calculation. There's one called Current time here. So for example, we can use this one to answer a question. So if I do, OK, from. Strengths tools, I want to import current time. So now I've imported the current time and all I have to do is to tell my agents, OK, you have access to all these tools, so I put them in an array. So right now it's only current time. And if I ask again what time is it, you will see that it's going to. It's going to, yeah, it's going to call the tool, so it's going to call the tool current time, and then it's going to reply to me, it's 9. OK, let's. In Las Vegas, let's be precise, you know. It's at 9 p.m. So, I asked him again, he's calling the current tool, um, current time tool, and he's giving me the time. So they can see that we, we enhanced um our LLM with tools thanks to the agent and you can do things pretty cool like you like file right you have you can generate code. I don't know if you use like a code assistant like Amazon Q, but basically you can recreate like a very, very small like version of it. So for example I give I I have my, my agent and I gave access to like this tool Fileri and Python Ripple. Python Ripple is a tool that gives you the possibility to execute Python code. So I can do something pretty cool. I can say, OK, let's write some code, like write a function in a file called feed.py that generates the first uh Xe to. Of the Fibonacci. OK, and then Execute it. So I'm just asking that to my agent, and if I execute it, what is happening is that he's going to write the code so that LLMs know how to write code. That's OK. Then he says, OK, I need to write the file because you asked me. So I have this tool, write file. So for some of the tools like write file, for example, is going to perform actions on your computer. There's a safeguard which is asking you, is it OK for me to write a file? You can bypass that because in the CICD you don't want that. So you have like an environmental variable that can allow you to bypass these questions. So I say yes. So now you can see that I have this feedback PY file that has been written, which is. I trust it like the Fibonacci um function and then again the Python Ripper one is going to execute code, so it's asking you as a safeguard, are you sure you want me to execute code? And then it's going to execute the file with the Python one you just created. So you can see that now with just like a few lines of code, give it access to like a few tools it can create files, execute Python code. And it's actually pretty cool, right? Yes amazing. Alright, so, but we're not doing, we're not here to like, uh, rewrite Amazon Que. We're here to write a game master. So when I write a game master, I want access to other tools like for example, Tiffany mentioned it, we want a tool to roll dice. So actually if you ask your LLM to roll a dice, it's going to answer to you because he's been trained on data that roll dice, but it's not like an actual random. So we want to have a tool that rolled dice, and I don't know why this trends team didn't think that having a roll dicing tool was. Generic enough to add it in the toolbox, so, but I can actually write a function. To roll dice with a number of faces and or I can write I can ask another name actually uh write the function that. It's 295. Come on, I'm gonna write the code. Roll a dice with a number of faces given as a string. Manage errors. OK, to run me a function because that's not the point of the. Of this talk, accept, OK, please indent it, nice. So here I have some code, OK, and wouldn't it be nice to just say, OK, I want my, whoop. I want my function to become a tool. That would be cool, right? Well, it's not that easy, unfortunately, but it's not that much complicated. I just have to import this tool here from strands and then add a decorator on my function, and just by doing that, my function here, roll dice, is becoming a tool. So if I ask it, OK. Roll a dice of 6. And I execute it, I execute it. Here it's going to call my tool roll dice that I just wrote and then yeah roll 2 on a dice of 6, but I can also ask like roll a like 3D 20, which means 3 dice of 20 faces. And when I'm doing that he's going to call 3 times my roll dice tool and then give me the result and even the total, even though I didn't ask for it, but bonus. But you can see that he called my roll dice 3 times. Pretty cool, right? I just wrote a function, it became a tool. Now, as Tiffany mentioned, there's 2 cases, 2 use cases where I don't want my actual tool to be written here. There's one use case where maybe someone else somewhere wrote a tool that is already doing that and put it behind an MTP server, so I want to be able to like use this MTP server or nobody did that and I'm like, oh, I'm a nice guy, so I'm going to like put this tool behind an MTP server so anyone else can use it, right? So let's see if we can do that. I'm going to create a new file. MCP dice, OK? And so the goal is to take my uh roll dice here. OK, remove that. So my agent doesn't do much, but he had access to an MCP server here that is going to be the one that has my tool, right? To do, to do that, I'm going to use Fast MCP. So Fast MCP is not part of Strends. Trends is here to call MCP servers, but not, strands is not meant to like create MCP servers. So Fast MCP is a well-known library that allows you to do a lot of things with MCPs, including creating creating servers. So I'm going to create a server here. I'm going to give it a name. It's kind of like a DD. That role service role. Service. OK, I'm gonna, you don't have to put all this information, but I'm gonna say, OK, you run on my local host and I want you to run on port. 8081, OK? OK, so I've done that and then I'm going to run my MCP server. So I'm gonna say, OK, I want you to run, and MCP servers, there's like 3 ways of running them. Either it's like uh on SCDIO when you run them locally, if you've done that with uh Amazon Que, for example, you can put like NPX or whatever how you want to run them. Uh, or, uh, SSC, which is like server who is pushing messages, or what I prefer is like a, um, streamable HTTP, so it's like an HTTP, uh, stream. So I'm going to specify the transport. I'm gonna say, OK, I want a tremble HTTP. Let's do it. OK, so now I have my server, it's running. All I need to do is to say, OK, I want, uh, I want this function to be a tool. So it works a bit like in strands. Fast MCP is like you put the your server and a tool decorator. So by doing that, I have a MCP server, normally less running. All right, uh-huh, or not, what is the wrong? Oh, it's run? My bad. Wrong function. So here, here you go. On the bottom right, bottom left here, I have my MCP server running on my local host on the port 8081. So now what I want to do, I want my gamemaster agent to be able to call this MCP server. So I'm going to import the MTP client class and because I'm using like streamable HTTP also the streamer HTTP function. And so I'm going to say, OK, my dice MCP. I'm going to create an MTP client. I'm give you the, the function, uh streamer HTTP. And I only need to give it the URL. So I'm gonna take the. The end point here What do you want? You want paste, OK. Um, 8081. OK, so now, um, I give, I have access to like a client MCP to my MCP, uh, server, and I'm gonna say, OK. By just doing that, my agent is going to be able to call all the tools of my MCP server, so let's run it again. Running it. Yeah, fast MCP gives you an endpoint with 4 slash MCP. My bad. OK, so you can see here you have something happening on the bottom left. So it's, it requires to list all the, uh, tools, and then you can see that it's coding the tools. So you have some call to requests. You can see here that I'm still calling my roll dice. Uh, OK, first one didn't work, but it's calling 3 times my MCP server roll dice tool, and I have the results again. So now I was able to externalize my MCP, uh, server, and so my main agent doesn't do much, but he has access to tools through the MCP server, right? And it's cool. Thank you. All right, so that, that's basically. We have a function. It's an MCP, OK, it has a function as a tool. Uh, Tiffany mentioned another thing we want to have an agent to manage our characters. So now what I want to do, I want to create another agent with who my, um, my gamer surgeon can communicate to ask him to manage, uh, characters, OK? So let's do that. Let's create a new agent. Um, OK. Blank file. So you remember how we create an agent? Yes, we import agent platform strands and create an agent. So here I'm not gonna be the one who call the agent manually, it's going to be my other agent who's going to call it. So I need to give it a bit of context of what it does. So I'm gonna say I'm going to give it a name, so it's like a. Management. Agent. I'm going to give you a description. Uh, here we go, oops, description. OK, description is like create and manage Dungeon and Dragon characters with a name, class, race, statistics, and background, and you can write and read character files. So in the project, in the final project what I'm gonna show you after, Tiffany mentioned that we are using a database here for the sake of the demo because I don't have the whole afternoon. Uh, I'm not gonna set up a database, uh, for the purpose, but what I'm gonna use is, I'm gonna use the tools I have access to, and remember we have access to. Uh, file read and file write. So for the purpose of this demo, I'm going to use read and write on files as a database in a normal project. You're using a database to manage your characters, right? So I give you access to the tools here I'm say, OK, you have 5 read 5 right. Here you go. And now I have my agent. Good. OK, so in order for this agent to be able to be called by my game master, I need to make it an agent server. So I'm going to create an A2A server here. And let me create a An object, which I'm going to give it the agent. So on, on this A2A server, agent to agent server, I want this agent to run. Again, I'm gonna say, OK, I want you to run on my local host and I want you to run on another port like 8082, this one it was 8081, the first one, right? Remember? Yes, let's go with 8082, and then I'm gonna say OK. I want you to run. Right, so by just doing that, I created an agent who has access to who has access to tools. I have an agent to agent server. I'm just running it, so less running. Let's run it. OK, I'm running my agent character, uh, agent, so you can see it's running, so I have my MCP here, server, and my other agent running here. So I'm going back to my main game master, which again, we don't want it to have any, any like capacity, it has to rely on other uh agents and tools to, to work. So I'm going to, OK um. Import an A2A client to provider. So for the MCP servers, you need to create an MCP client for every MCP server you have, because you have to get access to their tools individually. So a bit of a difference, when you have access to an MCP server, you can list all the tools he has access to, OK, and so you call a tool from this MCP server. When you call another agent, you're just sending a prompt. And the other agent, which actually can use a different LLMs, you can use another another provider on this other agent, but these other agents, you don't know how he functions. You don't know what Tulsa is, what tools he has access to. You don't know if he's calling any other agents. The purpose of it is to run his own LLM, to have his own like reflection and iterations, and then to, uh, give you an answer. So that's why for the MCP we need an MCP client for every MCP server. for the For the agents, however, it's a bit different. I can say, OK, uh. You can say, OK, I create like an A2A client provider and uh it takes an array of all the non-URLs of all the agents you want to call. So here I have my, my agent, so which runs on my 8082 port. Here and if you have others, other agents, you basically just it's an array so just put them all here, right? We only have one now. And so what I'm gonna do, I say, OK, this provider, he has tools. So now the tools here is not the tools of my agents, it's the tools of the provider that gives my agent access to coding other agents. Yeah, it's gonna make clear in a second. It's gonna be clear in a second. OK, so now I have my MCP client for my MCP server, my A2A client to provider to call my other agent. Let's give it a try. Create a. DND character name, give me a name. Steve, Steve, who is an elf of the night, yes, let's be. Night Night. Oh, OK, roll the dice to generate its. Characteristics, then save it in a file, OK? So, we're doing that. So now when you start to have a good practice when you have um agents, is that when you start to have like a lot of MCP or other like um tools or agents you can communicate with, a good practice is to give it a system prompt. So a system prompt is basically a prompt that is gonna tell him what to do, what is, what it is responsible to. But something I like to do is to give me some guidances in this system prompt. So for example, here I said, OK, you're a D&D game master. You have access to different tools and agents. Use them when you need them. So like you can draw dice, you can create them as characters. You don't need to give it to tell him how to do it. Just like you have access to these things, just use them if you want. And because we don't want it to do anything but only rely on these tools and agents, just specify like. Never answer by yourself. Always use the tools and our agents, OK? It's a good practice. Let's do it. It's gonna work, right? It's gonna work. Yes, it's gonna work. OK, let's go. So, what is happening? OK, it's calling my MCP server list to request. Um, also doing some agent stuff. So now throwing dices, uh, for ability score, some things. It's going to generate like 6 main abilities, so, OK. Strengths 11 Average Steve do uh 12 in dexterity. Average Steve 8 for constitution at the best. Uh, Steve is quite intelligent. That's good. Um, how many dice are we running? Uh, 16 weeks. Oh, Steve is not the best character. And that stands for charisma. OK, so now you have the characteristic, and you can see here, OK. So here, it's um it's using this tool, A2A send message, and that's what I was talking when I had the tools here. So the tools here are this kind of tool that allows my agent to call the other agents. So you can see at the bottom right that my other agent had been called and again he has access to like a file right tool and he's asking me if I am, I'm OK to use it. He's writing the tool and now I have a file here, Steve Knight F character with all its characteristics. So you can ask him to write it as a GO whatever you want. I didn't specify anything, so it's just like a file. The same thing I can say, OK, what can you tell me about the character Steve? And if I execute that. Again, OK, tools, we don't need the tools normally for this one. You say, OK, I need to check what agents are available to help me, uh, get information about characters. You can see that you say, OK, uh, it's listing the agents. I have access to a D&D character management, it's sending a message, and if I scroll up here. You should see that tick tick tick tick here he's using the file read tool so it's it, it knows that he has a a file about Steve. He's reading it, sending the, the response, and then we have my agent here, my game master who uh who received all the information about Steve. And he even gives like some like seem like he relies on studying knowledge rather than blah blah blah. He gives his opinion. But basically, we can see that in a few lines of code I have uh my first agent, another agents, tools. Something I didn't mention though, I forgot to mention, when you have tools, so here it's pretty obvious. I have a tool that is, the function is called roll dice, um, it's, it, I mean, it's pretty, pretty obvious. So when I ask my agent to roll a dice, he's going to check and say, OK, there's a function called roll dice, it makes sense that it's rolling dices. Now, When you don't have, if I generate the dog string. When you have multiple tools, um, You have to use dog strings, so that's how actually agents discover tools. Um, using the dog string, let me just click that in. So you need to give it a description. You need to give it the arguments, and then you can return team and examples here. So when you have a lot of tools, it's actually using the dog string to use that, and that's what I use when I use the, the tools here, the current time, you know, the first time I said, OK, give me the time, and he gave me the time like UTC. But if you look at the, the, the code, the source code of the current time, you can see that he has a dog string here. And in the arguments I can give you the time zone. So when I say in Las Vegas, my game master agent transcribed Las Vegas to the time zone and called the tool current time with the time zone arguments. You want to add something? Yeah, uh, just so that's interesting, um, when, when you write your, uh, your tools, um, you're, you're actually in the documentation of strands. I don't know where it is. It was there. Oh yeah, uh, you have examples of good practices, and it's actually good to look at them. You have examples of good practices of how to write a good prompt because, as Olivia said, this is crucial into your design because it uses this description to know exactly what the tool is doing. So there's a standard way of writing in those uh do strings now and what I would recommend for you is not to write it on your own but rather give the example to your AI code assistant or uh but make it generated by an AI and give them the example of the good practices that is in the strands documentation and then give them the function and they will write a perfect duck strings for you, um, but yeah, I like almost never write my duck strings myself anymore. Yeah, most of the time it generates it by default, so, but yeah, it's a good, it's a recommendation to use the dog string because that's what you want them. If you have like multiple tools, it may not know which one to call, so it's going to, it's going to use the dog string to know how it's called, what it's doing, and what parameters he needs to take and the type of the parameters. Good, OK. Sure, I don't know how question works, but yeah, I'm open to questions. you. For uh orchestration, like a master. That Yeah, so So there's different ways agents can communicate and work together. Here what we did is like we just let the agent to discover the other agents and to call the one he wants. But if you go on the on the, the trends documentation, there's different ways of creating agents. You can create like workflows. So basically you said like I have these agents, and I want them to always be executed in that order. You, you can have like graphs of agents saying like, oh these graphs are connected, these agents are connected. You can have like swarms of agents. Actually, if you go to Let's look at the agent leak workflow here. I think you have a code sample. So here you have like an agent, researcher, an agent, uh, analyst, an agent like writer agent, and so you can just tick tick tick tick where is the. Um Somewhere, somewhere. Here All right. I don't know exactly, but you have, you, there's a the example somewhere you have what is it? But basically you can yeah you can do like work orchestrations, swarm graphs. I think that's what you meant that. Hm? Was it like Do what I mean, and then it's, it's still going to use like A2A um underneath, so the protocol is still the same that is used, it's the standard protocol. I don't know the answer to the question. Hm? They live a photo that The acestration agent is still going to use like um A2A unless you run all the agents on one code which you can do actually you can run all the agents, the agent to agent. So what we did here, OK, I think I got the question is that we run the agent on a like its own on a uh server right with its own uh. Uh, like end points, but you can actually, yeah, you can do like like they do here it's like, OK, I have an agent. Here And I have another agent that you write in the same file and so in that sense here it's not going to go to use A2A because they're all running on the same source code. Um, I don't know if there's a good practice or whatever. The good thing when you have an agent running on its own server is that anyone can call it and it's not just for you, but. That's the software design. Or architecture question. We have time. Are we good? Alright, so that's it for the life coding demo, but we want to show you the final products, final products. Still a demo, but a bit better. Taking over? Yeah. All right, should I run it? Uh, yeah, so what, so it's really tiny, um, at the screen we realized this, but this is, um, this is just to show you all of the different, uh, servers that we're running. So the first one that Olivier was running was the, um. Server here. The server is here. Then here is the character agent. The rules agent, the rules agent, and then the orchestrator, and we have built a front end application. Do you want to show the Scot a bit before? Yes, sure. So tell me what to show. Um, so the MCP server is pretty much the same, uh, that we have shown during the demo. The character here is the character, um, agent agent. So it has access to a database. We have not created a database together, but here it is. You can, you, you can see that we've, um. We have given the agent character a bunch of different tools to allow it access to writing into the database, uh, reading into, uh, reading the database, and also I think deleting, um, things, so it really is managing this databases of characters, um, and you can see that basically each tool here is literally just wrapping a database call just like saying oh find character by name. We give it like a name. There's the, the dog string, and then the only important like line of code here is this one, DB search. It's just like wrapping like an API would wrap database code. The tools are doing the same and all of that wrapped into a tool decorator. And we've made a massive system prompt and description uh because you'll see as you iterate through your tests, um, prompt engineering is still a thing. Uh, you still need to, to make sure that, um, your prompt is actually like describes well, uh, the different actions that the agents can do, um, specifically if you want a certain format as an output or specifically if you wanted to standardize because for example for creating a character this is a pretty standard output for us we always want kind of the same format and everything so. We needed to be very specific into what we wanted, uh, the, uh, character, uh, agent to perform and also this is the system prompt of the, uh, game master. So the, the orchestrator also has a massive, uh, uh, system prompt we have this is through several iterations of testing this demo that we've come up with this, uh, big system prompt, um. It's um I mean it's a pain that you have to go through I guess like at the moment testing how your work flow uh goes uh and iterating through different prompts is is is the way you can you can reach satisfactory outputs um. Here we, especially when you want like a like an exact output type, yeah, so we came up with this Jason format specifically because we had a front end at the end and we wanted to be able to take each of the outputs and put it in the right place in your front so you know like at some point you're like if you want to generate things automatically you kind of need your orchestrator to answer to you in a standardized way. Um, and this prompt actually works pretty well at the moment. I'm, I'm saying this, but maybe the demo is gonna fail, but no, no, it's not, um, so live demo, yeah, here we wanted like the response to be, to be like used in a, in a, web applications. We like give it the response based on this response, which is like what the game master is saying, Give us an action that you can suggest the user does after the player. Give you some details and if you roll some dice, just tell us the kind of dice you rolled, the result, and the reason why you had to roll the dice. Should we, should we try? Yes, yes, yes, OK, alright, so Steve, we see that Steve, Steve is a man. He's a dwarf this time, random, and he's a cleric. OK, so I'm gonna take this. you I love my game master. Let's go. OK, so as we launch, uh, the game, uh, the, uh, AI game master has the instruction to launch a campaign. Uh, and create the character Steve with the characteristics that we gave him. So it, what is, what is Steve? It's a human, uh, no, he's a dwarf, dwarf dwarf, yeah. So you see that there are different calls that have been made by the game orchestrator. Some, some like the, the, the dice tool has been called. The character agents has been called and it generated like an answer and send it back to the game. So let's see what we have here. You want to read what it says. Welcome to the room, Steve. Your English is better than mine. Welcome to the realm, Steve. Your driver's boots crush, crunch on frost-covered cobblestones as you approach the flicker. Ring torchlight this is pretty cool. Like you can, you can read the entire thing. I've played so many different games with this. This is pretty cool. So we have 3. We asked, uh, the orchestrator to generate 3 different options that you can click if you don't wanna type. Um, so let's investigate. Investigating is cool because it usually leads to dice rolls, um, as you can see, um, OK, we have the response already. So it was investigate the strange sound coming from the alley behind a tavern. And as they uh as the um uh game master is rolling dices we can uh we can get the results of the roll dices and uh put them in our uh front applications. Cool you can type what you want if it's like run away. Go home. I don't know. And he's gonna do the same You want to try the rule thing? Well, so, um, this, this is where this is where we know the boundaries of our demos. we let's let's try to, let's try to make it invoke the rule, the rule agent. Is it something that has no sense fly to the moon, take your light saber, and kill the monsters. So basically, if you, if you want to do something that has no sense in the mechanics of the game, usually the game master will be like, you can't do this, but We'll see if so there's an error message first. But OK, let's ask him instead, like, can I go to the moon? Can I? Can I fly to the moon? And back with My rockets, let's see. It should. Request the rule. Agents, uh-huh, OK, something's happening here, yeah, yeah and the rules. Oh, it's working. I'm so happy. So for, for the roots agent what we did that we took the PDF of the game, we put it in a vector database, so it's like a rag. And so that's how our agent is able to read it and say like Steve, you're still bleeding in a dark alley facing a dangerous bandit. There's no rocket in the medieval fantasy world of D&D. You are the first level draft cleric with whatever. No, no, no travel, no sci-fi technology, sorry. Well, I mean that that's good because it's actually arguing as to why you can't do the things you want. To do, but yeah, it's actually checked the rules of the games to see if you actually could not do this. So yeah, uh, this is really cool. So as you can see in like a short amount of time, do we still have time? Yeah, uh, we're able to build, um, multi-gentic workflow with, uh, the strengths, uh, SDK, um, do you wanna add anything else if anybody wants to try something. Let me check um. Because you should be able to find this. OK, just for those who want to see this in action, if you go on, uh, Away samples, you have these sample ones upon, uh, Agentic AI. This is usually a workshop, but here, so by default you won't see anything on this branch. But if you go on the solution B3 here, you have all the source code to run the, the demo we just ran. And if you go in the UI, uh, branch, you even have access to the UI. That we use, which is like a angular application. So feel free to go check. Let me share the QR codes, yes, with you. So if I go back to the presentation. Uh, so those were if we failed we had video recordings of the demo. It worked. The demoed it did work, yeah. OK, so here are the code samples that you can get also the trans documentation if ever you're interested, um, and if you have any questions we still have a little bit of time. So thank you very much for your attention.