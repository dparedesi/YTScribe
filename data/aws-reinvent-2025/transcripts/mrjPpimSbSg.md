---
video_id: mrjPpimSbSg
video_url: https://www.youtube.com/watch?v=mrjPpimSbSg
is_generated: False
is_translatable: True
---

So hello everyone and welcome to this session AC 321 where we are going to talk about how you can take advantage of the goodies but without being stuck in the candy store. So I'm Jean Francois Andreu, also known as GFL. So Philippe is going to call me that name. It's not a new service. It's not an airport. It's only me. And I'm a solutions architect at AWS uh for global financial services. Yeah, like JFL, my name is Philip, no jokes aside, my name is Philip. I am a global solution architect also working mostly in the financial industries and spending most of my time building flexible data and AI platforms and these days also agentic AI platforms. So let's get started on how many of you have been stuck in this conversation you can have sometimes with the application teams. They want to take advantage of the cloud goodies, as I said at the beginning, but the IT folks, the managers, some people with more experience in IT, and they are worried because of their experience of what it could mean in terms of lock in. Is it going to be the new mainframe? Are we going to have problems because of that? So how are we going to address this concern? It's a legitimate concern on as architects where the ways to articulate and to make sure the application teams and the rest of the IT organizations are going to be happy with the cloud. So the first thing we need to explain, so what are looking for, what the applications teams are looking for when they are going to the cloud? What are the benefits? Then we are going to use two architects' maneuvers. So as architects, we can bring new perspectives. So we are going to add dimensions, go through different layers, and with these tools that we can use, we are going to analyze patterns, actually two patterns we believe doesn't work so well when you are concerned about that. You want to be able to move from maybe one cloud to the other or go back to your premises. So 2 patterns that works not so well and 3 patterns that works quite well actually. So first, mobile cloud applications, what the application teams are looking for in the cloud. And very often you are going to see this schema. I mean this diagram, I mean you understand it, VM probably not so modern, or less more modern, but actually this camera has multiple errors into it. So first, containers are serve or less. Well, what is the distinction? You can run containers in lambda. You can run in ECS elastic container service with you can run serverless, so you have containers serverless, so it's not accurate and actually you are not looking for only the runtime when you are looking when you are going to the cloud, when you are using these goodies that you have on the cloud. So let's say now you have set up a lambda function, but you have done it with clickups. Is it a modern application? Probably not. So you don't have a CIC. You don't use deployments. It's probably not such a modern application. How much managed services do you use? That's going to determine also if the application is going to bring all the values you expect granularity. If you run a gigantic monolith in an EC2 instance, is it really a modern application running on the cloud? Probably not. So even programming language, if you are still on Cobal, hey, you don't have APIs, it's probably not such a nice cloud modern applications. So not only about the run time and you have all these other dimensions you need to take into account. And the reality, why you go to the clouds, you go because it's going to help you with the scalability. It's going to clarify the cost. It's going to be more transparent. You are going to gain in agility. You are going to be able to deliver faster, more frequently. All these advantages, more resilience, and also observability. You are going to have more detailed observability that is going, for example, to help you identify where there is a performance issue. So now if we look, even we abstract even more, so what are we looking for? We talked about fine grain. We don't want these large monoliths, and when we have fine grained applications, finer grained applications, well, we gain failure isolation, so the resilience is going to be better. And then the teams, particularly when you have lousily coupled services, the teams are going to be able to work independently and they are going to be able to work faster. And then some applications they are even going to be even driven on even driven applications, well, you, you can make them evolve even more easily. Think about your message bus. You can put a new producer, a new consumer, and you extend you evolve your applications. And now people are going to say, well, well, we want that. I mean, sign me up. There is no problem. It seems to be good qualities you want to achieve with your application team, so no problem with that. But still, the IT experienced senior managers may be concerned. Sometimes it's procurement may be concerned, but is there still a lock in? Is there still something to pay if we go in that direction, and we need to address that now. Yes, thank you JFL and as JFL told you and um yeah as architects we're trying to create new dimensions uh sorry to see the world in more perspectives um and we saw this we see the world as as as trade-offs, right? And there's never this this one single right solution and there's never this one single wrong solution or option to solve um a certain problem. So given that the most powerful architecture maneuver um we can apply is actually twofold. We can try to break down the problem into multiple small pieces and by doing this creating adding more dimension to the problem or or and or even better and what we can also do is um broaden the scope of the solution. And um having more options available for the actual problem. This may sound a bit abstract, but no worries, um, I'll walk you through this. Um, so what we hear a lot and especially um in the beginning of these um discussions when talking about lock-in is, well, I like to have the new world, this, this beautiful modern, um, fine-grained managed services, but then there is this, um. Red flag, which is like the login. And the login is basically uh it's a very single dimensional um perspective on that problem because I mean there's no happy place for this, right? I mean. What we want to have actually is more cloud usage and less login, right? We do not want to have this blue bar here. What we actually want to do is we want to bend this curve and have like a lot of cloud usage, but less login. So the question is, how can we get there? And as I've told you, architect maneuver number one is adding more dimensions to this problem. And the first dimension we are going to try to break down into multiple small pieces is um the dimension of locking. And actually when we're talking about logins, most people, they, what they mean with login is actually vendor login. That's the first thing. And the second thing, and that's also the reality is um. There is no login, right? So what people also mean when talking about vendor lockin is basically the switching costs, right? So the switching costs of moving from vendor A to vendor B. So if we keep this in mind, then we quickly can identify, well, I mean, there are even more dimensions to this, right? It's not only the vendor who is creating switching costs, right? It's also things like the product I'm using, maybe I'm able to switch to a different product, which will of course then also create switching costs. But also simple things like changing versions, right, can be a simple problem but can be a terrible hard problem. For instance, upgrading your database version to a version which is not backward compatible, right? It's a hard and tough problem. Um, also architecture refactorings, right? Refactoring a monolithic architecture into, for instance, a distributed architecture. It's, it's going to be a long and painful endeavor, right? And all these things, they contribute to the switching costs and by, and also don't forget skills, right? If we are modernizing or changing into a different technology, re-educating um your, your staff, your team, your work is also creating lots of costs. To stay within our two dimensional story, the popular decision model we can apply, and also for this problem is uh 2 by 2 metrics. So we can try to break down the problem into the utility we are getting from our logging. In relation to the switching costs. And we will identify, by doing this, we can identify, let's say 4 quadrants. The most boring one is here in the white box. It's a commodity, right? Commodity means um low value but low switching costs. Think of it like conceptually, for instance, like like in USB stick, right? You plug it in. If it's break, well, I, I buy a new one, right? I I I couldn't care less. Um, more interesting though is the, the green box because the green box is, hey, I'm getting a lot of value out of my, of my login, um, but also I don't have a lot of switching costs. Unfortunately this is, uh, pretty rare, but there are these the these technology services they exist and when JFL will later talk about managed open source small hint. They apply to, to this green box. And of course there is this yellow box, yellow, it's a warning, right, be careful. There are always these things like, OK, low utility but high switching costs. I mean simple message avoid them. And then there's um yeah, 4th very interesting quadrant with the blue one here, which means, OK, maybe I have a very unique problem. And um I can accept a very high lock-in because the value I'm getting out of this lock-in like like for like with a marriage is pretty high. Right? So this is an interesting concept, I think, to keep in mind. And by, by this example, We can now have a much more nuanced discussion when discussing about let's say switching costs and this is what we call the architect maneuver number 1 and by saying this, handing back to JFL who will introduce you to maneuver number 2. Exactly so architect maneuver number 2. The first one, it was about adding more dimensions and not staying either it's good or bad and nobody is happy in the middle. Actually, so with more dimensions we have more possibilities, and we need also to think across layers and you probably all know this model. How many of you have been either on the application teams or on the infra team and have been on the application team side actually and I deployed on the the operation teams who was responsible to run this application for me. And they are also deployed. The other technical term is throwing over the wall, and actually the problem when you are on the upside, very often you try to pass the blame on the other side, and it's a model that doesn't work and we got we have better ideas now. We do dev ops, but if ever you come from this model like many of you, I mean me included. You may think that the people at the bottom, so the blue box, not really the guys at the bottom, but the blue box, well, they are responsible for the scalability, they are responsible for the availability, they are responsibility, responsible for these elites for my application. And then you may think, well, portability, it sounds a little bit like the other realities, so it's something that they should take care about. Very wrong idea. So first think about Sales. Who is responsible for the code in the lambda and who is responsible for putting the lambda together with your sequence S sequence Q, for example? Well, it's the separation is not so clear. Very often it's the same team, so you don't have this separation. It doesn't work so well and actually the application team. I have a lot of responsibility for the portability, so don't forget it's not only the responsibility of the blue box, but also of the application team. So now we have a new model and probably many of you are using this one. We came with platform engineering and with this new model, with this new mindset, so the platform team, the blue box, they enabled the application team. On the application team, they have their full responsibility to run their applications. They are going to worry about the scalability, the availability. They are unable by the platform team, but still they have to take care of that. And with this mindset, it's clear portability is part of the responsibility of the application team. So the lesson here is don't try to solve a problem somewhere else from where it originated, and it's the application team that has a lot of responsibility with portability. So yeah. I mean we already announced it we will also talk about things that do not work well and one of them is uh provider mappings and um I have to admit to be honest, um I was working as an enterprise architect here um no offense to any enterprise architects here but I mean what we typically have to do is drawing this super nice high level capability diagrams, right? Um, and if you just fly high enough every cloud vendor looks the same awesome. Like they have virtual machines, great, um, we have serverless functions, cool. Um, same goes holds true for message queue and no SQL databases, but let's hold on. I mean, no SQL databases, I mean there are lots of favors to this, right? NoSQL database means it could be a graph database, could be a document store, key value store, um, I mean, you name it, there are myriads of different types of um noSQL databases, right? And all of them have been designed in a different context with a different philos philosophy in mind and obviously they're integrated already in that specific environment, right? So, the more we zoom in into this problem, the more nuanced and the more different these things become, and it's getting even harder and harder to really distinguish between like to to really compare them on a let's say a reasonable level. And just an example, I mean it's um pretty straightforward service. JFL mentioned this already is Amazon EventBridge, right? EventBridge, we're taking this year as an example you can choose whatever service you like. I'm pretty sure it applies for all of them, um. It's built um as an event bus so what it does um state of an event changes something in the AWS cloud happens or in your application, so you're sending an event to to to the to the event bus and then it triggers like a downstream for whatever step function, lambda function, you name it. But, and that's the important part. I mean there are lots, lots, lots of unique different uh properties of this service which come along with the service, right? For instance, it's come through a schema registry, um, has hundreds of different connectors built in event filtering. All of them are unique abilities and the point is you remember we were, we're having, we had this metrics, it's um 2 by 2 metrics where we're talking about value. It's when you choose a service, right? You choose the service for for certain features and maybe for your, for your problem, Eventbridge is the perfect fit because you require an event registry and if you're not having the discussion on that level, you actually cannot see this value maybe taking let's say the wrong. Decisions. So what I want to show you with with this example is service mappings are dangerous um illusion and oversimplify um the problem of picking the right service. And by this giving to JFL, so it was the first patterns that we believe don't work so well. So actually we don't do service mapping. We don't have that. Some other vendors do that, but we don't do that because there are many things we can distinguish. And the other pattern we have seen a lot and that doesn't work so well is technical abstraction layers. Actually we all know layers. I mean it solves a lot of problems. There are even a CRM for that, and the main CRM in IT, you can solve any IT problem with a new layer. So does it work so well all the time? Well, we have a demonstration. It works well. We have done that already and we have standardized, for example, for our web services so that we can communicate. We can build web services in different languages. So today I can decide over here I'm going to work with Java. Over there I'm going to Bingo and how did we manage to do that. So we added this API layer and we fixed, we standardized the layer on top. So HTTPS we all use that GSA, we all use that all out, so we standardized the layer and doing that. We gain options, so we have harmonize on top and we gain options at the bottom. So it doesn't mean that you should build an application with all possible different languages, but that means that if you work with another partner that let's say works with Go and you work with Java, you can still collaborate with each other. And what happens with this standardization, we open new options. But then, so now let's apply this CRM. We know it works. Does it work for the cloud? Platform A, Platform B? We put the layer on top, and then we have the applications and they are going to be able to move from one place to the other. Well, let me take one example that demonstrates that this doesn't work so well. I don't know if you know Esperanto. Who knows Esperanto? OK, nice. Well, I know Esperanto because the capital of this language is close to where my parents live in France. But most people don't know that, so it's a language. It was the idea. Let's pick some words from the different human languages we speak. Let's let's pick some of the grammar, and we are going to build a new language, and we are all going to be able to communicate with it. The problem with that, it will mean everybody needs to learn Esperanto, and actually we have already a de facto standard. English, so I'm French. I have a bad accent, but still I speak in English and you can all understand me. So I mean we don't have this need so much to learn a new language, and that's the idea behind this extra layer you may not need. And another problem why this um pattern of adding more and more layers does not work so well is um basically as we've shown you before cloud vendors are different right? So um if you remember the event picture for example again like there are little nuances which are different right? So I mean. What I saw a lot with like my big customers I mean it it it gets better but it's still there is the idea of cool I mean um cloud provider A does not have this feature so I'm starting to build these features on my own and try to to like catch up with the cloud provider but honestly this is a super tough race, right? I mean. I think we're raising around thousands of new features over the year, so keeping up this race is going to really be a super costly endeavor. I mean, obviously what you can do, you can try to do the opposite, right? So just use what the common denominator of the different cloud offerings is, but I mean this will kind of eliminate the value you're actually trying to get out of the cloud, right? Because then what you can do is just use what both have in common and pros probably this is probably be a little right beside of this it also puts you in into a disadvantaged spot right to your competitors because you're actually not using the value you could get out of the specific uh services. And there's another aspect of this, and this is where this approach clearly gets to its limits because there are also physical characteristics of these services which you cannot influence just by adding new physical layers, right? For instance, I mean the pricing model, we are the ones who define the pricing models, right? So whether a service is for instance built by request or just by up time, this is something which you can simply not influence. Same holds true for things like the geographic, uh, presence of or availability of a service. I mean, we are AWS or the vendor decides where to deploy a service or not. You can hardly deploy, for instance, Dynamo to be, uh, I mean, where we don't have a region or something like this, right? So it's a pretty tough problem to solve. But I do not want to neglect that these options provide value, right? We discussed this in the very beginning, um, and indeed options have a value. I think there's even a mathematical proof for this, and I'll show you an example later why and how they add value, but. The point is, especially on adding these layers, um, you also have to keep in mind, of course, I mean, it's the developer efforts, the developer awards, you have to um, to invest to, to, uh, by, by just adding these layers, but also, and this is often overlooked is the opportunity costs of doing this, right. Because while you're investing in adding and building all these layers and doing the investments to keep the switching costs low, I mean you're not investing into your business, right? So you're allocating the money for something which could maybe even better contribute to the business, right? And you're increasing the complexity of the system, which is something at least we as architects, we don't like this, right? So, so as you've learned in the beginning, JFL me and me, we are working in financial industries, so we had to pick an example which is from, from financial industries and an interesting uh model to look at this problem is actually option pricing. And options work, they work like an insurance, right? You pay an upfront fee to um to to control or to reduce the impact of an event. For instance, like stock prices go down, or fortunately I've bought an option which will now like move me in a more favorable position where I can like sell my equities for for a better price than without having this option. This applies pretty well to our problem actually, because, of course, uh we should not be naive and do not invest anything into, into preparing for, for switching, but on the other side, we should also not overcommit. Um, into preparing for, for the switch because in the end, the point is switch, it's, it's maybe, right? It's, it's an event that might occur, but we're not sure that it's going to, I mean the question is, does it even ever happen, right? And also on top of this, I mean, it's money we have to invest now, which is not then available anymore for to contribute um to our business. So the message actually is pretty simple. So the sweet spot most probably is somewhere in the middle and not um at the extremes. Back to you, and we work with and we work with global financial services or with big enterprises, and very often they ask, how can we be as fast as you? How can we be as fast as a startup that works on your cloud? And actually this fast company, one of the secret recipes, they don't like to use this complex portability framework because as we've seen on the curve for the options, you have an upfront cost, and it's a cost you need to invest money, but it's effort and it's effort distracted from the features you want to build, from the speed at which you want to bring new features to your customers. But we have some other examples. Some people are going to say, well, SQL, SQL isn't it an example where we have a standard. Everybody is talking the same language. Most databases. This is a good portability framework. So what is interesting here is to look a little bit at the history of SQL. So how did it appear? It was IBM. They had these new storages and they wanted to make sure that the application teams, they can be efficient. They can access the data efficiently, and then they developed this language and then the competitors, the other vendors realized, well, it's pretty cool. Let's implement the same thing. On implementing the same thing, so it's not that easy. It's 587 pages of specification, and we all know that all different databases are. They don't exactly support the exact same definition of sequel. If you want to port from let's say Oracle to Postgress or IBM to another database, you all know that it's not obvious. You are going to have some efforts to do here. So here what's important to recognize is that Well, productivity was a trigger. This is what made SQL a standard. You need to bring productivity first and think about portability as a second aspect. And why is that? If your competitors are productive, deliver a lot of features while you are developing your portability framework, well, actually you may not have to worry about portability anymore. So think about it. When you select a product, a framework, it needs to help you today. It brings you, it makes you productive and not only in the future, because the future, well, it may not come. So now, we are finished with the bad news and we are starting with the first pattern, actually a good news, and we started to talk about SQL, so de facto standard. And open source, we have a lot of these de facto standards. So somebody has created a new database system and shared it open source, and a lot of people started to realize, well, it makes me really productive. And then it got several implementations and what happens as cloud vendors what we have done. Well, we provide manage open source, so manage open source, and we have nearly all all categories. We have a lot of databases. I talk about Pores. We have managed, Aurora, RDS, different options. One time EK. I'm a big Kubernetis fan, so with EKS. You don't have to worry about the control plane. This is managed for you, but you still have the standard that you like to deploy your applications to implement your platform, and we have many of these other systems. So on the messaging queue side and EMR, so many different places, and it doesn't stay only on the web application side and not only the service you use for web applications. I guess you are going to hear a lot about AIML GI during this week. Well, we do the same efforts, so we bring you open source, so managed, so it's on the green place in the schema from. From Philippe, so a lot of values, but switching costs is limited, and we manage that for you. Same thing for for Gary. We have a bedrock where you can have a number of LLMs that are open weight, so maybe not fully open source, but open weight, and you can customize them. We have the Bedrock adjunct core and we will see with adjunct core, so we run the adjunct, but you can still select your framework and very often it's open source framework and we have Amazon Sage maker on Jumpstart where here you will be able to use some of the open source models more on the area and let them run very easily on Sage maker. So how does that look for standard applications? Well, you are going to have agent core here. You are going to be able to select your framework, so still open source. You can select your own agentic framework. You are going to select the model as well. You have options and you can select an open weight model, and then the rest around the mechanics, the heavy lifting, which is not really bringing some differentiation, will take care of that for you. So manage open source. It's a good pattern. Use that a lot. You have the open source that brings the portability plus the value, and we manage that for you. So the switching cost is going to be reduced, and you have a lot of value for it. That was the first good pattern. Yeah, and let's continue with the good patterns and the second, um sorry, the second pattern or um highlight of this or idea how to um reduce switching costs is, um, velocity and that's a dimension we haven't talked about yet because if you remember our graph from the very beginning of the session, um we were thinking about OK what are the dimensions we could add we broke down the login. But there is another dimension, the one I've mentioned a second ago, which is, uh, velocity, and velocity is pretty interesting because the good news about velocity is first of all it's um fully under your control, right? It's, it does not depend on on on on us as a vendor. The second good news is. Other than the investments into, let's say, logical layers or other stuff. Investments into a good let's say um dev ops lean organization agile practice it directly pays out it's kind of a no regret move because you directly benefit from having things like continuous integration, continuous testing, and I mean it's, it's obvious because think of OK, now I need to for instance change my architecture or refractor from like monolithic to. Um, to distribute it, I mean, having these continuous delivery pipelines in place will drastically reduce the risk and the costs of doing these things. And an often forgotten and overlooked aspect of this, uh, discussion as agile, not agility in terms of, hey, we need to have our daily stand up, um. It's more like HI helps a lot to really focus on the business outcomes of your products, and by doing this, you're reducing the clutter left and right, which you have to touch like again and again when it comes to the event of switching. So in a nutshell, switching costs is also a matter of how you work and not just only about which uh services you are going to use and by this. We have already seen two good patterns. First one, manage open source. Second one, velocity. It's going to help you. good development practices is going to help you to move. Another one where the architects may have a very important role. So preserve the design intent. And what does that mean? We talk about even Bridge. So Even Bridge, simple service, simple icon, but we have seen there are a lot of features on what is behind all these features. Actually you can implement a lot of different patterns. Here we have 4 different patterns that can be implemented with even Bridge. So now if the only documentation you have about your architecture or your applications, it's this diagram with the icons from AWS. We like them. They are really nice, but they don't give you so much information. They don't tell you how am I going to use it? Is it a message filter or is it a recipient list? It's completely different. And when you are going to port this application, well, it's really important to know that. If the only place you can have this information is inside the code, you quickly realize, well, for the portability of my application, it's going to be more complex. I will need to reverse engineer the code and then it's going to take time, so the switching cost is going to be important. So if as an architect you think only with our platform icons and really nice service selections, it's good, but it's not only that, you should think about design patterns. It communicates information that are going to be relevant on platform A and platform B, whatever the service you use to implement them. Now let's dig into a more complex pattern, a central pattern, so scatter gather. Not only you should have the nice icon, now we have the pattern, but actually on this pattern there are many architectural decisions that are being taken. So the first one is broadcast. How many, how many is it going to broadcast to? Is it a fixed set? Is it viable? And depending on this decision, well, actually it may be even bridge, it may be, it may be another service, so you should document that. Then, well, the recipient, so should they give back an answer? Should they provide a message? Maybe, maybe not. It's another decision which is really important in the way you design your service, and it doesn't determine which service on AWS you use. Same thing. So when you aggregate, do you need to wait to aggregate everything, so another decision. Same thing. So how do you output? How do you concatenate and give this response? Well, it's not something you see simply in the diagram, so it's not enough. You need on top of that to document to have some text around your diagram, and that means none the decision that you have taken, all these decisions. When you document that, you realize it doesn't, the service selection doesn't depend entirely on these decisions. So what is important here to think about is that service selection, well, it's only one part, but there are many other critical decisions that you need to document. You will need to provide so that to part the application, it becomes easier for the team. You don't need to go inside the code. You don't need to reverse engineer. You have this information and with these patterns and with the description of all the decisions on the patterns, you are going to reduce the switching cost. And that was the last pattern and the last good news, and we are going to summarize what we discovered. Yes, and so the key takeaways we want you to take home from this session is basically starting with reframing the problem, not talking about vendor lock in, talking about switching costs, and by doing this we are automatically breaking down the problems, adding more dimensions with it have a much more intelligent, um, discussion about um the actual switching costs. We also learned that options they provide value. Remember the graphic with the option pricing, right? Um, But they also have costs, right? Things like the, the upfront investments you need to do the um. The costs of the opportunity costs of not investing into actual business. Then we've shown you the patterns, right, so the provider service mapping which is typically far, far too high level and does not take into account the finances of these services which then provide you the actual value of uh. Specific service we've also seen that adding layer of layers over layers is most probably not going to heal this problem and also we have the physical characteristics of the specific services which we can simply not change or influence but they also good things, right? The things that work, um, I mean JFL has introduced the idea of using managed open source and I think this is a pretty good pattern. And this sits in this green quadrant from, from, from the beginning, having like a lot of utility for actually low switching costs. And then there's always, I mean, it's always good to have good and well established dev ops and agile practices, um, I mean they, they always help, so this is really like the no low and no regret move just do it, it always helps, um, and then also think in design patterns, not services. And this will especially help also sooner than later because um then if you need to rethink your system by keeping and remembering OK that was my original idea that was the actual intent this really helps to then also in later stages to modernize. The thinking so what we actually told you is maybe something you already knew, right? So what we told you is just do a good job as an architect, which means like use proper design patterns, use abstraction where appropriate and just stick to the well established. Um, good development practices like DevOps, agile, and designing lean products, and by saying this, thank you to you and yeah, if you want to talk about flexible data and AI architectures, happy to have this discussion later. If I talked about, so it's on the green area on the utility versus switching costs, so a very nice one, but still there are more dimensions, so ECS may be a good option if if ever you want to talk. About these options you have questions, you can come after the talk and we can discuss that. Don't forget to use the app and to feed your survey. We really appreciate your data about that and we can improve the sessions. Thank you very much. Thank you.