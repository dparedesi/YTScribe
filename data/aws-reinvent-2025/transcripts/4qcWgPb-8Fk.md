---
video_id: 4qcWgPb-8Fk
video_url: https://www.youtube.com/watch?v=4qcWgPb-8Fk
is_generated: False
is_translatable: True
---

Hello, everyone, thanks for making it today. We are going to be talking about. Specter and development with Kiiro. This is going to be a. We're going to be doing a code talk here today, so I have my laptop set up. We're gonna look at some code, but we're going to first go through some slides, and I'll explain what we're up to. First, let's have a little bit of an introduction. My name is Eric Canchet. I'm a senior developer advocate at AWS, and today I have with me Nikhil. Hey folks, I'm Nikhil. Uh, I lead the product team for Quiro. Uh, thank you all for coming here. This is after lunch. We're gonna have a fun session. Hope you, you won't need your coffee. Make it fun. Absolutely. So we're gonna start with a, a few things. We're gonna look at the history of Quiro. So Nikkel is going to jump directly into, to that in a moment. We're going to talk about a little bit of spectrum and development, the name of this talk and why I think everyone here should be using it with their agentic IDs today, and we're going to specifically look at Quiro and how that works with it. We're gonna touch on MCP. Uh, does anybody here use MCP servers right now? OK, I see a handful. Let me ask you, who's using Quiro right now? OK, only a few. So hopefully by the end of the, uh, end of this hour talk that I have convinced you all to try out Quiro and Spect Driven Development and, and, uh, just another follow up who's, uh, who's used Quiro so far? OK, a few more people. OK, good to know. Good to know. And then this is a code talk, so I see everyone has their laptops out, or most people. We are going to jump on, I'm gonna jump on this laptop here. We're gonna do a little bit of pair programming. So we're gonna try, uh, to create an app. Uh, we're gonna talk about it more in a moment, a job seeker's app. We're gonna use the spectrum and development flow inside Quiro, and we're gonna see how well it does. Uh, and then we're gonna talk about some of the features of how it works all together. And then I wanna give every, everyone here time to ask us questions at the end. So maybe, uh, 1015 minutes to, to, to for that. So those of, so I, from the, the hands that came up earlier, it sounds like a lot of you have not used much of Quiro. So let me let me explain it before we get too much farther. It's uh a new agentic IDE that we released in the last few months. It actually just went GA or general available a few weeks ago, and it's, we're really proud of it. It's, it's really based on this idea of spectrum development. Now you can do vibe coding. But we really feel like spec driven development is what it. Makes it sets it apart from some of its competitors that maybe some of you have heard of, uh, when we released it, it was a total surprise to us. It really went viral. It got hundreds of thousands of downloads. We had to put up a waitlist, uh, and then people found a way around the waitlist, so we had to put even bigger barriers up, but we've been really happy with the reception. We've gotten so much feedback on it, and we've been making it even more, uh, better. Uh, as, as it's been going on, as this time frame, um, in the last few months. So I'm gonna kick it off to Nikel to talk about the history of Kara. Cool. So, I'm going to spend a little bit of time talking about this, but I want to jump, I want to jump to the coding session fast. So, ah, the evolution of building software. Uh, let, let's actually take a step back and talk about the overall editor space, right? IDs got really popular because they provided a single tool chain where you could do things like have an integrated compiler, view lin linting issues, find, uh, debugs set breakpoints, and it, it offered a lot of benefits over, you know, traditional text, text edit like code interfaces, and so that, that was kind of the first wave that got wide adoption. And then in the last I'd say 2 years we've had really like AI editors become a big thing. First started with code completions, so like you'd be in a file, you type like a hash or you type um two slashes and you'd you'd be like do this and then we'll generate like a function for you. And then that quickly evolved to the more agentic or like you know I call it like the chat GPT like experience where you, you input natural language and the agent's able to edit multiple files. The fundamental shift that's happened, and we see this with all our customers who are who've been using Quiro and and Q Developer in the past was that uh unlike previously what the developer drives and provides. I think with AI editors, the developer steers the AI agent to author and review code. The developer is still very much in the in the in the driver's seat, but it's a different workflow where you can actually use AI to kind of accelerate your workflow, but you're still responsible for the code. That's the important bit. Vibe coding, this term got really popular in the last year, year and a half, where it's, it's essentially covers this workflow where it goes, developer writes a prompt, AI generates code, you write another prompt, and then you keep going in this loop and cycle. And this has worked really well for a lot of people to be able to prototype things that would otherwise take weeks to set up, but it's also got its challenges. Um, Slack threads, for example, I use Slack threads as a good analogy. So if you have a a Slack conversa we've all been in Slack conversations where like the message thread goes to like 100 messages and you know you leave that thread with like OK what did we take away? Uh, why, why are we making the decisions we're making and, and sometimes that's, that's just lost in that context and that's, that's one of the challenges you have with vibe coding. Is that it kind of completely skips the traditional SDLC life cycle, right? Historically, when we build features, we've always started with artifacts, right, we talk, we talk about requirements, we, we write design docs, we talk about trade-offs, and we meet and then, and then we start. Whether it's waterfall or agile, you're, you're doing, you're doing that both at different scales. So, what we did is we looked at, we really talked to a lot of our power users internally in the company and externally, and we saw that they'd already made this organic shift to planning before they actually went about creating or generating code. And planning upfront really helped the models focus and produce better output. So what we did is we built a a first party workflow in for planning called Spect driven development and normally this, this time I demo it, but we're gonna spend so much time talking about it that I'll just move, move ahead and get, get to that quickly. But really spec driven development, what it introduces it introduces a workflow for going from your initial requirements to to to an output. It's a really structured workflow where you start with the re you start with requirements. Once your requirements are done, there's a design, so you actually look at your design file and then you get to a task list and then you implement that task list. And you can go back and forth in this loop, um, Till you end up with a uh with an output you're happy with. And once your code is generated, a big another big problem in this space, the the term AI slop has become quite common now, is where the AI generates a lot of code, and there's you once you generate code there like there are no processes to actually. A lot of tools don't actually have processes to review things, so we have hooks built in, and what hooks allow you to do is we have a whole bunch of life cycle events in the IDE such as file save, file create, uh, and we're adding, adding a bunch more, uh, in the next few weeks that actually allow you to validate changes. So, an example of a hook that we use in our docs repo, uh, is, is a effectively like a C spell checker, but it also checks for tone and style, right? So, Our workflow when we're writing docs for new features is that we take our initial requirements doc, we feed that into Quiro, and it, it structures our docs, but then we have hooks that help actually say, hey, like it's almost like a separate thread to think about the work that was created that help, help us set up rules. Another good example is for if you're building UI components, you can have things like, you know, you have a react component, you want it to follow a single single responsibility principle, right, so it's a single focused, you can use a hook for that. And rather than me keep talking about this, why don't we actually just go ahead and build something together. And we're going to pair program though there's only one chair, so I'm going to peer over Eric while he's programming. Sounds good. All right, let's get this set up. Log in. 1 2nd. OK, so, uh, we wanna create an app with you guys today. So before we started, me and Nikhil came up with this stigma. So do you wanna explain a little bit about what it is? Yeah, so just FYI after this demo we're both quitting our jobs and this is gonna be our new business because we really like the idea, um, but the core of it is a job seeker's app, so, uh, problem. Here's the elevator pitch. So problem people looking for jobs outside of just prepping for interviews, there's a lot more than just goes into like, do you know the answer? It's like what's your, what's your style? What's your tone, and how do you actually prep? People use, use software tools out there, but like you can't actually talk to another person and there's no experience where you get feedback on how you, how you're doing in your interviews. So that's the core of the idea, and there's, you can imagine a lot, a lot, we can build a lot of things around it, around it. So, the way Eric and I started this is that we just hopped on a quick call and we whiteboarded a flow where we said, OK, a user logs in, Uh, they set up a profile, uh, and once they set up a profile, they can actually start interview prep, and a very simple MVP flow would be, OK, you start, start my interview prep, and you, you go in this question answer flow. So you, you're getting, you're asked a question, you can record your response, and that goes back and forth, and at the end we deliver, uh, an overview, a qualitative overview of how you did. With quantitative, ah, with a quantitative score. Excellent. So we have this picture that the figma that we created, and here is Cairo. Just for those of you who've never used it, let me give you a quick tour. I have a, a brand new Vet app that I just started this morning. Uh, that we can start off with. It's basically hello world. So we're just gonna keep it to the front end for now, but you can imagine some new DevOps and, and backend engineers, you can imagine we might have a back-end component to this too. Uh I just wanted to start with this also has tailwind CSS installed for our design graphics. Now, on the, on this site here we have this little ghost. I haven't really talked about this. This is our Quiro ghost. It's our mascot. If you have been around the Venetian, we have the Quiro House. Anybody seen the Quiro house? That looks like a haunted house. Yeah, I would recommend everyone to, to go through it. It's actually pretty fun. And then at the end of it, there's actually a code to get 1000 free credits, 500, 100 500 or 1000. Um, so check that out. You can go through, through it at any time. Uh, so this, this, this ghost here brings up a menu on our left-hand side, agent hooks, agent steering, specs, and MCP. So hooks, we kind of explained it already. It's a way you can. Essentially have things work in the background that are triggered on certain events. So imagine that you save a file, delete a file, you can have things happen. One a common scenario is you might update documentation on every file save, uh, or you might, uh, do some localization, and we actually even have pre-built ones you can kind of take out, take over, uh, without having to write anything yourself. And you can also have it specify certain file types. We're adding. As Nikhil said, more flexibility with this agent hooks in the future, but I just wanna give it a shout out. We, we've also seen very creative people from the community do this in all sorts of ways for their get work flows, for testing, all sorts of things. Uh, agent steering is more like a rules file that you can put in. Maybe you have certain coding standards, uh, or design standards that you wanna include. You can put it in steering files. I can also just have it automatically generate the steering files for me. And so what this does is it looks inside this folder inside my application, and then it creates a, a few files. You can see here it's already created the product and the tech file. And these are just based on what's in the app right now. So if you have an existing application and you wanna kind of play with Quiro today, uh, you can put this in there and have it generate the steering files, and then that'll get added to the context every time you start talking to the IDE. So you can, you can show what that looks like, what those files look like. Yes, that's a good idea. So here is what the product is. It's not that much because we really haven't added anything. Yeah, but it's a V3 web application with TypeScript and Veet. I use a script setup. I don't know if anybody's a VJS fan, but that's essentially how they're created, the components. TypeSafe. We have the structure, right now it's just kind of the hello world out of the box structure, but it's nice, it's in here. Uh, and then here's some tech. Which I just scroll down, but yeah, the frameworks, TypeScript, the, everything you would expect in there. And you can keep this, right now, this is just a moment in time snapshot of your current application. However, you can be creative with those hooks and maybe you have it continuously update those documents and uh those can be shared with your product teams or whoever else. And of course, uh, I heard, I saw some hands earlier, MCP, my, I'm, I'm a huge MCP fan. It's getting, there's, it's even getting even better. I've seen some, some stuff coming out recently. But this is where you would set, uh, your MCP servers. In this case, I have contact 7, I have. AWS loves MCP servers. If you don't know, we keep continuously adding more for different services and different products. It's kind of the catch-all one is the docs one. I'd recommend to try that one out, uh, but if you have a specific use case, you can install like the MCP server for Bedrock Agent Core is one of them. And it's just a few lines. We, in fact, just recently, uh, added a way to add MCPU servers with one click. So if you go to Arkiro.dev, I'll show that in a little bit. There's a little, there might be a little button there, you click on it, it'll just automatically install it. Inside your inside Quiro and then we are diligently going to many of your favorite open source MCP GitHub repositories and updating it to add the little one click install uh that is still working. I'm still working on that. And then of course, I have Brave Search, Bedrock Asian cop. So that, that's kind of a little bit of, of, of how, uh, of some of the features of Kiro. But I know the name of this talk is Spectrin Development, so let's, let's dive into that. So once again, I, on the right-hand side, I have two boxes here. I have Vibe, which I, I just love to vibe. It does a really good job at doing that, or Spe, uh, agents. Right now we support Cloud, Sonnet 45, 44 4.5, Opus, Haiku. So we kind of recommend just to start off with auto because we pick behind the scenes the best model that you should be using. I'll just leave it at auto. We're adding more and more all the time. It's definitely in the back of our heads of adding more models for those of you who are fans of other ones. Uh, sit tight. So, but let's try back, um, we actually had a uh before I Well, let, let's, let's go ahead and, and start it, and then I'll, I'll give you a little story I had the other day. So, uh, here is the diagram that me and Nikhil came up with. I'm just gonna make a snippet of it, a screenshot. And I'm just gonna paste it here, and let's give it a prompt. So I'm gonna choose back here and I'm gonna say, please use this picture and create a job seeker's app. Use the picture as a. Um, uh, as the design. I don't know, I, I always, I always like to be, uh, explicit and. I like to be polite to AI too, so you'll see me using please and thank yous. I would do that too. OK, so now it's going in and it's taking a look at those steering docks that we just created, and it's going to create this job interview preparation flow. And it's starting off with the requirements document, and I'm gonna have Nikkel really walk me through on what his ideas and how properly you could look through a, a requirements doc. Cool. Awesome. Let me, let me actually switch to the preview view of that requirements do. OK, sure, you don't mind, here, I'll do it. OK, go ahead. All right. So as you can see, uh, we took Kiro to we're, we're gonna switch, we're gonna do a little, yeah, we're gonna play a little musical chairs, so as you can see here, Kiro took the initial screenshot that we had and actually unpacked that into a format. And I just realized Eric has an opposite scroll for me, so it's like really, this throws me off when I'm trying to scroll. Ah, but it, it unpacked our initial prompt to a set of requirements, and the way we define requirements is we, we define them as a user story, and every user story has acceptance criteria. Now this is actually something we built, we were doing in-house in, in Amazon, in our, in our teams, the way we worked. So we took the same workflow that we had uh on our team and we made it available broadly. And the benefit of a user user story is like the human readable way that if we wanna say, hey, do we want, what's what feature do you want to support? So this one's about logging in so that I can access my application, profile management. Whereas the acceptance criteria are the actual details. So if you were, you were to sit and say, OK, let's go and build this profile management feature, what are the nitty-gritty details that I need to actually think about? So the the first task I typically do is when I'm when I'm building something with Hiro, is that I will look at the user stories and see if they're the user stories that I actually want to build. Um, and I'll start there before I get into the acceptance criteria. So if we start at, the first one's about logging in, The second one's about profile management. The 3rd one's about an interview prep session. And this is about viewing and responding to answers and like this is a very important. OK, this is about navigating through multiple questions. This is about the analysis and the result. This is about trend analysis. Requirement 7. Requirement 8 is about requirement 8 is my least favorite requirement because it's really nothing like what do you mean I have a clean and intuitive interface? Uh, so what I'm gonna do is actually like simplify this because I've, I was just thinking through this I think that demoing all here is not that important, so I'm just gonna say. Um, please remove requirements. One 2 Uh, we want 3, we want 4. We want 5. We want 6. I don't think we necessarily care about state persistence either right now. We just want to get something up and running, 7 and 8. As they are not needed for our MVP scope. Look, I use please as well. I never use please. I'm telling you, although some people do say it's just waste tokens, but I don't know. The, um, this is something I really think even if you're not gonna use Quiro after this talk, just being able to have your ID or having your. IDE AI IDE like go in uh and. Create these documents, but then also kind of going back and forth because one shotting this may not give you exactly what you expect at the end of the day. So it's always it's almost like a you kind of go back and forth I mean process. I think that the way I've seen, seen actually talk talking to some customers is that, you know, the initial whiteboard we did, right, some if like as a developer I might prefer to just, uh, vibe code that, right, like just because then it forces me to think about my interfaces and things like that that I'll need and then enter something more structured. So that is also a workflow that uh we, we, we support. Right, so I think hopefully these requirements look good. I think for the interview questions, we should just limit 4 interview questions, limit to 3. Yeah, so it should be just a quick, I imagine it, you go in, it asks you a question, and then you use your microphone, explain it, then it goes to the next question, and then it does it does an analysis at the end. All right, I, I think this is good. Um. Yeah. Ah, so now that the requirements are done, we can go ahead and move to the design phase. So what what's gonna happen now is that it's gonna take these requirements and generate a design doc based off your existing code base and Eric and I will play musical chairs again. And for those of you who are thinking, well, my PM does this, right? I don't have to write requirements, trust me, maybe you take what they give you to put in here, so you can then really create the feature or product that they're looking for. So yeah, now it's creating the design documents, kind of reading what we've done and the updates, the requirements to go to this next phase, the design. Uh, while it's working, I can also click here to kind of get an idea of, of the state of it. Uh, while it's working, one thing I was gonna say with the spec and the vibe code, I played a game on stream the other day. I get to, I get to have so much fun that we, we actually had another person on and we decided like which task would I use vibe coding versus versus spec mode, and it's actually harder than you would imagine to figure out which one is, is, which one you should use. Uh, I usually say if it's something that needs a little bit more forethought, it's a larger feature. Then spec mode is good. And I also, I love just having this documentation afterwards I can look at. For those of you pink, for those of you eagle-eyed on the screen right there, it says, can, by the way, can everybody see the screen? Do I need to make the font bigger in the back? Can you see it? OK, I see thumbs up. OK. So what it did now it's actually it created something called property tests. I wanna go. Why, why don't we start with the just, just the architecture, right? Like it just work down to see if it's the actual system we want and then I think let's get to properties. And yes, that's a good point. I'm so excited. I wanna jump into property testing, but we'll wait on that. So here is the design document that it created. It also gave me a nice summary of what it did, uh, and, and I can move on from there, and it's asking me, hey, does this look good? We can move to the next phase. But I can look here and kind of take a look at the high level architecture. We have view, uh, nice little Ay art here, but we do use mermaid diagrams if those of you are familiar with that, it works really great in markdown. So a start screen, question, results. OK, I'm assuming this looks good. I mean, just, it does look good. Local storage to, to share everything, web audio API that'll really help us when we record the audio from us when we're answering these questions. Uh, this is kind of how I, at, at Amazon, we are a, an AWS. We're a very document-driven culture. I've been in many design doc reviews, and we actually write our design documents very similar to this. We have interfaces that we outline. Uh, if you ever wanna see how, kind of how the sausage is made when you, um, wanna see how some of our services are designed, kind of take a look at these design documents. So I have question, response. The components start screen view, uh, so just under response, can you just scroll up for a second? What, uh, what is session state capture right now? Questions, responses, OK, got you. Yes. Oh, and then we have question screen.view. So I think these are all our components that it's going to create or score. Some prompts, question bank. It's gonna be just a hard coded file for now, so is this, is this the actual file or is it just gonna use generate its own questions? Looks like, uh, it's a static array in the application for the MVP. We'll use a predefined set of common interview questions. So I'm assuming this is just the structure, yeah, the structure of it. But it could be very similar to these or these. Here's our storage session. And then the last part we'll come back to, but that's the correctness properties. Uh, one thing I, I noticed out of here that's missing is it doesn't really have any information about how if we're recording audio from our laptops, how is it going to take that audio and transcribe it? So I wanna add that feature into it. Yeah, and I think there's one more thing missing too. So once you transcribe it, how is it actually like how are you gonna get the results? Was that was that captured? Yeah, that's a good point. So results, we have a session, we have a response, guessing we're gonna use AI for the result generation. Yeah, we have a results screen with a score number, but it's not really like this isn't really showing exactly what we want, right? We want a little bit more information. Sometimes I just do a quick search too, if I can't find it. Yeah, test complete results. All right, so what I assume we probably want to add in here is a way for AI to go in and, and do some analysis. So let's add these two things. We'll say, please transcribe the text as the user speaks it. Also Let's Add additional analysis. Additional, that's, that's the nice thing about, uh, this I don't have to typewrite additional analysis. That's actually my favorite feature about AI that I never have to like if I'm make a typo I never go back and fix it. Exactly with the results, uh, using, let's just, and we could use our favorite Amazon bedrock, but let's use Cloud, Cloud, um, SDK SDK. Uh, it's called AI SDK. All right, so now it's going to kind of understand what we want and make some updates to our design. And it's actually even going back to our requirements. And making some additional changes there. So it's smart enough to know like, hey, I know you're updating the design, but the requirements aren't quite what you mentioned. Now let's go and update the, the requirements as well. So now we have, uh, a microphone button that you can click on, and now it, it will transcribe it. And it will keep going from there. There's also, I didn't mention this at the beginning, but. We do have uh an idea of checkpointing. So if you're going through this process and you're like, oh my goodness, the, it's way off what I expected, you could just click this checkpoint button, or in this case the restore button, and it would restore back to its previous state. So this means that you can easily go back and forth instead of having to rely on your version control system and revert the changes and go back. Uh, so it also kind of makes little changes, it might find an error, it kind of goes back and forth and updates it. So now it's creating, it's updating the design document based on our suggestions. And we can see what it's doing. Yeah, so now here we have the transcribed text in our interface as we expect it would be there and some better analysis. It's also adding in. So what's the analysis analysis result? OK, got it. So that's the, that's what'll capture the. The, the results, there wasn't really a results interface before, was there? No. Perfect I love how happy the uh gente ideas are. Perfect. I've updated the design document. So we can now take another look at it. And we could say, OK, now we add the transcription service to the to the system diagram too. Let's see. So we have start screen question result recording component, local storage web audio idea oh says speech to text. I added the cloudia I too perfect. Perfect. Honestly, when, when, when the system diagram looks good, I'm like, yeah, looks good to me. Let's move forward OGTM. All right, let's move to the next part. So now we have, we have taken this idea that we had, we, we updated the requirements, went into the design, and now we are going to the last phase, which is the task. Well, I guess it's more like the second to last, because once we have a list of tasks, we need to implement those tasks, and there's ways we can do that as well. And this workflow is, um, there's a actually a lot of feedback we've gotten on this workflow on improvements we can make, but in general it's pretty flexible because it's all built in markdown. So you see there's like this refine button on the top, so what we also have a flow is if you go and like make a manual edit, you can refine that, clicking refine will basically take that edit and and and kind of introduce. Integrated into the rest of the design doc. So if you do that in the requirements, it'll generate like the user story and acceptance criteria in year format, which we'll talk about, um, and you can the same thing on the design and actually even same thing on task list. So like let's say you've done 3 or 4 tasks and you're like, hey, I actually wanna change something because. Often this is in real life, right, we implement 44 tasks and we're like, hey, actually like now I wanna change something because it didn't, this is not what I wanted to do. You can go and make changes out of band and, and clicking the update tasks will refresh, uh, the, will refresh, so Kira will look at your code base and actually see what's done and, and update the, the upcoming tasks as well. So now it's at a part where, yeah, we have this task list of all these tasks, uh, and we also have an option to keep the optional tasks or make them all required. And here are these property-based testing. Uh, which are all optional right now. Let's, what, what do you think, Nikhil? Should we just keep optional tasks for faster? Yeah, let, let's just keep our optional tasks. This was actually a flow a lot of people asked us when we, we didn't have this flow when we first launched, but, um, what was happening was that for every feature you had a lot of unit tests, and people sometimes wanted to see the, see the end product before they get. To the tests, but they wanted the tests, so we introduced this flow to keep tasks in this, ah, keep tasks spelled out, but set to optional by default. OK, so should we take a look at the task list? So we can do the same thing here. We can refine this task list as well now. So, ah, is it, can we see like, uh, I keep scrolling down, so you've got to create the data models, implement audio recording service. Implement response validation storage, the AI integration. One thing you may be thinking about, hey, I have this list of tasks, but I wanna get to something like right away that I could test. So another idea too is we could refine this list and reorder it. Yeah, let's, let's ask. I, I, I think so. I think let's, let's ask hero to. Like I, I'd say prioritize getting. And, and we, how, how should we frame this? Prioritize getting an MVP scope together by task 5. Right, so we have something to see. There's a product, there's like a product analogy here where like when you, when you're building a car, you first start with a skateboard and move to a bike and then build a car, or you can choose to build the wheels, you can build the engine, and then stitch together, stitch together everything at the end. The better way to build a product is, is you, you, you build interim steps. So you always have something that's workable. Right. Yeah, so this is very flexible. We can kind of move these tasks around. I kinda like that idea of getting to the 1st 5 tasks that has an MVP we can show you, especially in this time, short time we have together today. Uh, so that, I think that that would work well. I also sometimes just have it condense tasks down. Like if I see it has like 25 tasks, I'll be like, Whoa, why do we have 25 tasks? Can you just, can you make it into like 10 tasks? And then it'll kind of group some more together. Or some people who does test first development, who, who writes their tests first? No, OK. All right. A couple of people over here. Uh, no one likes tests, so maybe that's the workflow that you like. Then you can set this up, write all the tests first. Let's do test first driven development. All right, so we have now, we have, I think, for the, for this, uh, a core MVP with 12345 tasks, even has task 2 or phase 2. So let's see, is there UI state captured in the 1st 5? Set up dependencies, create core data types, implement application state management, implement audio recording, speech tests, implement response validation storage. Create start screen component. Oh, so it looks like the first phase may not even have the UI. Should we, should we ask it to have some UI? Yeah, that's. Uh, UI to the initial phase. So we can actually visually test it. So we can visually play with it, yeah, it. Good call out. That's, we did a run through of this. Like, it's, it's interesting because we did, we've done like now 3 run throughs of this, and every time it's a little different, you know, like every time, like last time we did it, it, it, it was, it got, it got this in the first run, so it's, it's, it's super interesting. Yes, that's why you always read it. You, I mean, we have to all, when we're using coding agents and, and genetic IDs, you have to read it and pay attention to what it's doing, because otherwise it will do things that we don't expect. All right, so it looks like it, it reordered it again. Now it's, it's task 1 through 10 now, um, until it gets into phase 2. I think for the sake of time, cause we only have about 20 minutes together, let's, let's see if we can start implementing some of these tasks. And I do have an after. So if it doesn't get through all of them, we'll still show you what it comes up with afterwards. How's that sound? Yeah, sounds good to me. So we'll start task here, and you can see, we can do the starter task a couple of different ways. We can just click in the UI or we can talk to it in the chat. So I'm gonna start task, start task. I'm scared, how about we do 5? Yeah, and we'll do 6 because that has the start screen component. And right now what it's doing, it's, it, uh, it's gonna go into the terminal, it's gonna run some commands. Now, typically, you can see here we have a whole task list. Uh, there's task, they're queued. So it's gonna do task one, and then it's gonna do the rest of the task afterwards. These actually need to be done in order. Uh, that's why it, it does it this way. You can also just take a look at it. It's now starting to do it. It, this one was pretty easy, just had to like make a few files and install a few NPM dependencies. And then I can kind of look at the next one and see it's starting task 2, and it's going through it pretty quick. This, this will probably take a little bit of time. So while this is happening, why don't we, ah, pivot to talk about property, property testing. Great. Um, maybe switch to the design view. Yes. Cool. So I'll just give a little bit of an overview. So, there's a reason why we went with, in the requirements, we went with this user story acceptance criteria format, and the acceptance criteria are structured in what's called years, which is easy approach to requirements syntax. I believe that's, that's it. Uh, but what, what, what that means is that when you define something it says when you do this, the system shall do Y, and that allows us to create, uh, essentially logical equivalence and do things like formal reasoning on the actual requirements. So that's really what a property is, uh, you know, there's a definition of property here, it's a characteristic or behavior that should hold true across all executions of a system. So what we do is we take the year's format requirements, extract properties, and then from those properties we actually, there's a framework called Fast check that allows you to actually test those properties and unlike unit testing that has like limited inputs, uh, you know, the inputs that you provide to the system to test the output with, uh, property testing you it actually fuzzes a whole bunch of values across a range, so it generates more evidence that you've when you have a requirement. The generated output maps to the requirement, right? So that we're thinking about this whole world of specs in a very first principles approach, right? Like how do you, how do you solve the problem in the AI world where you, where the generated code actually matches the user's intent. And property-based tests are like the first way we're going about it, but we're, there's a lot more we have planned. Yeah, it's pretty powerful, everything you can do with it. I'll, I'll show you an example. I did this, uh, I'm a, I'm a chess fan. I created a, I vibe coded or spec coded, I guess you could say, a, a chess app. Uh, and I was, for me and my son, and we're like, we wanted to make sure that it worked as it expected. So here is a list of property-based tests for this other application that we created, and you can even see if you hover over it, it tells you what the test was for. This really does test those requirements. Uh, Fast check is, by the way, if you're using Python or a different language, there are other libraries that, that do, does this property-based testing. Uh, so I can even take a look at it. Uh, it says all property-based tests passed. For any board to stay in the AI generate move, the move must be valid against the movement registry. And so here's the test. And you can see that uh for those of you who are. Looking at imports from MPM, it's this FC from Fast Check. And we write here, we write our test. We do an a cert on it. We have create board state, and then one thing that I find really interesting is this numb runs at the end. So it's gonna, it's basically doing fuzzy testing. It's making changes, random changes to the test file, and it'll actually run over 100 times to make sure it is as you expected. And I will say adding these property-based testing makes the output of your code. At a much higher quality and oftentimes less bugs. And I, you can see here, it just goes through a bunch of different tests to check to see if the move is valid. Where are we in our demo? So we have step task 5. Looks like it's on task 6 now, which will take a moment. So as the tasks get done, it also marks it off in the implementation plan, so. Yes, so here's our job seekers' app we've been creating. You can see we have nice little check marks next to everything. And it's diligently working on task 6, which is what happened right now is one of my favorite features we launched recently, like the diagnostics tool. So because we own the overall ID interface, when there are problems, like, so if you go to the problems tab and in your, um, editor typically reports like your, your linting issues and the agent is able to read it, so. We used to have a lot of problems with specs. Like you'd have 5 tasks generated and then you open problems tab, you'd see like, there's like 6 or 7 issues to fix. But like ever since we've had this added this diagnostics tool, it's been really great. So it completed step 6. I'm not sure if this, it wanted me to go to 10. We could keep it going. Let me see, I'm just doing an MPM run dev cause I wanna give everyone here time to ask us questions. And to show our quick optimized demo at the end. So if I open up 5173, it looks like it didn't finish it. Still has a whole world. I think it probably didn't link the component. The start. Why don't you just go ahead and, uh, do, do the other ones, and you can, while it's happening, you can switch to the finished app so people have time to ask questions. Yes, OK, we're gonna queue all these, uh, you could see here though. Last time we did this in 5 tasks it was done so you see it's starting to create the components that that we want. Um, some use states, these are like hooks and react. OK, let's take a look at our final app. I'm gonna run Dev on this. You see here, same principles as the app I'm showing you. We have our spec design requirement task. And so this is what it looks like. Uh, it's an interview prep practice. So we have behavioral questions, technical questions, and leadership questions. It's connected to, uh, a cloud sonnet 3.7 model, I believe. So which one do you wanna try? Um, just pick, pick, pick one. Let's do, let's do, uh, technical. Sure, I'm gonna allow this time. So explain a complex technical concept from your field to someone. Hello. Uh, let me explain about websites. There's a server and there's, uh, a client, and our website has to interact. It can run locally, we can have single-page applications, we can have service-site rendered apps. I could keep going as you can see, we've gotten pretty low scores in our every time we played this. Probably not gonna pass the interview with that, but for the sake of this demo, we'll keep going. It's actually, uh, one thing, it keeps the last answer from the last one we ran in here. It's just something we didn't change yet. Describe a challenging technical problem you saw recently. What was your approach? What was the outcome? I, I'd say this app, right, we learned about web, the web APIs. We learned to create a spec driven development to create this application I'm using right now. I learned about a little bit about Vet and React and property-based testing, and I got to do a demo in front of 100 people. OK. How do you stay current with new technologies, industry trends? We should ask the audience this, I'm sure they have lots of interesting answers. I, I attend reinvent amazing events, amazing talks. Uh, I also go and look at. Builder center that AWS uses to tell people about our latest tech. Uh, I go to conferences, I look at stack overflow. I, I go online to YouTube and watch a bunch of technical creators. Maybe I'll get a little higher score for that. So then I click click finish, get score, and now it's taking all this. It has a very simple system prompt, uh, that just does an analysis on it. And it should go and grab the information. It sometimes takes. 30 to 60 seconds. Nice. You got 4 out of 10 this time. And of course the candidates demonstrate some relevant technical knowledge, engagement industry, but the response lacks structure, clarity, and depth, um, so great interview prep that we could use. And literally just took us not so long to put it together. And looks like it did actually complete this as well. It'd be nice to see something a little more than Hello World. All right, well, let's give some time. Um, let me switch back to, do we want, do you guys wanna see what it, it came up with after step 10 that we're not faking this? I do. OK, let's see here. OK, this is what it, this is what I came up with. Start interview prep. Look, tell me about yourself and your background. Now this time, test, test, test, hello, hello, hello. OK. So it's duplicating it, maybe we could go back and have it do something else. Greatest strengths, this is my greatest strengths, test, test, test. OK, you get the idea. One thing I didn't do is I didn't put my anthropic claud key in here, so it's definitely gonna fail at the last step. Oh you, oh yeah, you forgot about that. Uh, test, test, test, and I think. Right here, I maybe it's not even using that's amazing. That's all you need to do, guys. All right. Uh, cool. Well, I mean, I think we're, we have 12 minutes left. I, I think we, we got through the, the core workflow that we wanted to talk about. I think just one thing to keep in mind in specs like we launched this and like there's a lot of positive momentum and adoption around specs, but this is just a start, as I said, we're, we're solving like first principle problems on the requirement side. How do you know, often what we do is like we do things like scenario planning, right? Like. Or scenario planning is the wrong word, but like when we actually build something like, hey, when, when you do, when the user does X and Y, what's the expected behavior, right? That doesn't really translate well into like the structured kind of doc we have here, but there's clarity on requirements as a concept. How, how do you know your task list matches, um, uh, your task output matches your intent is another area we're just continuously gonna invest in. And I'm actually super excited about this journey with specs we're on and very excited to come back next year and talk about all the cool things we do with Specs over the over the year. Me too. And also just looking at it, it never implemented the cloud AI integration that was the MVP didn't have that integration, but you got a 9 on 7 on 10, so you know it's better off. I know. They have. A guripo, um, yeah, we'll put it up, sure, um, I don't have one right now, but we, we can certainly do that. You can use the one click get integration on Kiro. Oh really? Yeah, that's, we'll have to try that. Yeah you just you click here. And you add them to your source changes? Oh, you're, you're back on. Oh, you're no longer on the demo. Never mind. I was gonna demo another feature cool, um. Thank you. Yeah, thank you. Any other questions?