---
video_id: z1qnPTUZZ9M
video_url: https://www.youtube.com/watch?v=z1qnPTUZZ9M
is_generated: False
is_translatable: True
summary: "Siva GuroRadiar and Alex Nazaroff from AWS present a deep dive into the new features of AWS Application Signals, focusing on the recently launched Application Map and mobile Real User Monitoring (RUM). The session is a ""code talk,"" with a strong emphasis on live demos and code examples. Application Signals is AWS's native Application Performance Monitoring (APM) solution. It provides an inventory of services, monitors their health based on ""golden metrics"" (requests, errors, and duration), and tracks dependencies automatically using distributed tracing. The underlying technology is OpenTelemetry, an open standard. The service also supports Service Level Objectives (SLOs), transaction search, and synthetic canaries. The new Application Map feature provides a high-level, interactive visualization of all applications and services across multiple accounts. It uses dynamic grouping to discover resources like API Gateways, load balancers, and container clusters, and presents them as a ""tip of the iceberg"" for the underlying applications. A key enhancement is the ability to discover and display uninstrumented services, providing a minimalistic APM experience for all resources. The map uses color-coded donut charts to indicate the health of each service, making it easy to identify bottlenecks and areas that need attention. Users can create custom groupings based on AWS tags or OpenTelemetry resource attributes, allowing for a more tailored view of their environment. The session also introduces the newly launched mobile Real User Monitoring (RUM) for Android and iOS. This extends the existing web RUM capabilities to mobile applications, providing a comprehensive dashboard for performance metrics and crash analytics. The data is sent to CloudWatch RUM in real-time, allowing for immediate visibility into user experience. The service provides platform-specific information, such as Application Not Responding (ANR) details for Android and crash analytics for iOS, as well as device and OS version information. A crucial aspect of this new functionality is the correlation between mobile RUM and backend services. Using a correlation ID that is tracked across multiple hops, developers can trace a transaction from the mobile application all the way to the backend service. This end-to-end tracing is visualized in the Application Map, providing a unified view of the entire system. Alex Nazaroff then provides a live demo of these features. He shows how to enable Application Signals for a set of Lambda functions, which adds an OpenTelemetry layer and provides deeper insights into the application's topology and dependencies. He also demonstrates the ""operational audit"" feature, which proactively identifies issues and provides root cause analysis. He then uses Kiro, an AI-powered IDE, to query the application's health and troubleshoot issues directly from his development environment. The demo also showcases how to troubleshoot a mobile application crash using RUM. By clicking on a data point in the crash analytics graph, he is able to drill down to a specific user session, view the stack trace, and identify the exact line of code causing the issue in Android Studio. In conclusion, the session highlights how AWS Application Signals, with its new Application Map and mobile RUM capabilities, provides a comprehensive and interactive observability solution. By connecting front-end user experience with back-end service performance, it empowers developers and SREs to quickly identify and resolve issues, ultimately improving the reliability and performance of their applications."
keywords: AWS Application Signals, APM, observability, real user monitoring (RUM), application map, distributed tracing
---

Hello everybody. Thank you for coming in. Good afternoon. Uh, my name is Siva GuroRadiar. I'm a senior specialist architect here at AWS. So welcome to this session on comprehensive observatory with mobile real user monitoring and application map. So with me, I have Alex. Uh, who is a principal engineer at AWS and we would like to talk about this as a code talk, right? We wanted to have it, uh, dive into the code, and then talk about the various features and all those things, right? But before getting into the beats, uh, how many of you here, like, you know, just show me your hands if you are using application signals in your product or in your company? Maybe that's a bad bad marketing on our side. How many of you have heard about application signals? Good. Yeah. So application signals is our own way of doing APM, right? Application performance monitoring. And uh I would like to, to level set, uh, the field like, you know, we will be taking a very short, maybe theoretical concept on what is it all about then we'll dive into the coding things, right? So this is what our agenda is going to be. We'll talk about the overview on a very high level, then we'll talk about the latest and greatest features including application map, uh, the mobile real user monitoring, which we just launched a couple of weeks back, and finally, like, you know, we'll get into the code things. So application signals, as I said, it is on a high level. You can think of it as our own version of application performance monitoring. So we have inventory of services that you're running in your application or like in a, in your account and all those, right? And you wanted to both understand, like, you know, monitor it and observe it, and when things are failing, you want to fix it ASAP. So that's what it is all about. So we will be showing like, you know, irrespective of whether you're instrumenting it or not instrumenting it, we'll be showing you all the services that are available in your account from the councille. We'll be showing a demo. And also, like, you know, it's all based on golden metrics. In the APM world, the golden metrics is all about red metrics we call it, wherein R stands for request, E stands for errors and false, and D stands for duration or latency. So everywhere, like, you know, in application signals console, whatever you'll be seeing, it's based on golden metrics or the red metrics, and dependency tracking. But the beauty here is like, you know, you're not sending us any kind of metadata that says like, you know, OK, hey, my service A is calling Service B. We will be getting all the tracing information based on the distributed tracing, and then we'll figure out what is your dependency. It's all based on open standards. We all using open telemetry as the underlying mechanism. And using that, like, you know, we will be showing you all the details. So with that one, like, you know, as a next level, you want to connect your, maybe your technical things with your business metrics. So that's where you can create your SLOs, service level objectives, from your services. And also, like in the topology map, we'll be showing you how these services are interrelated with each other, as and when your services are sending metrics to us. So with this one, like, you know, like we discussed, it is based on uh distributed tracing. And last year we introduced the concept of transaction search. So what we are doing is We are taking your traces and then storing as locks. So in that case, like, you know, any kind of transactions that are available in your business applications, you can go ahead and then search for it. The typical way you will be doing with cloud watch locks, right? So we can do that. And last but not least, like, you know, we have support for real user monitoring as well as canneries. So real user monitoring, predominantly we have been supporting web for a pretty long time. And recently, like, you know, we added support for mobile applications, both iOS and Android, and as well as like you know synthetic canneries, if you wanted to run any synthetic testing on your APIs, on your endpoints, that is also supported. So let's talk about the newer feature called application map. So, it has come like in a lot of stages. So we started with Trace map, and Service map. Currently, it is in the stages of application map. So application map, it is, so like you're seeing in the uh upper like you know uh right hand side picture. So that's all like I will be seeing it. We will be uh showing you a demo on this. So here is where like, you know, you'll be seeing a lot of tiles. So these tiles are representing your applications and then we are grouping together by related services. So that is our default grouping. But you can go ahead and then create your own custom grouping. Either like, you know, there is a front-end grouping and then there is a backend grouping, or if you're running like you know multiple BUs, for example, like I might be running a a GFS application, right, a financial application. So that could be like, you know, my BU could be a loan BU could be one tile, and then my lending could be another BU tile, right? So that way you can go ahead and then segregate your applications the way you wanted it, the way you wanted to observe it, right? But the thing is, if you can click into that one, so that's all like you know it is going to be elaborating. So each and every service with its dependencies, so that's the lower part of the picture is showing, you can do all these things from one place. Again, each and every tile, you can click on it like a reccursion basis. You can keep doing like, you know, the drilling down till the way you wanted it. So how you do, uh, navigate the map? So as I said, like, you know, we can group by the way you wanted it. By default, the grouping is the related services, how you are sending the metrics, but as I said, like, you know, you can go ahead and then group it and then you can zoom it and zoom out and all those things because it's a map. So wherever you need the attention, you can zoom in and then zoom out and then do all those things. And also, like, you know, if you see in the right-hand drawer, there is something called like, you know, there is a lot of details around it, starting with your health metrics of your services. So in this case, like, you know, I do have a pet clinic printed, which is showing like, you know, how healthy my services, how many falls I'm getting it, uh, and then if I created any SLOs, how they are healthy or unhealthy, those kind of information. In addition to that, as I mentioned, you will be seeing your all your red metrics, the number of requests you are getting it, your errors, faults, then latency, all that information is available. And one additional thing is the support that we recently added is there is something called operational audit. So operational audit is something like we are proactively saying to you that hey, this X service is having some latency issues. Can you take a look into it? So it is not like, you know, the reactive days are gone, right? Like, you know, now people wanted to do more of proactive stuff. So in this case, like, you know, it will tell you, so not only tell you like, you know, there is something happening. But if you wanted to take a deep dive, you just click on that 1.1 of the traces that it will be showing you, and then it will tell you exactly like how it is coming to the conclusion that it needs some attention. So let's switch gears and then talk about real user monitoring. So real user monitoring, as I said, like, you know, if you wanted to record all your user interactions from browsers, uh, like, you know, your end user might be using their browsers to get, like, you know, some insights from their browsers, you might be using real user monitoring. And we have been supporting like, you know, this web web for a pretty long time. And we recently added uh the support for both Android and iOS and with this one, like, you know, you can get a lot of information around it. Like, for example, again, how healthy is your application or like both mobile as well as web and then in terms of web, you will be having a lot of details around how, how many JavaScript errors I'm getting or like, you know, is there any JavaScript errors or in the mobile world, like, you know, it could be like in the number of crashes, those kind of stuff, right? So you'll be getting like numerous information from this particular charts. And also, like, you know, when we are extending to mobile. So these are all some of the charts you are getting it, right? First one is like comprehensive dashboard. So that's where, like, you know, you will be seeing both your performance metrics, and then your crash analytics on all those information. And all these things are coming in real time. So when a customer is getting a crash from their mobile application, it will be recorded in application signals or real user monitoring. So that like, you know, there is no, not much leniency there, right? So the moment they are getting it, you are getting it in real time. And also, like, you know, when we are talking to many of the mobile app people, they wanted to see, like, you know, the important things around how much time my app is taking to load, or like, you know, the application performance index, those kind of things. Again, the mobile world is splitted. Like, you know, there is an iOS, there is Android, and then here, like, you know, in Android world, we call it as ANR or application not responding. But in the iOS world, we call it as crash analytics, right? So depending on the uh kind of mobile application we are talking about, we provide you both information in the same language that the mobile developers are using, right? So, if you are using iOS, we'll show you all the crash analytics. And if you're using Android, we'll be showing all the ANR details. So with this one, like, you know, you are also getting, like, you know, the various information like uh which iOSs they are running or which version of Android they are running, what type of devices are they're using. So all those kind of information we are capturing it, and then those information are available to you. So, we talked about, like, you know, two different things, right? One is your services which are running in the back end, and then the other word is the real user monitoring, which could be like, you know, web or mobile, right? How they are interconnected with each other. So for that, like, you know, we are using correlation IDs. The moment, like, you know, your customer is doing some operation, we will create a correlation ID and then that correlation ID is being tracked over multiple hops. So this is based on open telemetry, open standards. And again, like, you know, the end to end transaction tracing is available for you. So, once uh there is an error that is happening, you can easily track it all the way from your mobile application to your back in service. And also with this uh newer application map feature, you'll be having automatic topology discovery, as well as visualization, so that from one place, you will be able to see how things are interconnected with each other. And also it is showing you the service dependency as well. So you might be wondering like, you know, how my A is calling B and all those information that is also uh available for you. And also the performance metrics overlay at each tier. I don't know whether you, uh, noticed it. Every tile will be having a donut chart. So the donut chart is color coded. So every chart, when you're having like, you know, some issues, it will be showing in red. So that needs, like, you know, it needs some attention, right? So on a high level, if it is like, you know, a 1000 ft overview of your application, you can easily see like, you know, which tile is showing you red or green, those kinds of information, so that it's easy for you to figure out what's going on. So it's easy for this bottleneck identification and mutual indicators using that one, right? So with that one, like, you know, this is how the architecture is from your mobile applications, uh, you are sending, whether it is iOS or Android, you are sending your telemetry to CloudWatch real user monitoring. From cloudWatch real user monitoring, we will do the job of taking those metrics and then sending it to application signals. And in the bottom side, like, you know, you have your backend services. So with these back-end services, you are sending your telemetry as well. Again, everywhere it is the open telemetry, open standards. And if you are a user, so in this case, like, you know, assume we are seeing from the right hand side, we are seeing from the right hand side with this application signals and application map. So using that, not only you're going to monitor your applications and uh if something is breaking, we are gonna see like, you know, how you're going to fix it. So that's what all about the code we will be showing you from uh Alex. So with that one, like, you know, let's go with the code. Hi, everyone. Uh, as software engineers and, uh, system architects, um, how many times have you looked at the Architecture diagram. Something like this and thought to yourself, well, this is like some really Ugly spaghetti monster right there. And how many of you actually build a system like that? I did. My name is Alex Nazaroff. I'm a principal engineer in CloudWatch. Many projects start with simple, beautiful architecture. But then the business grows, you add features, you add, um, redundancy, you add security, you add search index, you add analytics, list this list goes on and on, and so you get the idea, eventually the system becomes so difficult to comprehend. Even people who build that system 6 months down the road will have a hard time understanding what's happening under the hood. You see, the Problem is not that distributed systems are over-engineered. The reality is that, um, real user scenarios, real-life scenarios requires building complex systems. And this system stretching human abilities to understand and keep track of what's going on in the system. So when we approach this challenge, we talk to our customers. And they said, you know what, I, instead of this, uh, I want to have a way to look at. All that I have in all my accounts on one page. Kind of like this. So, show me on the high level what I have and also help me to understand the status, like health status of each application. But when I'm interested, I wanna dive deep like. Go inside, uh. And see its guts, see what's happening under the hood. But then I should be able to go back, zoom out, and look it up, uh, on the high level. So we use this as a guidance when we uh worked on this new application map. Um What we introduced here is dynamic grouping. So what application signals in this map is trying to do. At its best effort is to discover resources like API gateways, load balancers, EKS, ACS clusters, EC2 other scaling groups. And use them as a backbone that or like a tip of the iceberg. That to present a structure that forms applications that you're hosting on, on AWS. Previously, application signals only worked with instrumental sources. You would have to instrument your code. But we uh just recently added uh functionality that. Like I highlighted on this map with the dotted lines. These are the applications that we believe um just entry points into something much bigger, it's not instrumental, but you still have all the benefits that like minimalistic APM functionality for, for these services. So for example. I have this ticketing light service that essentially allows customers to submit tickets. When I explore details for this uh application, I see first of all there are like It discovered 4 services under the hood. It tells me, you know, it is breaching some SLOs. These are the most recent deployments for this application. Uh this is taken from Cloud trail. And the golden signal metrics like availability, some latency, server faults, user errors. Um, I can go dive inside of it. And again, everything is a dotted line here. It means it's not instrumental, but it's pretty straightforward. I have an API gateway. And it has 3 lambda functions that implement some of the APIs uh backed up by this uh. Um, list tickets, read tickets, submit tickets. Pretty straightforward. And Even from this map, I already can see that, OK, I have an issue that my customer is facing because it's an API gateway. And then it's actually going into the submit ticket, so submit ticket has issues. From this, you know, overall description I can only see, well, it got deployed recently. The deployments are marked as vertical lines on the graphs, but I don't see any correlation with deployments. So at this point, the best idea for me would be to instrument this application. I can go and instrument each individual lambda separately or on the high level, I can just use, you know, this context menu to enable application signals for all of the components inside of this application. So here I can just like click, click enable on all the lambs. What's gonna happen is that this enablement will add uh open telemetry layer to this lambda functions. It will not add the agent, but only the SDK, the client side, that will talk to uh OTLP endpoint. So the benefit of that is that you actually not wasting resources on the agent and the. It does not increase the The agent does not increase the lambda gold star. So, I already, so the enablement takes roughly 5 minutes, so I already have a carbon copy of that ticketing service over here that is already instrumental. So now when I look at instrumental version of that application, I see. More details, right? So now I can see that, OK, this is that. Uh, problematic in the ticket lambda. But it also brought in another lambda and this SQSQ. So this is how they communicate the synchronousy with, with each other, also showing me the uh tickets dynamo DB table that these lambdas are using. So I got much better picture about what is actually happening right now with my system. And after instrumentation. What is also available to me is this operational audit. On the high level, operational audit just goes, finds what you would do, uh, manually, just find traces, finder. Exceptions and it just surfaces it up, so you can actually not diving into the logs or doing any complicated research, you see exactly, OK, this lambda called SQS and this is the exception message that says, well, you're trying to submit. Uh, too big of a message to the queue and it doesn't accept it. This is how we got that exception. Um, Now what's I want to also show is that this audit. Is available from. Your dev environment like ID. So in this case I'm showing Kiro, but VS code with client would do exactly the same thing. I have here preinstalled cloudWatch application signals MCP server. And the way to get it is actually it's available on AWS labs under MCP folder. And there is a cloudWatch application Signals MCP server. So what I can do now, this ID talks to the telemetry. Um, that captures the state of my production. I can ask questions like, which services are breaching SLO? And uh right now it actually went. Scan that map, list of services, figured out which ones are bridging SLO and reporting this to me. And I can also. With the individual services, like I can say, well, what's wrong with that submit ticket, right? So, submit ticket, um. It's gonna execute public API available that you can also use that runs the operational audit. And From this operational audit, it makes the same conclusion that we just saw that message. Uh, on the screen it's saying you trying to submit mess messages bigger than the queue can accept. And the benefit of this is that. You can essentially do your root cause analysis, troubleshooting from IDE and instantly connect your code with uh what's happening with your services in, in production. And the ID already knows like because you loaded that code base in ID it connects that stack trace that it found in telemetry and it says which line of code is causing this problem. It suggests uh remediation or fixes how you can uh. Actually mitigate that problem. OK So now, let's go back. And talk about. How to Uh, customize this map. So So right now, um. What you're saying here is. Best effort to group all services. Um, what we call like related services. Essentially, many applications have an entry point like a load balancer or some front-end service, API gateway. And this is what we're. Ah, discovering and showing, yeah, like you have. You know, uh, this, for example, appointment service. It has like this uh microsurfaces. This is how they relate to each other. Um, there are some components that are not connected with anything. They have their own like standalone version. Um, but we also allow. You to customize this map. And so, By default, you could see also all the services grouped by environment. So by environment, you can use hotel attributes and say deployment, um. Environment. name. And That way you can differentiate your production versus task, performance, etc. So that way, you can regroup all your services by environment. But in addition, we have this way of custom grouping. So, it's a little bit involving, so bear with me for a moment. Um, so Let's say I would like to have different groupings of all the resources and all the services I I have across multiple accounts. So I would create these groupings over here. Like, I want to actually control myself, what composes my application. So I, I have created a grouping by application. Another part that's important to me is cheating, like tier 1, tier 2 service, like how it's important to my business. And then, uh, team ownership. I can You know, assign um services to the teams who operate on them. So this is on the left side. On the right side. What I'm specifying here is. AWS tags, these are the tag names. So if I have a name, uh, tag named. Application or APP.net or my app on API gateway. The value that this tag is carrying will be the name of that application. The same with the tier and the team. So these are just AWS tags that I'm saying should be used to create grouping. In addition to AWS tax. We also support hotel resource attributes. I brought them here. Uh, so, hotel resource attributes is when you instrument your code, you have a chance to define additional key value pairs. Um, for these services that get instrumented with hotel telemetry. So and this is what you would, uh, you could use, uh, alternatively to the tags, you could use just hotel resource attribute and pretty much do the same thing, specify that this microservice, you belongs to, let's say, pet clinic application. So after that is configured. Um, or, you know, give it some time. And when telemetry gets ingested into cloudwatch. The application map will form these custom groupings. So, for example, this is the grouping by application, because I have annotated by telemetry or annotated resources with ALS tags with these values of telemetry. What, but and this is an example of, let's say. Tears. And this is how I can work. I actually can chain this grouping by. I could start with tiering. Like, let's say the most important to me, I wanna work on tier one services. I see them all in red, but I'm interested in tier one first, right? So I go inside and it's quite complicated. So I can group on for the second level, say, well, now I just wanna see them by application. Well there's actually 3 different applications in tier one. Payment, pet clinic, ticketing system. Then I can go essentially inside of them and um. Inspect the Let's say this application, PET clinic. Right? Or I can go back completely back up. And regroup by applications and see what's available in this account. So let's uh actually dive into pet clinic. And um. By the way, if you have any questions, please, um, ask it, like, you know, let's make it as interactive. Uh, if you have any questions, please feel free to ask any questions. Sorry, Alex. So, what we try to achieve here is. For, that's what, you know, customer sentiment was. I want to use the map to guide me to when I'm paged, for example. And so, What this map is highlighting, let's say. 4 services in red, they're breaching their service level objectives. And besides that. Every component also shows it's uh like a health circle that shows a breakdown between. Server folds, user errors, and successful requests. And you can kind of gauge from that where the problems are. First of all, what's highlighted in the red. Second, you, if let's say you didn't set up any service level objectives, you can just gauge from that circle, the more red means, you know, more problems essentially. And you can like instantly go and inspect uh each component and get this. Operational audit and for example, in this case, I get a whole bunch of, you know, this audit cards that tell me, you know, we have this uh problematic dependency and it it's set like some, you know, unhandled um edge case. etc. And this one is interesting. Uh, one of the, uh, auditors will try to find an outlier, and by outlier, I mean some of the resources like a pod or a node or easy to instance that contributing the most to errors or to high latencies in your application. So this is, this, uh, audit card is finding exactly this scenario suggesting that. You would want to recycle this resource, right? But it's all good and great knowing what's happening on the server side, but sometimes we don't have full visibility into what's happening with the, what the client experiences because um The server side instrumentation gives us so much, right? And for that, there are 2 techniques that CloudWatch suggests you could use. One is uh synthetic sknadis. So this is an example of A whole bunch of different synthetic DNAs that continuously running, executing. Uh APIs and validating that the responses actually match the expected results. And you can see like, well, they're actually not always succeeding, there's only 96% success rate. But there is a of. They, they called synthetics for a reason, uh, so they're not fully represent the actual customer experience. And to measure that, uh, cloudWatch has real user monitoring. So real user monitoring is a. Essentially Um, uh, a set of APIs, including the client-side SDKs that You can use to instrument a website, so like this example is the A monitor that uh it it's just essentially a bunch of JavaScripts that included with a website that continuously measuring and reporting back home about how these pages are loading, how fast, are there any JavaScript there, etc. And what we just recently launched is a similar. Client-side instrumentation for Android applications. And for um iOS applications. So, so that way, when you look at this application map. You're not only seeing how your services are performing, but you're also seeing what your customers are experiencing. And so from this picture, I could say that like again this uh health status circle, it tells me that, well, the Android customers really having a bad day. I have Too many crashes, and like also server faults and these graphs, they kind of support that. They just saying how historically. Um, those issues have been happening. So at this point, I would like to troubleshoot more and, and get to the. Uh, really user monitoring part of the AWS council. So in here, real user monitors in application signals that they connected with the service that this, um, you know, client applications are hitting first, like in this case it's a pet clinic front end. And I have 3 different real user monitors for this uh microservice. Uh, so this one is for website, this one is for, no sorry, this one for IS, this one is for website, and this one is for Android, and I could tell from here, from details. Which pages or screens actually having issues in an, in Android application. And so, like this is a number of crashes, and so the owner details activity is the one that has the most problems. Um, to troubleshoot even further, like, first of all, I, I can go and use, um, Android Studio, so I have it preloaded. To validate like is this actually happening, so I can go check on list of all the owners, so I, I'm running a simulation of this uh mobile app. And when I click a. Individual owner, it essentially resets, so I do see that this application is crashing on that particular screen. So to root causes even further. I can click on any data point on the crashes graph and we'll get like essentially a list of sessions that Uh, resulted in application crashes, so this, this data is transferred from the mobile app to RAM, uh, service. And at this point I can just, you know, spot check. For example, I pick a session and uh I I get transferred to Ram console and then here I can look at the exception. So this is the stack trace for this exception. I can just go and transfer it back to the. Um, Android Studio analyze this stick trace. And essentially go to the line that causing the issue. Just help me to understand where I need to implement the fix. So enabling um. A RAM for mobile and I'm gonna show for Android. Very straightforward. So there's one more, there is one dependency you need to include in your um You know, build file which is um. Hotel is the key, but it's packaged by Amazon. We, we just picked all the pieces needed from Hotel to support that functionality. And you also need to create a monitor and. Specified in the configuration file that This application will be recorded through this RM monitor. And just specify the region where the telemetry will flow. And that's how to set it up. If I go back, just one thing I wanted to summarize is that. Application map is um acting essentially as a guiding tool. You can think of it as a dashboard, but interactive dashboard. From this dashboard, you're not only looking just at metrics and graphs, you're looking at your life system, how it performs um at the moment or historically, you can go and check different Time, let's say, if you're investigating an event that happened last night or two weeks ago, you can change the time frame and go back to that time and see. It will historically show how your system behaved at that time. And you're not only seeing. How your service is performing or how your resources uh responding to requests. But now you also with mobile RAM, you can also see. And user experience. And Essentially, that way, uh, oversee all your distributed system from start to end. So, um, application signals what it does it. It, um, after he instrumented. It actually connects metrics logs and tracers together. So, for example, in lambda it's pretty straightforward. There's lambda logs and traces and metrics. For let's say EKS it's a little bit more involving, but it's still, you know, relatively straightforward, um, so in fact, uh, traces in cloudwatch they do report they connect which log group to go for corresponding logs. And so, like, I can show uh one of the examples. So if, when I'm troubleshooting the service, let's say this is a microservice, could be chaos or And have this bunch of operations, and this operation is like obviously failing. And at this point, this is where the sidebar connects all. All this other telemetry. So, on the left you see the metrics. Here you see correspondence spans to the metric, but this is the link to application, uh, log. And the similar would happen for, let's say, EKS application log, and you can, let's say application signals could not connect the dots, you could customize your, um, trace attributes and add which logs to look for. When that trace is um emitted. And also like, you know, we have uh maybe you wanna show the transaction search feature. So what we do is like, you know, we take your transactions in terms of traces and then convert and then store as logs. So that way like, you know, you can go ahead and then um just search for it, anything. So an ideal use case could be like, you know, if you are um maybe a support person and then you're getting a call. And then the customer is saying like, hey, my order is not going through. All you need to ask them is like, hey, what is your order number? Just go to the transaction search page, click that, like, you know, order. ID is 123, something like that, right? And then the moment you click enter, it is going to take all the traces or all the transactions that have happened in the last 3 hours, for example, and then it will show you all the transactions in that one, wherever we are using this order ID is 123. So this is like, you know, finding a need in the haystack kind of a situation. And with this transaction fees uh search feature, because we are taking your traces and then storing as logs, you can do all kinds of operations typically however you're doing it with your logs, right? So maybe, yeah, so this is what the transaction search feature is. So Alex can guide you on that. Yeah, the transaction search already also. In mm getting benefit of discovered services, it will help you. It will suggest, OK, you can search through this microservice through this API and that will also help you with like which fields you can specify in here and maybe some of the fields will be, you know, this is my request ID. I know the request, or this is my order ID, um, and, and you can that way nail them, but I think the point what Shiva was making is that. Uh, traces in application signals, they stored as logs, and, and that way you can use log analytics essentially to um better reason about the your application. Behavior. Follow up. Uh, if I've already instrumented for X-ray. Do I need to hit that again for open? No. There is one, you know, caveat. So, when X3 originally launched, it has its own SDK, which is, we announced as on deprecation path quite a while back. And I don't know, some, some people still use that, right? That X-ray is decayed. But I guess starting a few years back we announced that moving forward Otel uh SDK is the one that X-ray will support in the future and we call it Amazon distribution of Oel A dot. Um, and the reason for that, we actually all of that you can assemble it yourself as well. It's all in public people. We just prebuild it so it's easier, uh, to make sure all the necessary pieces are in one place. So this particular QR code has a bunch of links, uh, so if you want to see that, so whatever, um, Igor, sorry, uh, Alexis, uh, talked about, all these things are available in that one observatory workshop. Uh, so we have application signals demo also, uh, so all these things are interactively available so that you don't have to, uh, create any accounts and then try out those features. So, and also, like, you know, we have a YouTube, uh, show. Called Cloud Operation Show. So that runs every 2 weeks, Thursdays. Uh, so that recorded videos are also available there. And, uh, we do have a separate observatory best practices guide. So we have been talking to hundreds of customers, and we identify the patterns, and then we document all that information. Uh, so that information is also available. Uh, please take a look into it. And then if you have, uh, any interest, like, you know, any follow-up or anything, please, uh, reach out to us. Um, so this is our LinkedIn, uh, handles. Please feel free. Thanks everyone. Thank you everybody. Thank you.