---
video_id: ukqAqMVh9Vs
video_url: https://www.youtube.com/watch?v=ukqAqMVh9Vs
is_generated: False
is_translatable: True
summary: "This session, titled \"From Code to Cloud: Building AppSec Programs with AWS\" (SEC222), presents a comprehensive, four-phase roadmap for establishing and scaling effective Application Security (AppSec) programs, moving beyond the traditional \"gatekeeper\" model to one of \"distributed ownership\" and builder enablement. Speakers Daniel Begemer and Patrick Goh argue that successful AppSec is less about acquiring the latest tools and more about mastering organizational change management, emphasizing that humans are inherently lazy and processes must meet developers where they are to drive behavioral change. They propose a maturity model consisting of Planning, Preparation, Execution, and Scale. In the Planning phase, Patrick Goh introduces the \"ACE Model\" (Actionable, Convenient, Encouraging) for communication and shares a pivotal lesson from his career where a sophisticated enterprise security platform failed to gain traction because it disrupted developer workflows, whereas a simplified \"easy button\" approach succeeded. He reinforces this with a side-by-side comparison of internal communications, demonstrating how subtle shifts from \"Action Required\" demands to \"Opt-out\" defaults can leverage social proof (e.g., citing that \"90% of builders thought it was easy\") and significantly boost compliance rates without friction. Daniel Begemer then deep dives into the Execution phase, focusing on two key mechanisms: Threat Modeling and Automated Scanning. He details the \"Four Question Framework\" (What are we building? What can go wrong? What are we doing about it? Did we do a good job?) and recommends tools like the open-source \"Threat Composer\" to systematically document these architectural reviews. The highlight of the session is a practical demonstration of AWS Kiro, an agentic IDE assistant, using a vulnerable \"Fry Factory\" Python app that contains hardcoded credentials and SQL injection points in the \"My Orders\" section. Begemer shows how to create a specialized \"Security Agent\" within Kiro by ingesting \"steering documents\"—custom markdown files that codify the organization's specific security standards (e.g., \"Secrets Management Policy\" or \"Injection Prevention\"). This agent autonomously detects the vulnerabilities, references the specific internal policy violated, and generates compliant remediation code, effectively bringing the \"easy button\" concept to life directly inside the developer's IDE. The session also covers Amazon Inspector as a zero-configuration vulnerability management solution that integrates directly with code repositories to provide continuous visibility into package vulnerabilities. Finally, the speakers address the challenge of scaling security in large organizations by advocating for the \"Security Guardians\" program. In this model, specific developers within product teams are trained to act as local security champions who understand both the business context and security requirements, empowering them to make autonomous decisions. They also emphasize the creation of \"Golden Path\" artifacts—reusable, secure-by-default code templates and infrastructure patterns—that ensure the path of least resistance for developers is also the most secure one, ultimately transforming the security team from a \"traffic cop\" into a business enabler that prioritizes getting to a \"secure yes.\""
keywords: AppSec Program, Security Guardians, Threat Modeling, AWS Kiro, Behavioral Change, ACE Model, Distributed Ownership

Hello everyone. Thank you for joining us for this 4 p.m. Thursday session and welcome to SEC 222 from Code to Cloud building Asec programs with AWS. My name is Daniel Begemer. I'm a senior security engineer in AWS. Been here for over 5 years now. Been doing. Security for the past 13 years across different domains including incident response, application security, and recently security. Today I'm here with Patrick Goh. Hello everyone, Patrick Gall. I'm principal security engineer on ABOS's global service security team, and I've been at ABOS about 3.5 years. Prior to that, uh, I was a late stage startup, was a, a VP of security, helped, uh, build up their Greenfield Security program, and then prior to that I was an APSsec engineer and I've built and run, uh, security engineering teams and architectures. And a pleasure to meet you all today. Cool. So this is a level 200 breakout session. We're going to have 60 minutes where we're going to dive deep into APsec, how you can build APSsec programs in your organizations. Um, hopefully by the end of, of this talk, you're going to get some tools, practical, practical tools, practical frameworks that you can go and implement in your environments, uh, regardless on which stage you are in your sec program, if you already have one, or if you plan to implement a new one. We are going to start by having a quick overview about what is application security. What exactly means APSEC? What is an ASIC program? Then we're going to discuss the principles of APEC. And from there we're going to dive deep into into the APsec program roadmap and we categorized it to 4 different phases. We're going to start with preparation and planning, which metrics you need to you need to define, which metrics you need to collect, how you're going to communicate with different stakeholders in your organization whenever you implement new new upset controls. Then we're going to touch execution. We're going to show you how you can really run threat model, how you can run code scanning, and and and and and other and other solutions leveraging our services. And we're also going to show you some demos there. And in the end, we're going to touch on scale. How you can do those things in scale, and, and I really hope this session will be valuable and hopeful for you. Patrick. Thanks, Daniel. So before we get to the main part of the session, I'd like for us to align on a common understanding of what application security is. So application security is a set of people, processes. And technologies used to evaluate the security properties. Of software During all phases of the software development life cycle. So I'll call special attention now to the latter part of that definition. Because it gives us some unique insight into how AWS, we ABS views application security and security. It's really along two dimensions. The first dimension is around this notion of ownership or distributed ownership. So if you talk to anybody at ABS from Matt Garman, the very top, to individual contributors, They're going to tell you security is top priority. That's the first piece and so implied in that is some notion of distributed ownership, everybody at ABOS that builds and operates services. Has some sense of responsibility and accountability towards securing the services that they build. It's a part of of that as well too, in particular our builder teams when they build and operate a service. They're responsible for the security of their service. But they're also Empowered to make security decisions. On behalf of ABS. So that's the first thing is distributed ownership. The second dimension is around this notion of shift left or integrating good security practices across the entire SDLC. So if you asked me about Abstract 10 years ago, we'd have done bolt-on security after the fact, after we pushed code to production. Today we think about integrating good security practices as early on as possible into the SDLC. So you all have probably heard the term shift left, right? So it's distributed ownership to scale. Second thing is around integrating good practices, security practices, as early on in the SDLC. So Daniel's actually going to touch upon a core mechanism that we call threat modeling. Um, and we'll get into details and give you a high level framework and approach to do that, um, but that's a core part of what we do here at ABS. Now why is it important if we're doing it right? That really helping our builders. Build software faster. Get features and capabilities into your hands as quickly as possible while still maintaining a high bar for security. And if we think about integrating all these applications getting best practices early on in the SDLC as possible, you're also reducing costs and reducing risk for your organizations because let's face it, it's a lot easier to actually make changes on a simple diagram in an architectural diagram than it is to actually go back and roll back code that's insecure to start with and then also potentially deal with the fallout related to having security issues potentially being exploited. And if we have those time savings, those cost savings there. We have more time and we have more money to reinvest into our program for other improvements. Now how do we do it? There's really 5 core principles that we here at ABS abide by. First is around setting clear expectations. From an organizational perspective, it's really understanding what your risk tolerance is as an organization, what your risk appetite is. Defining what that security bar looks like. Once you define that. Then we clearly define what security requirements, policies, and standards we're going to drive and enforce across our APS program, across, across our portfolio of applications. Earlier I also mentioned this notion of like distributed ownership, right, and that service teams at ABS are that build and operate their services, they're also responsible for the security of their services. We empower them with knowledge, so having a strong training mechanism to educate them on knowledge of security. And it's also teaching things like threat modeling, so a lot of our builders, as part of our standard development processes. are looking at architecture diagrams and Daniel's getting into more details, but they're going to identify risks early on in design and try to build in security versus wait for after the fact when code is pushed to production. So the second core principle is really around having robust training in communities around empowering our developer teams to actually build securely. Third part is automation. We use automation to be able to automate undifferentiated manual processes, 1, and then 2, when we define security requirements and standards and policies. We use automation to consistently apply them and enforce them across our SDLC. Now the 4th I around metrics. At ABS we incessantly measure everything. So think of metrics in terms of number of security flaws by severity levels, by different business units, business lines. Because that gives us a current view of what our security risk posture is. And then it also gives us a basis for continuous improvement. So the 5th 1 you also heard a little bit about earlier too is this notion of organization. And when I say organization I mean organizational buy-in across the entire org. Now I mentioned earlier that everyone from Matt to individual contributors like myself. For us, security is top priority. And so that's key. The other aspect of this underlying sort of these are the five sort of you know key principles that we use to drive our program. But the other underlying principle that I'll show you next is just based on my own past experiences. So a number of years ago when I took on a new tech team and I had to reboot the program. We had to get some visibility out there to understand where our security risks were within our application portfolios were going to be. And so we evaluated a number of different application security platforms to be able to do things like static analysis, security testing, software composition analysis. And one of our core requirements is really how effective. The fast and SCA engines were going to be. What I didn't consider and looking at it back at hindsight is 20/20 is really Is this tool something that the is the developers gonna actually use? And so it was a hard lesson learned for me. And so when we deployed this platform, we selected a platform, we deployed it. And it took probably 3 times as long as it should have. But the problem was I was asking our developers to go and actually do the build and the compilation to build the software and then log into a separate platform, upload that to get actually get the scans done. And that was a struggle. I planned out a year in terms of planning. It took 3 years to actually get 100% coverage and 100% visibility of security risk across the application portfolio. That lesson learned translates into this last principle, and you'll see this theme throughout it in that we want to give developers the easy button. So my lesson learned was we wanna, as we think about our abstec programs, whether we're building a Greenfield one, we're rebooting the sec program that we currently have, we really wanna meet developers where they are. Which means things like we're not gonna add extraneous process into what they're doing, right, in terms of tool selection, in terms of how we communicate, we really want to give them the easy button. And you'll see that across a variety of different dimensions whether it's technology or even just simple communication. So a lot of this is sort of my own personal experiences, but there's actually a branch of science called, um, behavioral economics, um, but the TLDR Ablo studies is that humans are inherently lazy. I am inherently lazy. If I was given a choice to be to take action or not take any action, I would rather not take any action. That's just what it is, um, and so as I think about APEC and as we think about absec. We really needed to drive this home, make it easy for them. So in terms of a practical roadmap. There's nothing fans here Absec and getting behavioral change to occur is not it's not rocket science really it's not a technology problem it's not as much a technology problem as it is a human organizational change management problem. So we want to keep it simple for you all in line with the spirit of using the easy button. It's 4 faces. And you can use this whether it's a green field or brown field program you're trying to reboot, but planning, preparation, execution, and scale. And we'll dive into each 4 of these. Throughout the remainder of the session, so the planning phase, it's really about stakeholder analysis, it's identifying, engaging your stakeholders, understanding who they are, what their businesses are. Keeping the business objectives in mind because we as a security team really want to be a business enabling function versus a traffic cop and the solution. So identifying engaging stakeholders, understanding the high level of risks, understanding what keeps them awake at night. And then from there it's working with them to establish clear goals and metrics that we can measure and that we can achieve. From there it's about preparation, getting code code scanning across your environment, across the portfolio applications, to understand what sort of security risks you have in your source code in third party packages. And then we talked about communicating our expectations. It's really defining what your risk tolerance is and then defining those standards, requirements and policies and then communicating those expectations with those stakeholders. And the third piece is around scale training builders to builders to threat model. There's never going to be enough tech engineers to support the number of developers. Having been one before, it's impossible, even if I work 24 hours a day during 65 days a year. And so we want to really empower our builders, train them on security 1, and then 2, we want them to identify risks in their design and build securely versus wait till after code is pushed to production. An execution phase that's where we're sort of in a steady state. We actually have threat modeling as a standard part of our design processes. We're fighting and fixing security issues in the ID before a line of code ever gets committed into our source code repositories. It's also deploying security testing in pipelines, knowing that we want a defense in depth approach to to applying controls. And lastly, scale. Once we've got the visibility, once we have an ongoing process whereby we can actually see what the security risks on our applications are gonna be, then we can start looking at identifying systemic issues. And then turning around and building secure design patterns and enabling our developers by giving them what we call golden path design patterns, packages. So for example, one of the things that Amazon we do is we want to give our customers a consistent authorization experience. So we have a golden path pattern for that and we also have all the libraries and packages that we all use as part of that design pattern, and that's how we can start thinking about scale. And lastly, it's really about seeking feedback from your program stakeholders, really understanding who your stakeholders are, having a good relationship with them, right, getting to a, instead of saying no immediately, it's really about how do we get to a secure yes. So let's dive into the plant phase. So I mentioned briefly earlier, it's really about identifying and engaging your stakeholders. Take inventory applications, understand what you're working with to start with. Understand who those owners are, who the businesses are, and then also understand the operating context. But the biggest pro tip I'll tell you here is If you're rebooting a program or you're building something green filled, getting leadership blinded is going to be the most important thing. The second thing is find absec friendly or security friendly organizations leaders to help you create some quick wins. Engage with those organizations. Find applications that we know that are high risk, high value, high impact if we're to help there. Get some quick wins, get some momentum, and that really starts to, to accelerate your program after that. And then most of all it's really about reframing your thinking, and we'll see some of those examples and just subtle communication differences, um, but again, meet developers where they are, not the other way around. Understanding high level risks When we do the stakeholder analysis, we really need to understand the applications we're working with the business context, the operating context, get a complete view. Some businesses are gonna have different objectives than other business units that you support, so having an understanding of those subtleties is going to help you build rapport, build trust, build relationships with your constituents, because you're gonna need that because you're as an abs are never gonna be able to scale yourself as a human, so you need their help. Understand the parties. Ask him what keeps him up at night. What are some of the challenges? And then from there think like an adversary at a high level. Look at different business lines, maybe in different industries potentially, depending on the size of your company and understand what the potential uh avenues that a third actor would like to compromise either confidentiality or integrity or availability of your systems. Lastly, this is not rocket science, it's really just doing basic things like establishing clear goals and metrics and getting everybody aligned. So out of this plan phase you want really to develop a program charter. You want to get by with the leaders at the highest level. When you're rebooting a program, whenever you're building a greenfield program, you really want to bring your stakeholders along as part of that journey, you want to include them in the conversation, you want them to be involved in the definition in terms of the program, vision, mission, and charter. And that way they have some sense of ownership and accountability. Once you do that, get some quick wins, then you start to get some momentum, and then you really start to take off. Key is distributing ownership. So back to the initial initial concept of everybody at ABOS owns security, right? Our service teams are responsible and accountable for not only building and operating their services, but operating and being responsible for security. Now out of the planning phase, you get a charter, you've brought your stakeholders along, you've got a clear vision, mission and goals, you've got buy-in from a leadership perspective, now it's about preparation, getting visibility to your portfolio. Get testing out there. Understand what sort of security issues are in your source code. What third party package is the most vulnerable? Try to identify systemic issues and then develop mitigations for high risk, high impact applications. So this is kind of interesting. Um, now we sort of switched the communication aspect and we talked about this notion of the easy button, right? And so I like to use this framework called the ACE model. Um, and so when we start to engage our stakeholders, we communicate with them. It's really about when we think of communication, think of four letters E A S T. Keep it easy. Make it exciting, make it attractive, right, gamify it. Make it social. It's funny, there's this psychological phenomenon called social proof. So, uh, in the absence of, you know, if you're presented with a situation where you're unfamiliar and you don't know what to do. The human tendency is to look towards your peers to see what they're doing, what they're thinking. And then you have this tendency to do the same things that that that did that excuse me, that they do. And so you'll see it in the upcoming example of of sort of sort of reframing and how we communicate that actually drive a lot of behavior change and part of that is the social proof concept you'll see it sort of in practice in the next few slides here and make it timely, right? Read the room as you communicate, it's being able to understand when's the best time to talk to somebody, right? Try to identify barriers to action or inaction. And remove them, but it all goes back to the E button. You can use the ESE model in your communications as you engage with the stakeholders. So, going back to my story of my lesson learned, uh, when I was deploying this sec platform, and we'll call it uh absec widget. This looks like probably 80% of your corporate communications that go out. It's not quite as long, but if you read it, take a moment to read it, it's kind of boring. But the, but the thing I'll call attention to here is that, that bold line, action required. Enable scanning your respective source code repositories by a certain date, so we're deploying an ASec platform. We want developers to actually start scanning their applications so we get some visibility out there. So 80% are boring. Asking you to take a lot of actions and making it hard, right? To me that's a barrier of action or a barrier to actually doing something. So that's, that's what I probably would have written 10 years ago when I was trying to reboot this sec program. Now let's think about the ACE model in the context of this next email. So I'll give you a moment to sort of read it, but a couple of things to call out here. The first one is this notion of um Making it really easy. So if you see the call to action. We're actually using uh defaults if you will, so if you need to opt out of scanning for specific repositories, following exception by January 31st, 2026. So we're by default enabling scanning on repositories so we can get. There's some visilla out there and we're not asking a lot of our developers, so we're actually forcing them to opt out of it and it makes it easier. So subtle reframing techniques make a huge amount of difference in terms of the way you communicate the way you collaborate with your developers. And you also see things like the first one, the first bold line. In fact, 90% of builders who tested it thought it was easy. That's the power of making it attractive. Like you want to gaming, you want to make it exciting, you want to show that most developers are actually doing this and thought it was, it was a cool, really cool and easy to use platform. And so subtle reframing as you can kind of tell in the way you communicate, makes a world of difference. We are here. So now we've talked about the communication piece. We're going to move to the execution phase. Daniel? Thank you. So really, we started with the pre prepare and planning phases, and now we'd like to discuss how you really execute, how you really can leverage frameworks or some of our services in order to run the execution for your OSI program in your organization. Let's start with with threat modeling. You want to threat model everything. Whenever if it's a new feature or a new product, you want to start by trying to understand what can get wrong, what's the worst that can happen. So When you start the threat model, er, there are several, several phases that you that you can follow and several frameworks, and I'm going to share some some shortly. But first, your goal is to try to identify. Identify those risks as early as possible during your software development life cycle. If you need to make a code change, or if you need to change the architecture or include different service or tool, you want to make those changes on the whiteboard and not already after the application is developed and deployed. Now, this is an example for a framework, the 4 short stack 4 questions framework. When whenever you run threat model, you can leverage that or or other frameworks out there, but the principles are pretty simple. You're gonna start by what are you working on? If it's a new service, it's a new app, it's a new feature, an existing service, who are our customers? What is the business logic? What exactly is the expected outcome? Next is what can get wrong? What's the worst that can happen if I have an unauthorized user, if they can exfiltrate sensitive information. They can maybe impact the integrity of my of my data. What's the risk of the availability if my app won't be available for several hours, and what is the business outcome of that? Then what are we going to do about it? Which tools, which services we can implement in order to mitigate the risk. Maybe we can use a different software package. Or maybe we can push a code a code change. So what exactly we can do in order to mitigate or minimize the risk? And in the end we need to review it. We did a good job. Like if we really minimize anything that we wanted to mitigate, if we accepted some risks. If you can if you if you can accept the current state of the application. And this process is iterative. So, you will probably learn from other applications, you will learn from other projects, you will learn from your security issues. So you need to take those learning outcomes and put it again as a part of this threat modeling process and make sure you're asking the right questions. Now this is how we also work in AWS whenever we're shipping a new product or a new feature, a new service, threat modeling is is something essential that needs to work a part of this process. If you want to take another step further about what exactly you need to do in your threat model. So first, make sure you have diagrams, documentation, that you know what is the data flow, what is the architecture. If you don't know how the system looks like, how you can first model it, right? Next, you need to get your security teams, your developers, and your, your business stakeholders all in the same room, or virtual room. And work together in order to identify the risks and different mitigations. Then we need to document, as we mentioned before, we want to document everything. And you can really use some tools. 11 example for a tool is Threat Composer. It's a tool which is available as an open-source tool in our GitHub repository. I will, I will share a link later on. But the idea is it can help you to conduct this process and really document document the information and and the decision that you make during your threat model. Next, I would like to discuss another topic. Code scanning. You want to scan your code, your repositories, one software composition analysis. I assume most of you, most of your teams are leveraging air tools as well for development. So we are going to really discuss uh Amazon Kiiro and the Amazon inspector, and how those tools can help you to run some of those er etc processes. Let's start with Quiro. Our igentic IDE solution. This is an example for the easy button that Pat mentioned earlier. So really, Quiro can help your builders, your developers to write code to be more productive, and we know that by now. But it can also help you to run code scans, perform security testing, security analysis on your code. And it really meets the developers where they are, right? Talking before about the easy button, developers using IDs to develop code. So why not including those tools as a part of the ID to make it easy for them and not adding another process or another screen or another window that they need to open in order to follow an upset process. Next, I would like to show you Kiro in action. I would like to have like a short demo about how you can leverage Kiro for for Upset. Just before that, before jumping into the demo, I have a quick question. Who likes french fries? Raise your own if you like french fries. Alright, I like french fries. Probably need to eat less, but, but I'm really, I'm really a big fan. If I want to be a security engineer, I'm probably gonna be, uh, uh, I will probably open my online shop for french fries. So that's what I did with this demo. You can see here, Fry Factory, my online shop for selling french fries, and I have different types of french fries here. You can see that we have classic fries, but we also have cheese fries, truffle fries are my favorite actually. And this is an opsec talk, so if you go to the my order section, you can see that with a simple SQL injection query. I can potentially get some sensitive information. So this is very sensitive information about the previous orders, the amount of salt, the amount of crispiness, how much ketchup each previous order had. So this is something that I probably would like to investigate and protect. Now, let's jump quickly into the source code. This is Qiro, uh, the same, the ID that I mentioned. And if I will go to the source code of my Python app, I can see that I'm using Flask, and I have several, uh, several, uh, dictionaries that represents my database. And if you notice downstairs, down there, like, there is some hard-coded credentials as well. So I think that by now, we all agree this app is a bit, a bit vulnerable. Now I can use Kiro and just mention those issues or ask Kiro to run a security scan for me. And, and that's fine, but I want actually to show you something a bit from, from a different angle, a bit more advanced. I'm going to use the Kro steering documents. So the the Kyro steering documents can help me to define prompts, which can include standards or security requirements or templates, and I can reuse them across different projects or across my organization. So if if I would go to the to the kiro folder. And I will go to steering. And on this thing I can see different files. So first, I have a file that can help me to define my documentation standards, how documentation should look like, right? This is how I want every, every project documentation to be structured. There's another example of threat modeling. We just discussed threat modeling, how we can automate that. So, really, here, I, I, I can use the stride, and I want to have these risk scoring metrics, with these considerations, with this template. Another example I want to show is security standards, which may be the most relevant for this one. So I have here a document that defines my security standards. If you notice, uh, section 2 and 3 are directly relevant to the security issues that we noticed before. We have secrets management which we know that we're not really storing secrets in a secure location. We saw the hardcoded credentials and that's also the injection prevention, which we saw an example of how we can really run SQL injection against our sample app. So, this this steering document can be ingested into Qiro, and it will help me to run the fixes. Great. I want actually to take it a step a step farther. I will use your agents. Secure agents can help me to define different agents with different roles. That the input of those agents can be those steering documents. We can see here that we have a threat modeler agent conduct the threat modeling using stride. Your role is to analyze the application and identify the security issues, and really you have the which which passes are allowed for these agents, which actions this agent can take, and I'm also ingesting as a resource the stain steering documents that I showed you earlier. Um, so this can really help me to just run threat modeling in an easy way. Let's jump to our security scanner. I have another agent that specialized in running security scans. And this agent again has the prompt. You're running SAS scans, and you need to run security scans again against the project. And I'm also ingesting the same resources that I mentioned before, but this time I'm also including a tool. I'm including Ash, the automated security helper. So you can integrate with the agents your own tools in order to run your security operations. Ash in this case is the code security scan tool that's available in our GitHub as an open source, and again I'm going to share the link for this one as well. But the idea is just to show you that with the power of cure agents and MCPs you can really create end to end integration with your business context, the security standards, security requirements, your project. And really the role and the prompt that we're running into our agent. Let's see how it looks in action. I'm going to call our agent to run a security scan. So since it's already, it already has the The context, I don't need to provide any additional guidance. We're just going to go to the. And I will call our security agent, which I've defined here. The MCP is loading and I'm running a security scan with a simple prompt of run a security scan. And this will take a couple of couple of moments, and Eventually, the scan will run, and it will trigger my tool, follow my security standards, follow the guidance of the agent, and it will provide me a contextual security report based on the finding that it found in the repository, based on what my tool found, based on, based on whatever I prompted, and in the security standards and instructions. So we can really see again the secrets management and the SQL injection. Next, I want to really take it to the, I can just like open the report and review it and share it with my developers, so my developers can review it, but we can even take it to the even one step further, and we can use Quiro again to take this report and give us specific actionable actions that we need to need to run against our code repository. So by running that, again, it's going to take it's going to probably take a couple of moments. Sorry. It's going to take a couple of moments, but in the end, I can see really a report with what exactly are the issues, what needs to be fixed, and how I can really implement it. So, this really connects to the the same easy button that Pat mentioned before, and it's kinda we're going to repeat this concept. Make sure you're making it easy for the developers. I want to show you another example for another easy button, another tool that can help for running uh running sec on your org. This time it's Amazon Inspector, our vulnerability management tool. Amazon Inspector can integrate with the different AWS accounts and one scans against your containers, against your compute resources, um, against, against your code code repositories. And it's really an easy button because again you're not asking anything specifically from your developers. You can integrate Amazon Inspector with your GitHub and GitHub repositories. And have this centralized visibility over security issues across the organization. Let's do it in action. So here I'm in the Amazon Inspector console, and I can just go to code security. I've already integrated. Amazon inspector with my Gita repository, really with a couple of clicks, and I'm going to just create a new scan configuration. There are some parameters that I can change here, such as how often I want the scan to run. I'm just leaving it default here. It's going to be weekly and on every every commit push domain. And I can also pick the different security scans, so I'm going to leave it as infrastructure as code scanning, static code analysis, and software composition analysis. I can really filter by which repositories I want to run the scan against. Just going to run it against all of them. Now, In this case, it will just run on the next the next weekly period. I think that here I picked Monday, so instead of waiting until next Monday, we can just run an on-demand scan. And After running an on-demand scan a couple of minutes later, I can really go into go into my scan, and I can see a full detailed report of my security issues. Since it scanned both the code and both the packages, I will find different types of findings. Here we see again examples for hardcode credentials. What exactly is the issue and what and how it can be fixed. Then we have another example for another package vulnerability this time. And which version will be fixed in this specific case. So really, Amazon inspector is very easy to use tool that hopefully can be beneficial for you as well. After we really discussed about some execution steps. We showed you how you can use Qiro, an Amazon Inspector. We discussed threat modeling. How we can really scale. Right? We can, of course, scale with Amazon Inspector and Kiiro as well, but I want to dive deep into the scaling mechanism. First, and I think that Pat mentioned it a bit before, we want our developers to think security. Here in AWS developers focused on shipping and delivering new, amazing features and so and and products, but they all think in security. They all have security in mind. They can measure those security. We have different programs around around secure development, which, which I will share, I will share in a bit. So make sure that your developers are aware of the the importance of fighting more secure code. And make it easy for them. Make it easy for them with your different tools, with automations, and make sure you're not adding another step and making it hard to write a more secure code. One example If you have, if you have er a solution or a process that the developers need to follow. Where it's reusable, maybe create a reusable artifact that they can consume. For example, if you have standards for how authentication should work in your organization, instead of trying to invent the wheel each time, make sure you have a package for authentication that they can just consume, import to their to their project, and it already has the security requirements and standards that you need to follow. If you know how a 3D web app should look like, Give them a reference architecture. Give them the infrastructure as code templates. Give them already an environment built in with the security controls so it will be easy for them to start building. And another point is make sure they have the autonomy to make decisions. Make sure your security teams, not always, er, make sure your developers teams, I'm sorry, not always rely on the security teams, which are usually which are centralized and can be a bottleneck, right? So we really want to make sure that we can uh we can let our development teams, the product teams, the builders to make security decisions. And I'm going to give an example here as well. So, in AWS we have the Guardian's Program. Anyone heard about the Guardian's program before? OK, we have one hand. Um, so the Guidance program is a program that we have internally. Um, we already have some public resources about as well. But we're taking developers, builders on the different product teams and we're training them on security. And they are acting as the security guardians of the team. Those team members Knows knows their teammates best, knows the product best, understands the business goals of their team, but they're also trained on how to really do security and how really to conduct threat modeling and how to really follow those centralized security teams with the security requirements. That really helped to expedite security and upset processes. Because those security guardians helping the product team to run the threat model, helping them to guide documentation, helping them to implement security controls, we still have a centralized security team. We still need to run a penetration testing and to get the sign-off from the centralized security team. But when you have that security guardian in your team, it really helps you to make sure that you get everything necessary and you really make this process more smooth. So we really touched er touched the different phases of how you can really build an sec program in your organization. Um, we started with planning, right? Pat really showed you some examples of how you can define goals, define metrics, how it's important in order to measure success before you even start to run the program, define what success looks like. Then the preparation, how you communicate to the stakeholders. How you train the teams. We saw the example of the email how changing a couple of words and sentences making a huge difference, right? Then we discussed execution. We saw the threat modeling, which questions you need to ask, what do you need to collect, how you can use Kiro steering documents, how you can use inspector reintegration with our, with, with your code repositories. And then we discuss scaling. We talked about making Reusable artifacts when possible. We talked about the Guardian's program. We talked about distributing ownership to your product teams. Now if there is one big takeaway that I want you to take from this, from this talk, is make it easy. Don't make Apsec hard on your teams. Integrate it with your with your processes. Make sure it's easy for your teams to run the code scan, and to get you the results to make sure that uh that you follow the security requirements. Try to walk walk backwards from your development teams and integrate in your security requirements in Starmaster. I promised you some resources, so those are some resources that we discussed today. You can check the threat modeling workshop if you want to dive deeper into how to conduct threat modeling. We have the threat composer, the open source tool that I've mentioned before, which you can use in order to run the the threat modeling against your applications. Ash Automated Security Helper, it's an open source tool for code security scans, and I showed an example with the MCP agent. And the Security Guardian's blog if you want to hear more and learn more about the Guardian's program. I really hope this session was helpful for you. We're going to stick around if you have any questions, and please fill out the survey, it's super important for us. Thank you so much.