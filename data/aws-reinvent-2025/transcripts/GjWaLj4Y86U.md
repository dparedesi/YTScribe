---
video_id: GjWaLj4Y86U
video_url: https://www.youtube.com/watch?v=GjWaLj4Y86U
is_generated: False
is_translatable: True
---

Uh, thank you so much for coming. My name's Anton. This is my good colleague friend. Started as a partnership, now a good friend Ron from Cyber Ark, and today we're gonna be talking about scaling services with platform engineering, right, a blueprint for success. Now it's important to mention that when I mean when I'm saying scaling. I do not necessarily mean what you think scaling means in the context of surveys. It's not how you scale from 5 requests per second to 5000 requests per second. It's not that kind of scaling. When we're talking about scaling here is how do you scale surless engineering in your organizations, right? How do you get from a point where you have 1 team developing with serves to a point where you have 100 teams developing with servis without losing their efficiency? That's what we're gonna be talking about today. At the very last slide, you will have a giant QR code that will lead you to a page with everything you will see today, including these slides. You'll have these slides in 59 minutes roughly, OK, so feel free to take pictures, technically you don't have to. All right, we gotta start somewhere, right? And it always starts here, right? In the beginning we have application development team and infrastructure team. So let's do a quick show of hands. Who's here on more on our application development side? Few people, uh, more in an infrastructure platform engineer, oh, you're in the right place. You're in the right place. All right, let's talk. So everyone is familiar with this model, right? It exists for ages, right? Uh, you know, application developers, they're responsible for the application layer. They write code in whatever language, and you have that infrastructure layer under the hood, virtual machines, databases, networking, etc. which is usually managed by this awesome team with many different names infrastructure, DevOps, operations, SRE depends on your organization, right? Now, sometimes developers need to make changes to the infrastructure. As you develop new applications, you need changes in infrastructure. So who's here using ticketing system between development and operations, etc. right? It's Pretty common. It's still pretty common. So application developers open a ticket using whatever system change request infrastructure team implements that change, and it works great if you have one application development team and one operations team, but at some point you got your second development team, and then you have your 3rd development team, and it continues and so on, so on, so on. Anyone resonates with that, right? I think all of us know what we're talking about here, right? So. It's not a nice thing to say, but at some point in time we hit a place where that infrastructure team, without really wanting to get to this point, they're kind of becoming the bottleneck, and that's not a good place to be, right? No one wants to be, you know, that team that everyone complains about, right? So how do we solve that? How do we solve that? Well, there are a couple of ways we can solve it. First of all, yay, shift left to the rescue, right now, shift left works, but the problem with shift left is that the definition of shift left evolves over time. Right, and you know you can always throw more stuff into your development teams, right? So now you're also responsible for DevOps and now you're also responsible for security and now you're also responsible for sustainable, right? And now you're also responsible for picking the right model for your agentic application, right? So. It's not gonna scale for 100 engineering teams. You cannot just throw stuff to the left and kind of expect it to work, right? So, uh, another way is, you know, since this is a survey session, is you can start using servius. If you have problems managing a lot of infrastructure. Well, let's manage less infrastructure. Let's shift to servalli, right? I'm not going to cover every single bullet here since you're in this session. You're probably familiar with the idea of servius, right? minimized infrastructure management. Right, but when you're moving from this world of serverless, your perception changes a bit, right? So you come from the world of traditional applications where there's a clean separation between application layer and people and uh infrastructure layer and people that handle that into this new shiny world of serverless applications, right, where. You might still have the infrastructure layer. It's pretty slim, but it's still there. It's not necessarily gone, right? You might still be using RDS, right? But most of your application components, I'm gonna be using the term components here, are serverless. It's essentially a collection of loosely coupled serverless services like lambda, ECS, Dynamo, etc. etc. etc. and we're heading in an interesting state here, right? Application developers and infrastructure people, they kind of start having this interesting conversation, uh, lambda function, it's kind of my application resource as a developer. I wanna control it, but the operations people are saying, no, no, no, no, no, no, no, we do it with terraform, CDK, cloud formation. It's infrastructure. We want to control it, right? And both sides, you know, they have good intentions. Right, no one is wrong here. They have good intentions but a little bit conflicting intentions, right? So it becomes a conflict of autonomy that developers want versus standardization that the operations team want. Anyone familiar with this? Oh yeah. Oh yeah, so. If we put it on a chart, right, and now it's gonna be a little bit interactive. There are startups and startups, they care more about autonomy, right? They don't need to do PCI, HIPAA, etc. certifications. They need to move as fast as possible. But there are also regulated, highly regulated enterprises that need that compliance because they can just cannot afford every single team doing things in their own way, right? It's super hard for regulated industry. So, let me ask you a question. Let's take like 3 seconds. Where do you think you are on this chart? Who's thinking they're more into autonomy? What about the standardization? Probably most of you are thinking, oh, we're definitely having the right balance, right, we're exactly in the right spot. So the goal of today's session is to talk how you can get here. How you can get the best of both worlds. I'll be talking about different techniques and then Ron will cover how they implemented these techniques and many more in their environment and speed up their development. To give you a little teaser, right, maybe a spoiler, but more of a teaser, they've managed to reduce time it takes to launch a new service like from scratch, from nothing. From pretty much 5 months to 3 hours, that's like 99% improvement. OK, so today you'll see some of these practices from me in hypothetical and from Ron in practical, and again, all of that is open source on GitHub. Cool. Uh, whoa, sounds great. Can you please be a little bit more specific? Probably right, you're wondering at that point. Yeah, let's be more specific. So this is what development organizations commonly look like, right? That's what we call traditional ownership boundaries, right? You have application development team, they manage their code bases, then you have operations people, infrastructure operations platform is the new fancy term, right? They manage a lot of things like CICD monitoring, etc. It's not like everyone is exactly the same. This is, you know, general picture of this shift left. Brings us to this. You might have seen it. I called it wild wild west, right, where essentially you're saying every single team is free to pick their CICD process and then you have 100 teams with 100 CICD approaches and when you need to collect evidence for PCI certification or something like that, right, good luck, it's gonna take you 7 to 12 months. OK, so shift left without proper governance in place is dangerous. It is dangerous. That's why the idea of platform engineering that we're talking about here implies you do shift left. Shift left works, but you cannot do it in a chaotic way. You need to have proper governance in place, and that governance is managed by platform engineering. Essentially your teams do own more. They do own the stack end to end, but they don't need to figure out everything on their own. It's based on the artifacts produced by the platform team. So the first step, right, let's get practical. First step would be, uh, well, let's define infrastructure and application resources ownership model. Let's define tools, let's define processes, and you know, we're not talking here about E2 instances. We're talking about services, right, because application developers wanna own some of that, but infrastructure people, they don't want to lose control, right? So, let's talk what that problem, uh, what that platform story is kind of look like. So let's build that platform for a serverless world. At the very bottom of that platform, you will have AWS, right? You've got stuff that is running on AWS. That's the services we provide, management, API, lambda, Fargate, whatever you're using, right? That's kind of the baseline. On top of that, you need to make a decision. Your organization needs to make a decision. What's the infrastructure as code, uh, to framework that we're going to use? It doesn't have to be one, right? Anyone here, uh, let's have, uh, let's see, Terraform. CDK? Awesome. cloud formation. Sam OK, so we went through statistics. Our examples today are gonna be primarily CDK and terraform, right? So, kind of, you know, statistically this is what we're, uh, the most people we're getting here. Everything you see today is applicable to any infrastructure called framework, right? It's just these two are quite popular in the serverless world. So pick a framework. If you wanna use Terraform, if you're using Terraform in other parts of the organization, go ahead, continue using it, right? If you're using Cross. Plane or ACK you manage your resources through QBs control plane. Continue doing that, right? Don't reinvent the wheel. On top of this, you have the CICD flow, right? Once again you need to make a choice. Do you use GitHub, Gitlab, uh, you know, CodeBuild, you know, and you probably noticed that towards the left side that's more AWS, uh, options. Towards the right side that's more of a, you know, third party. Our partners, open source, etc. right? So every layer will have something like this. On top of that, you need to define what's the governance tools that are going to use, right? Why? Well, because since you're giving your developers freedom, and we'll be talking about that in a moment, you also need to have governance. There is no freedom in selection of tools without proper governance that your developers are actually selecting from approved list. And obviously on the very top, and this is not gonna be the main topic for today, but still you can have something like uh Backstage or canoe or Gitlab, something where you store your assets in, something that your developers can access. It can be something sophisticated as backstage or something as simple as Git repository, right? Essentially something that your developers can use to obtain access to those resources. You'll have a bunch of partners, OK, so those are common ones. I just arbitrarily picked three of them, right? So you'll have different partners that you need to integrate into your tools, and the question is, that's a lot of icons and a lot of layers. So how do you actually standardize this? How do you build what we call a blueprint, right? And this is where we're recommending you start with a catalog of vetted infrastructure code modules, OK. Everything before the slide was hypothetical. It sounds awesome, right, in theory. Where's the prac? This is the practice. This is something tangible, right? Something that your developers can use. It's much more than a pretty slide that sells a great idea, right? This is tangible. So, you're building a catalog of vetted IAC model. Depending on your infrastructure is code framework, it will have different names like Terraform uses uh modules, CDK uses constructs, you know, different frameworks. They have different terminology, but the idea is you identify what your developers need and you modularize that. So why? Big question. Well, you know, the same reasons we're modularizing stuff, right? First of all, best practices. If you're creating something as a module, you can embed best practices into that implementation, and you'll, you'll see examples, don't worry. Reusability. If it's a module, you can reuse it across the whole organization. And the last one is composability. Once you have different modules implementing different functionality. You can start composing your architectures from these modules. So let's take a look at some code, right? Let's take a look at how this actually works. Uh, terraform, right? Uh, so a lot of people raise their hands. If you're at this point thinking, huh, this is one useless terraform script, like terraform configuration, you're kind of right at this point, we're going to evolve it, don't worry. OK, so I got variables, function name and runtime. We're talking about lambda here, and then I'm creating a resource, and I'm just using function name and runtime as variables. There is nothing fancy here at all, right? I'm just using variables to define the resource. But there is one interesting thing here. If you look at the left side, variable runtime, the default is set as node 20. So with this one single line, I can standardize the default runtime across my whole organization. It's kind of basic, right? It's pretty rudimentary, but what you're doing with this single line is basically you're saying my development teams, they don't need to make this decision, and this is just a simple example. That's the default that we've defined in our organizations. Let's evolve it. How about log retention days, right? You know that default, uh, you're probably, you know, familiar with that, the default retention for cloudWatch logs is forever. OK, forever means pain forever, right? How about you standardize it in a module, let's say 14 days again, arbitrary number, right? But basically by creating this very simple approach, right, you're saying, well, by default all the locks will be stored for 14 days and uh deleted automatically after that. Not a single person in your engineering teams need to know about it or worry about it anymore, right? Because that's the standard across organizations. A few more examples. I want a standardize login config, because previously every single team had different login structure, right? I think many of you can relate here, right? I want a standardized usage of lambda power tools, right, so I want every single function to have a specific library embedded. Now my developers, they don't need to worry what's power tools, which version do I use, right? Do I get it through ARN or whatever other way, right? You just standardized it. Uh, once you build this terraform module, you can package it. Again, I'm using Terraform as an example, and, uh, Ron will show CDK. We specifically use these two frameworks to show you, it's not about framework, it's about the approach. So you've created a terraform module. You called it my awesome enterprise lambda function or whatever, whatever you want to name it. You've defined what's the configuration variables, and that's something that your engineering teams can change because obviously they need to specify function name and memory size, etc. But you've also defined defaults for many of these parameters, right? So for example, if it's a Java application, probably a good default will be 2 gigs of memory, right? But if it's a Python, probably 0.5 gig would be just fine, right? For many of you it sounds pretty basic, but once again, your engineering teams don't need to worry about this anymore. Can they change it? Of course they can, but do they have to know about it? No, they don't. That's the beauty of it. And you're also gonna have some outputs. So, those are 3 examples of very real composable modules that we see across many customers, including in Ron's company, right? Uh, we already talked about baseline lambda function. So how about lambda function with periodical scheduler? Anyone here implements this scenario, lambda function with even bridge schedule, yeah, I see about 4 people. SQ SQ with redrive, DLQ with redrive. So this is not rocket science. You'll probably already implement this in scenario. Those are 3 patterns that I've implemented as, you know, modules, 04 modules, CDK construct doesn't matter. How do I change these 3 modules into an architecture? This is probably the most important part of this presentation. Do you know what's the difference between 3 modules in architecture? This, 2 arrows, right? Now it's an architecture. Again, 3 distinct modules. Architecture. OK, obviously, you know, I'm simplifying this a little bit, but now you can take composable components and build an architecture. So you can have, for example, analytics job. That runs once a day, processes data, throws that into SQSQ, and you have a lambda function processing the data from the queue. Every single component is, you know, implements best practices provided by the platform team. Development team don't need to worry about what's the best practice for using specific runtime or whatsoever. Uh, you would put those modules somewhere in the repository, right? It's quite flexible. It can be Git. It can be, you know, whatever you're using internally. We see Git as pretty popular because again, it's a tangible piece of code, right? So you would put it in, uh, some sort of repository and your engineering teams will consume those modules, right? If you use, uh, you know, pro, uh, you know, something like Terraform Cloud or Pullumi, they provide, uh, you know, explicit ways to distribute those modules, right? But the idea is your engineering teams consume those modules. Over time, since once again this is code and you're talking about engineering teams, they start contributing to these modules. So it's not like you as a platform team now responsible 100%. No, no, no, no, no, you can have social coding exercise. You can go to your engineering team and tell them you want an update, give us a PR, OK? An engineering team can start contributing to that as well, right? You don't have to start from scratch. There are a bunch of open source, uh, repositories again. You'll get these slides like in what, like 42 minutes, right? There are a bunch of open source projects that already implement modules, right, for various serverless components that you can either use as is or start building on top of, right? It's open source so you can take it, you can take the part that you like and add whatever is missing, right? So completely up to you. What's next? So let's evolve this idea. So we talked about uh creating those modules. Let's evolve it into architectural blueprints, right? Let's build something bigger out of it. Uh, for example, right, huh, I know my company. I've spoken to a few people in different parts of the company, and I figured out that this is a pretty popular pattern in my organization API gateway, bunch of lambdas, Dynamo DB. Anyone here using it? It's like probably one of the most popular patterns ever, right? Uh, so it's popular in my organization, meaning there are multiple teams that are using this pattern, and those teams are communicating with event driven architecture using EventBridge or maybe, you know, something else SQS so you have different parts that are doing the same pattern, right? And there is a mechanism to communicate between these parts. What does it actually mean? So these are the building blocks. OK, what's missing? Arrows arrows are as important as blocks because in serverless world you define these arrows also with infrastructurist code when you create event source mapping for a lambda to read from SQS, right, so those arrows are as important as blocks because once again you're responsible for defining those errors, right? You don't just give URL to developer and it's completely up to you, you know, developer to do whatever you want with that. It's also part of your architecture. Well, you know, it's common, it's useful. My engineering teams would love to have this as a pattern. I'm gonna call it a blueprint. This is my first blueprint, synchronous API with database, right? So whenever someone in my company needs to implement a synchronous A space synchronous API with a database, they can just reuse my module, and it will have all the best practices that I've implemented. Which best practices? Well, how about this? This is just like a small subset of what you can do when you're providing this thing as a module, right, as a platform team, you can preconfigure defaults, right, and enforce things for a lot of things on these resources. So now your engineering teams essentially getting that out of the box. Moreover, you can embed observability, security, best practices, etc. etc. end to end. Ron will talk more about that as well, right? Again, a few examples. How many of you ever experienced what we call orphaned resources? Resources that you have no idea who owns them, right? Oh yeah, that's like, I wish I had a dollar, right? How about you set default tags on that module, and now every single resource has an owner, right? And developers don't need to do anything, they need to know about it, right? Like what, 5 lines of terraform code, right, or CDK CDK supports that as well, right? You standardize this. Another problem, right, well, yeah, and then you can have development variables and production variables, basically injecting those values. How about you standardize your Dynamo DB security? You're saying that server-side encryption might always be enabled. TTL, must be enabled. Point in time recovery must be enabled. How many of your developers are even aware of the fact that Dynamo DB provides point in time recovery and they might need to use it? Now you standardize it. Security, if you have Dynamo DB as part of your module, right, instead of saying, well, I have no idea what's gonna happen there, we're just gonna give asterisk as permissions, right? Great, no, right, you can standardize that. So by default put item, get item, update item, right? If your developers need more they can update it, right, but by default you scope down the permissions to what you think is saying kind of good uh selection. OK, uh, we spent like what, uh, 23 minutes, and I never mentioned GEI, right, let's fix that. Bedrock, right? This is something that your customers, right, your developers, your customers might be using, right? So it's another component, frequent component in every single architecture today, right? And everyone is looking for answers. Uh, how do I properly configure it like, uh, context, size, which model do I use, what's the configuration for temperature, top P, etc. etc. right? Everyone suddenly needs to become LLM expert. Well, how about first of all, you standardize security. Right, it's part of your blueprint. You standardize that your, uh, blueprint has access to a specific model, right? So now your developers don't need to wonder, uh, which model do I use. This is what we use as a standard in our organization. Moreover, the configuration, max tokens, temperature, top P is also standardized. Can your developers override it? Yeah, easy, right? Do they need to worry about that? No, they don't. That's the difference. This is actually interesting because this is the first time. That you see function code, not infrastructure is code, but function code. That's a little bit different, right? Uh, so, as infrastructure team, well, not infrastructure anymore, platform, right? As a platform team. Are you saying that now in addition to being able to kind of define the architecture with infrastructureist code, we can also enforce things in the actual application code in the function handler, for example, and the answer is yes, right? So if you think about function handler, it has some business domain logic, right? Business domain code, but there are also some things which are not specific to a particular function, not specific to a particular handler. Like observability. How many of you are embedding some observability extension, for example, right? Do you want your developers to worry about that? Probably not. Some the way you do config or secret management, multi-tenancy, that's a lot of work that, uh, Ron and Cyber Ark did. Security governance integrations and SDK. There are things that are unique to this function, and that's handler, that's the business value that the function provides, but there are also things which are kind of more generic across multiple functions, and you can actually standardize that as well. And now you probably have a big question, but what if developers do want to make, right? I've just standardized everything with amazing defaults, and now I have a lot of developers coming to me saying, how do I override this defaults? Uh, you know, defaults are nice, but I need custom configuration, right? Obviously it makes perfect sense. So like I said in the beginning, you do want to give your developers this flexibility. You do want to allow them to change things, but. You want to allow them to change things within boundaries that you've defined, OK? We have this notion of, uh, you know, various controls, right? So this is in a nutshell kind of the standard again generalized a little bit, right, the pipeline of, uh, your application code, right? It starts with you write your code and infrastructures code commit build. Test package deploy run, right? So you have the phase where it's development, then you have continuous integration. This is where you build and test stuff through something like Jenkins, I don't know whatever you're using. Then you have continuous delivery where you're actually pushing that to the cloud, right? At any point in time here your developers might want to kind of change things that will customize things, right? They want flexibility because we started with flexibility. We provide this notion of proactive controls and detective controls, right? You're familiar with that. You've heard about that. So proactive controls essentially controls that, uh, well, proactive, right? They catch things before something happened, right? So for example, during the development phase when developer changed something, you want to make sure that. The change they made is safe, right? To give you an example, uh, let's say in your organization you want to define, you want to define, uh, what are the approved runtime. You wanna say, uh, we only approve like again arbitrary node and Python and only two latest versions, right? So whenever a developer decides, well, I've got to experiment with Java. Maybe, but at first they're gonna get an alert saying no, no, no, no, we don't do Java here. OK, again, just picking on a particular language, right, it can be anything, right? And then you uh evolve that. So, you want to have this proactive controls and detective controls at every single stage. Now, there are different tools uh to achieve that. Some of those tools are coming from AWS. Other tools are coming, uh, from, you know, other vendors. The choice of those governance tools are heavily dependent on your choice of infrastructure as code tools, right? So if you're using, uh, cloud formation. For example, you can use cloud formation guard. If you're using CDK, you have CDK Ng, uh, uh, amazing open source framework. If you're using Terraform, you got Hashi Corp Sentinel or Chekhov. Anyone using these, right? So what do these frameworks do, right? That's a really good question. So those are the frameworks that, uh, you know, I'm seeing pretty commonly. What do they do? Well, we'll take Chekhov as an example because we had a few examples of terraform codes. So Chekhov, it's a framework, uh, governance framework for terraform. So you can see here a list of controls that uh all of them are green, all of them have passed, right? that uh you know I validated before committing code so this is part of my local development experience, right? This is part of my CICD process, right? So first, before code is actually committed, I run checkup and it validates that my code infrastructures code is appli you know, uh, complies with all the rules that I've defined. And then the same thing happens in uh during CI process. Now what's going to happen if I'm going to introduce a change that is not, uh, you know, compliant with whatever guard rails uh that the platform team supplied. Well, this, right? So, uh, you can see here at the bottom, ensure that cloud watch log group specifies retention days, right? Well, because I accidentally deleted that property from my configuration, right, so now my logs are gonna be stored forever, right? And ensure Cloud Watch logs retains logs for at least one year. That's the default control that they have, right? So what it means is developer, right, they've made a change locally according to what they think they need, right? But that change, uh, you know, goes beyond what you think it should be allowed, OK? So they do have flexibility to make those changes. Changes, but you control what's the kind of the the the range of what is allowed within your organization, right? To give you a few examples, anyone here ever used lambda function running on OGS with 10 gigabytes of memory? Right, uh, why is it less common, right? It's perfectly fine, but why is it less common? Because at 10 gigabytes of memory, you're getting 66 virtual CPUs, and node by default is not gonna use 6 virtual CPUs, right? You need to write your code in a very special way for this to happen, right? So it's doable, it works, but you need to know about the fact that now you need to write your code in this specific way. So as a platform team. You're familiar with this, right? And you can write a rule that says if this is a node application, right, you can set memory up to 2 gigs, right? Why? It's a safeguard, right? Because you know you can set it to 10 gigs and you're gonna be paying a lot but not actually using that and if you need to exceed that, let's talk, right? Maybe we'll add one more property saying I know what I'm doing, right? Something like that, but essentially, you know, to summarize the section. Do your developers have flexibility? Yes. Do they need to be aware of everything that's going on under the hood? No. The cognitive load on the development teams is is significantly reduced. Right, so let's summarize the section, OK? Uh, platform team, they build and maintain those, uh, blueprints, they put them in some sort of curated, uh, blueprint catalog, right? Developers consume those blueprints. Over time, developers provide feedback to the platform team, right? So platform team can evolve those blueprints. Think of it as a product. It's a product, it's not a weekend project. It's a product within a company. If everything works great over time developers start contributing to those blueprints, right? Because this is the way developers can get what they need faster, right? You know the process you want it, we're happy to merge your PR over time you can have security and compliance team and whatever other teams you have in your organization actually bringing their requirements so now. Developers don't need to talk to security teams, right? No one kinda enjoys that, right? We have to, but no one really enjoys that. You can bake this into the blueprints, the requirements from security, compliance, uh, etc. teams. Now I've spoken for what, 30 something minutes, but I think you want to see how this actually works in production grade huge system. So I'm gonna pass it to Ron, and he'll tell you exactly that. Thank you. Everybody can hear me? Yeah. Happy to be here. So before we start talking about Plato engineering at SAA, I'm gonna quickly introduce you to what we do what we do at SAA. So SAA was founded in 1999, and we are the identity and access management global leaders. We have over 4000 employees across the globe and over 1000 developers, and we are a cloud native serveus first SAS company, and that's where I wanna shift our focus to. Now if we go back about 6 or 8 years ago, we had several cell solutions, but their experience was fragmented. From the developer perspective with multiple silos, so there was no unified developer experience, no tax stack, or even architecture. From the SRE perspective, again, multiple solutions. So again it was harder for them to support all our, our solutions. And for the customer experience, which is the most important one. Again, there was no unified experience. There was a different onboarding experience and the look and feel wasn't all the same. So in 2020 we decided to do better and we started our platform engineering team with 15 engineers, and I was one of those engineers and our goal was to basically unify all these experiences. Now fast forward to today and we're actually able to do that. We've streamlined our tax stack. We're using AWS, Serves, and Python. Um, you have a unified observability stack, unified customer experience on boarding, look and feel, and we've defined best practices for security, governance, and created multiple toolings. Now these toolings are used by hundreds of developers, and we saved with them years of development time. And from a humble start of 15 engineers, we are now well over 100 engineers across two divisions. Now our goal is basically to adopt and scale surplus across the organization, but we want to do it in a smart manner. We want to maintain standards and best practices for architecture, governance, security, and observability. Basically we want to help our developers and the organization to deliver value faster for our customers. So what we've done is build a service platform, and this, uh, platform basically encapsulates automations and best practices into blueprints like Anton has mentioned, and these blueprints are used by hundreds of developers. We've created dozens of services and we reduced the new service time creation by 99%. That's not a typo, that's actually real, and we're gonna see the numbers later on, and we're able to save years of development times and millions of dollars. So my name is Ron Eisenberg. I'm a principal software architect at Cyberark at the Plat Engineering division. I'm an AWS Serves hero, and I have a website called RuntheBuilder.cloud where I talk about AWS services, and platform engineering. So over the years we've created in the platform generic multiple SAS services, multiple SAS products across, uh, multiple planes. For example, in the application plan we've created our shell service, which is our UI which loads all sorts of I frames for the different SAS services that we have, and we've created an audit service which is a centralized centralized audit service that shows audits from all of our services. In the more traditional platform engineering plan, the control plan, we've created our tenant management service or the customer and boarding service, license services and such on. And even in the data plan, we've created our centralized pops up for service, uh, to service communications. But all of these services, they are built on top what I like to call the pillars of impact. Now this can be SDKs, blueprints, automations across very important and critical domains observability, security, governance, and automation and developer experience. And my goal and the platform engineering team goal is to help other teams at Cyber Ark, the other service teams to build their services and use and use the same pillars of impact. So let's talk about scaling enterprise grade solar services. How do we build them in a grander scale? So this might seem familiar because this is actually what we're building. When we start a new server service, we start with the back end service, and this is exactly what Anton was showing a couple of minutes ago. We have some crowd API or some entity. We have an API gateway that invokes a set of lambda functions that reading right from a download the B table. But they did mention that it needs to be enterprise grade, right? So now we need to think about all of these elements. Infrastructure is code. I need to write my CDK code with all the best practices to spin up all these resources. I need to have my pipeline take me from PR to production through multiple gates, multiple environments, dev, test, stage, pre-proud production. These are different AAS accounts in our case, and even multiple regions. We deployed to dozens of regions. Then you have learn the best practices hexagonal architecture, input validation, tene installation libraries that we've created at Cyborg. Then you have testing, unit test, integration test, and to end test, observability. We have numerous observability libraries, so it's a lot of work, right? And this is a very simple back end microservice. But it doesn't stop there because we also need a user interface. Think of this new service as a single web page application. You have a table that shows items from the back end you can read, write, and change the items. So we're gonna add the cloud for distribution. We're gonna add our S3 bucket with the static react files. But again, we need all the best practices, the infrastructure is code, our CCD pipeline. Our front our front end best practices, we need to think about input validation, our integration with the back end, error handling, accessibility, testing, local host testing, Cypress, playwright implementations, and even telemetry. We're using mixed panels, so now we need to add our mixed panel SDK so we know what our customers are doing in the UI, so we know which feature we want to, uh, implement more and expand and which we can drop. And I did mention that this is a SAS service, so it gets even more complicated. So now we need to integrate with our SAS control plan, and at Cyborg that means we need to integrate with the tenant management service. We need to have our own sub-domain for our service, our own host name and cer certificate for our customers to, to send our uh to send our, uh, our service API requests. And we need to have cross-account access. Maybe we have some SQS that needs to subscribe to an NSNS topic in a different account. Or maybe we need to do role delegation and assume a role in another account to access an ironprotected API gateway. These are things that we need to do out of the box. So what I'm trying to say here is that enterprise grade is complex. It's complicated. It's a lot of work. One microservice is just not enough. You need multiple of them, right? You need to integrate with other sales components. You need to deploy to multiple AWS accounts dev, test, stage, people, production, multiple regions, and you need to do, to do all of these by following service and enterprise best practices and libraries and tooling. So before we had our amazing automation and tooling, we saw from surveys and estimations that it would take a senior engineer about 5 months or 23, 25 weeks to implement these microservices with all the tooling and all the SDKs and all the best practices out of the box. But now that we've created our automation, it takes about 3 hours, just 3 hours. So let's see this automation in practice. Let's see the developer experience. So our goal is to build a new service, the one click service, and it's going to have our cloud API, all the best practices, our front end, the cyber unified UI, the look and feel, and we want to connect it to ourA control plane right out of the box. So all of these things are going to be part of our new service. So for us, it always starts with a developer portal. For those who don't know, this is port. We're using it it's a service that we integrated with. You go to self-service in the in the top, you click and then you choose. Uh, create new business service and you have this form. So now you need to choose your service ID in the sales control plane, your service name. It appears for in, in the customers in the UI, uh, your name, your getup organization, and things like that, and then you click on start. That's where the magic happens. And then 3 hours later, you are greeted with new components and integrations that are provisioned. We have 6 new GitHub repositors that we scaffolded and deployed to AWS. And now all it takes is to create a new tenant with our new service and log in as the customer and see the new service in action. So here we can see the new service in the cyber UI. And you can see on the left we have the application picker, our SAS application picker, and we have our new service with the default icon. But here in the middle we can see all the items from the back end. So we fetched all the items from dyno with the B table, so it works. Our integration works, and even in the in the title where you can see FF enabled, that's actually a feature flag that we got from app config via the backend API calls. So what did we see? So we saw 6 blueprints. They have all these best practices security, observability, all these toolings that are baked in. We have our front end, our back end, our feature flex configuration, our cloud distribution, our tenant management integration, etc. and these are all deployed to 4 different AWS accounts dev, test, stage integration, where integration we deploy to 2 regions out of the box. Now, from the developer perspective, that's amazing, because now they get all this heavy lifting out of the box, and they can focus just on the business domain. They can take what we built, what we gave them, and just expand on that. As Verner says, go build. Now these are some uh basic automation developer experience tips from our use cases. Your, your automation needs to be simple to use with minimal prerequisites, and I cannot stress this enough, minimal prerequisites, otherwise people will get it wrong, get confused, get very frustrated. It needs to be retryable because people do make mistakes. It needs to be customizable because one blueprint will not fit everybody's needs, and you need to have the ability to delete failures. You also need to have ongoing maintenance on all the blueprints, but not just a single blueprint, but the entire process. You need to create all these one-click services from time to time, so you can see that this process runs from the from the beginning to the end. So now I want to talk about architectural blueprints, which are a different type of blueprints. So as Anton mentioned, we're using CDK Python and in this example we're using, we're creating a Python library that contains CDK constructs that encapsulate these black black box architectural patterns, and these are versions we have GitHub pages so we document them and we have release notes around them and they're easy to update and use. So a few examples we have our lambda function with dynamic provision concurrency, meaning the provision concurrency setting goes up and down according to traffic shifts. We have a secure STV bucket which is basically a bucket that our security architects give us the thumbs up on it on its configuration. We have the classic SQS and dataQ. You gotta have those. We have our CMK and KMS where we can sign. And encrypt messages we even have we even have a dynamo DB table uh that works seamlessly with our tenant isolation library for uh potency use cases and we have our WAF ACL association that knows how to connect to our, uh, WF that came from our firewall manager from centralized firewall manager. So this is an example of actual code. This is code that I copied from one of the consorts. It's a very simple construct. It's our S3 buckets that we use across the organization. So you can see that in line 13 we enforce the SSL communication. We set the removal policy to retain in production environments because we don't want to delete our customers' data by mistake. We block public access and we enable encryption. It's very effective and all the, all of, all of our developers can use it across their services. Now, it's 2025 and things are changing as you've noticed, and also the platform engineering domain is also evolving. Now, If you recall this diagram from before, I'd, uh, I'd argue that now in 2025, we need to add another pillar of impact. Yes, it's agentic AI. Now, let's think about the following problem, and this is a real problem that we have. So we have a requirement for 3 of our developers, 3 or 4 developers from different services to build an MCP server and to expose their service API through that. Now, it might be fine, but what's the problem here, right? So the problem is that they need to reinvent the wheel basically. It's a new world. It's a new domain. You need to think about authentication and authorization, and they're doing this all in parallel, right? CDK. They need to write the CDK. They need to write the CCD pipeline. They need to learn how to test with MCP MCP clients to figure out observability. So this can cause duplicated efforts, architectural inconsistencies, and maybe even tact that. But there's a better solution, a very simple solution. Let's use platform engineering blueprints. So this is something that I actually have the pleasure of writing and open sourcing, by the way, um, so we have our own MCP server blueprint. We have our Amazon API gateway with a WAF connected to a lambda function, uh, that runs the lambda web adapter extension. We run the Python fast MCP server and then we have some examples for MCP tools and resources that our developers can use, extend, do whatever they want with them. But on top of that, you get infrastructure is code, CSCD pipeline, security best practices for this new domain, testing, and observability. So now, for our developers, they can just scaffold this blueprint. And create their own new MCP server, and that's great. They get all these toolings out of the box and it's easy, easy to use. Back to you, Anton. Thanks, Ron. Things. All right, yeah, so you saw a real world implementation, right, of what these practices look like. Uh, you probably noticed that it takes time. It's not perfect, you know, it's not something you do within, you know, a few days, right? It's a process, you know, you evolve over time. You add more functionality based on what your consumers, your development engineering teams are looking for, right? So some best practices that we've seen as very efficient when adopting this approach. Don't boil the ocean, right? Do not say I'm gonna solve all the problems in the world with my blueprint. Identify a problem that is, you know, the most impactful in your organization, right? API gateway lambda dynamo like 70% of teams are using this. Let's standardize it and let's provide flexible, uh, customization for that, right? Identify what you can solve realistically, not something that will take 2 years to implement, right? Solve that problem, measure success, evolve, iterate, right? You'll probably notice it sounds like building a product because it is, right? Don't treat it as a weekend project. It is a product you've noticed like. Over 100 people working on this. Started with 15. Over 100 people are working on this now, and they're saving years of developing time for the whole organization. So focus and prioritize, right? Don't spread yourself too thin. One size doesn't fit all workloads, right? Obviously, your amazing blueprint will immediately get feedback from engineering teams, and no, we cannot use that for whatever the reason is, right? Trust me it's gonna happen, right? Listen to this feedback, ideally collect it early, right? And make sure that you, uh, address it and you provide customization, right? So for example your teams, they wanna be flexible on the runtime, cool, they wanna be flexible on TLS. Configuration awesome, right? Collect that feedback and implement it into your blueprints because there's never gonna be a product that is suitable for 100% of consumers, right? I'm not familiar with such a product, but try to cover large scope and make your, uh, blueprints customizable. Documentation and education are key, right? So you're building a product for people to consume, right? Make it easy to consume, right? Dropping a piece of code on GitHub and saying go clone it, that's not good enough, right? It might be good enough for a very small part of your organization. But if your engineering teams need to invest more time into understanding your blueprint than building it themselves, that's not gonna work. Make it easy to consume, set up education sessions right in your organization, right? You're building a product you need to prove the value of that product, right? Is this approach working the blueprint? Yes, it does, right? We have examples, right? But you need to make sure your organization is educated and they know how to use it, right? Uh, the good thing is generating documentation with Gen AI today is really, really simple. This is probably the most important thing, right? If you believe it's, if you believe in uh we're gonna build it and the users will come themselves, well, no, right? Build with your customers, right before you start building, validate that this is actually solving a real problem, right? Don't try to talk to every single team again, don't boil the ocean. Find a small subset, go to them and say, hey. I think I have something that you know you will benefit from, right? and we can work on that and start kind of solving your problems so build with your customers in this scenario customers are the engineering teams that you as platform uh engineers are, uh, you know, trying to help, OK? These are the general best practices that we've seen that actually work quite well when starting to adopt this approach. So with that, uh, we have several other, other sessions that uh we would like to recommend. Some of them are actually in the past, but it's all gonna be on YouTube, OK? Uh, there's one, yeah, uh, on Thursday, right? Uh, if you're not familiar with Servius Land, right? Anyone here familiar with Serveless Land? This is a website our, uh, mostly developer advocacy team maintains. It has a lot of templates, blueprints, tutorials, right, hundreds of things that you can use. Right, so I highly recommend you explore that one. We have weekly office hours on YouTube and Twitch, so there's, there's a lot of good information there, and, uh, me and Ron gonna be right here if you have any questions, uh, you know, we're not gonna run away. We're happy to take any of your questions once we're done in about 30 seconds. The last thing I promised is giant QR code with everything you saw today source code, slides, everything, right? Videos, uh, etc. Don't forget to complete the survey in the application, and we hope this was helpful. Thank you.