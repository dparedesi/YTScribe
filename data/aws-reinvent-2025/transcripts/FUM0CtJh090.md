---
video_id: FUM0CtJh090
video_url: https://www.youtube.com/watch?v=FUM0CtJh090
is_generated: False
is_translatable: True
summary: "Ben Kehoe, a Serverless Hero and Distinguished Engineer at Siemens, delivers a thought-provoking talk on the \"Builder's Mindset.\" He challenges the traditional ways developers identify themselvesâ€”often through their tools (e.g., \"I'm a Java developer,\" \"I'm a VI user\") or their outputs (e.g., \"This code is my baby\"). Ben argues that these identifications are limiting and brittle, leading to resistance against change and \"Not Invented Here\" syndrome.\n\nInstead, Ben proposes a shift in mindset: focusing on **outcomes over outputs**. He asserts that builders are not artisans; while code can be beautiful, its primary value in a business context is its utility, not its craftsmanship. He introduces the concept that **features are assets, but implementations are liabilities**. Every line of code written is something that can go wrong, has to be maintained, and costs money. Therefore, the goal should be to deliver the feature (the asset) with the minimum viable implementation (the liability).\n\nHe frames this mindset through three questions:\n1.  **Who am I?** Instead of defining oneself by tools or specific outputs, one should identify as a **problem solver**. Building is just the mechanism used to solve problems, but if a problem can be solved without building anything (e.g., buying a commodity solution), that is often the superior choice.\n2.  **What do I do?** The answer should be \"I create outcomes,\" not just \"I write code.\" This perspective helps developers understand their place in the larger value chain, connecting their work to customer needs.\n3.  **How do I respond to change?** By not identifying with outputs, deleting code becomes a \"joyous act.\" When a feature is no longer needed or can be replaced by a managed service, a builder should happily discard the old implementation because it removes a liability from their balance sheet.\n\nBen also discusses continuous deployment as a forcing function for accountability and humility. Committing to deploying constantly forces one to be good at testing and rollback, acknowledging that perfection is impossible. He touches on the role of AI, warning that while it can generate code, accountability still rests with the human. He observes that AI currently benefits senior engineers more than juniors because seniors know what \"good\" looks like. Finally, he urges builders to consider Total Cost of Ownership (TCO) in technology selection, recognizing that maintenance costs usually dwarf development costs, and that sometimes doing something the \"hard way\" (like learning Step Functions in 2017) pays off in long-term stability."\nkeywords: Builder's Mindset, Outcomes over Outputs, Total Cost of Ownership, Continuous Deployment, Tech Debt, Serverless, Problem Solving, Software Engineering, AI in Development, Engineering Culture\n---

All right. Let's get started. Uh, welcome everyone. Uh, my name is Ben Kehoe, and here to talk today about, uh, what it means to be a builder. Uh, how we should think about being a builder, how we should think about building. Um, I am an AWS serverless hero, and I am a distinguished engineer at Siemens. Uh, This talk is a lot about uh feelings and thoughts. And so for that reason, the slides, uh, don't contain a lot of, uh, a lot of material, you know, I could have asked AI to put together some images for me, but they don't really mean anything to you, I think, um. So as we go through I wanna start with what a mindset is when we when we talk about this because this whole talk is about what a builder's mindset should be, um, how we can have that for better outcomes and so mindset is about how you approach the world, right? It's both your explicit way of thinking about things and your implicit way of approaching things. And So there are a few different questions that we can ask. Um, to reveal mindset because it's often not something that's particularly apparent to us. And so one of the first questions that you can ask is, who am I? Right, who is it, you know, and in this room, I would suspect that most people would say I am a builder, or I'm a developer or I'm a coder or a programmer. And this is a question of identity, right? It's about what label you're choosing. And identity is about choosing the difference between you and and some other label, right? It's, it's saying I'm a builder and that is different from people who are not builders, but that doesn't really reveal much about what the mindset is or what it means to be a builder. You can identify, oh, I think these people are builders, but it doesn't really show you the explicit what it means to that. So I think often a more useful question to ask. When defining and investigating a mindset is to ask what do I do? And that turns that from a question of identity into a functional question. What are the tasks I carry out? What are the ways in which I interact with the world? How am I changing the world? How do I approach changing the world? And that's an easier question to answer, I think, and then that leads into um what that mindset is by how you approach that. The final question is, how do I respond to changes, right? When you ask, what do I do? That's a snapshot in time. And that's interacting with the world at a particular point in time. And the world changes and interacts with you, and your response to it is also part of your mindset, right? How you deal with those changes, how you try and resist them or go with them. Is all part of, of your mindset. And so you might ask, you know, I mean, you are here, so you seem interested, but why, why have a talk about the mindset? Um, and why is it useful to discuss this here? And I want to do the obvious thing. For answering this question, which is to talk about continuous deployment. Um, So an analogy for me here is that continuous deployment, so, uh, one of the reasons you do continuous deployment, right, to say that every commit will end up in production automatically is to get faster time to value, to get better, you know, faster feedback from your customers. But even separate from that, if you just look at it as part of the software development life cycle. The things that you need to have to make continuous deployment successful are all things that you want to have as part of software development in general. You have to have good tests. Having good tests is a useful thing to have, even if you're not doing continuous deployment. You need to have safe and effective rollback. Also useful no matter what your deployment strategy is. However, with continuous deployment, it becomes a constraint and not a choice. You are signing yourself up to have to be good at testing. You're assigning yourself to be good at, have to be good at mean time to resolution in a way that you are not in other modes of deployment. And so I think about this as a form of accountability and humility. Right, that you are saying I want that I'm, I'm forced to be good at these things, right? This is why, you know, people say don't deploy on Friday and other people say no, do deploy on Friday because you want to make sure that deploying on Friday, if deploying on Friday works fine, then deploying every other day is going to work fine as well. If you are saying I don't trust deploying on Friday, it's because you also don't trust deploying on any other day. And so if you force yourself to say, I'm gonna, I'm gonna deploy on Fridays until it doesn't ruin my weekend, you're holding yourself accountable. And to do that requires humility, right? It requires that you say, oh, I'm not going to get it perfect, right? My testing is never going to get 100% of things. So things are gonna slip through, that's why I have to be good. At rollback, right, that my, when I write the software in the first place, I'm gonna put bugs in it. That's why I need good testing. Um, and a similar form of that is, you know, you build it, you run it as a, as a model for operations, right, that when you have separate dev and ops teams, one of the things that can be challenging about that is that the operations team is accountable for running it, but they're not responsible for the software, the quality of the software that goes into it. And so you can end up with software that's being created that is hard to run, whereas if the same team is responsible for operations, well, that accountability lives in that place and even when you look at SRE models. SRE models include usually that there's a minimum bar for the quality of the software that an SRE team will run. And if that borrow is not met, operations goes back to the development team. So the development team has to be prepared for you build it, you run it. Because they will be held accountable if the software quality is not high enough. The other thing to talk about as an analogy, I think, is blameless postmortems. That, uh, the reason that we do blame this postmortems is not that there is nobody to blame. Because sometimes there is, but even when there is, we don't. Is that what you want to do is find out why. And if you are blaming people, then you will not find out why. And so you're prioritizing introspection. Um To say we really want to understand ourselves, our process. And I think both of these things, well, all three accountability, humility, and introspection are. For the same reasons that they're useful in your software development life cycle are useful to apply to your mindset to understand. Why you are doing the things that you do, why you think the things that you think, and then also to hold yourself account to say, I believe that the way that I act. Causes certain outcomes, right? That when I go and change the world in a certain way, it works in the way that I expect it to. But you want to hold yourself accountable just to demonstrate that that's true. Now one thing that I do want to note is that humility and self-confidence are not mutually exclusive. Um, I think humility and ego are this is sort of where ego is saying that whatever I'm defining to be true or good about myself, I hold to be inviolable. Like I, I, um, I believe that that is always true and any disagreement with that feels like a threat to me. Self-confidence is saying, here are the things I believe to be true. First of all, they may not be true, and I hope to find out if that's the case, but also even for the things that I am good at, I can be better. There are things I can improve, and that's the humility that you can have while you have self-confidence. So that's, uh, um, I think an important note about, about that. So we can ask what are typical mindsets that we see in builders. Um, and there are a couple of them that I think will be familiar to everyone. One is identifying with your tools. So these are both the things that you are using the technology that you're using to build. And the things that you use to build with, so the technologies in your application as well as the developer tooling that you're using, right? A classic one going back a very long ways is VI and Emacs and the reason that there are so many flame wars over that in the history of, of software is because people. Turn it into a part of their identity. I am a VI user. I only accept VI key bindings or I'm an Emacs user and someone else saying that they like Emacs is then a threat to my identifying with VI as the solution. Right, but this also goes to the technologies we build. We say, you know, I am a postgrads database admin. Or I'm a SQL, you know, I'm a SQL developer or NoSQL developer, right? All of those things become part of who we are or not. I am a developer who primarily uses SQL databases, for example. And so I think people are familiar with that. The other one is identifying with your output. This is the thing where I have created something, and it is a part of me. All right, this is my baby. And not invented here syndrome is a familiar uh manifestation of this, that again, it is something that you have created and you believe it has value. And if someone else says it is not useful, that then feels like a threat to yourself. Um, Now, I think um. Another one that is a little more subtle. Is being isolated from a greater purpose. And so this is often a reaction to the context that you're in. But that often you go and look and you say, well, what do you do? And, and the answer is very narrowly focused on the surroundings that you have. And you say, oh well I create this to deliver to this other team. And not this is my part in the bigger organization. This is how I fit in. This is why customers would care about what I am doing. And that can be because that's not visible to you. That can be because that purpose is ambiguous in your organization, possibly contradictory. Right, there can be lots of reasons, but that you start to narrow down what you understand and the boundary with which you define yourself. And so we can ask then. What a better mindset is. And so to do this, I think we ask those questions again. And we start with what do I do? Right, and how do we want to answer this question? And how do we want to maybe change away from identifying with our tools, from identifying with our output? And so one of the really important thing. Is that if we look at what we do, we are not artisans. Writes that for a long time software was very hard, and it took people who were. Deeply experienced and deeply capable to create any software at all. And that it meant that it was something that required this depth of experience, this care in creation. But that isn't true now, and it hasn't been for a long time. It is easy to make software, that doesn't make it easy to make good software. But it's easy to make software. And we're lucky in that the things we like to do on the weekends are also something that we can get paid for. It's not true. I mean, I don't know many HR people who spend their weekends putting together comp plans for in their spare time, um. But that's tricky too, because then we often expect that what we're doing at work looks like what we're doing when it's a hobby. And the the reasons that we choose to do it as a hobby and the reason that somebody might be paying us to do it are very different, right? Um, I think an analogy that I like here is that is very difficult and very expensive to make a mechanical watch. That keeps time as well as the cheapest watch you can get from Walmart. And through that difficulty, It can become an object of beauty. People can say, oh, I like this watch, specifically because of how difficult it was to accomplish this task. Or you can say because it's so expensive, this is a status item, and so I want this because it is so expensive. You know, you look at sculptors, sculptors are creating something that usually has no utility itself. It's not a tool of some kind. It is not meant to be used. It's meant to just be an object, and that has value and people pay for that. I've never seen software that works like that. I've never seen someone say, oh, this, this software was made in such a difficult way, I would pay more for it. Than the alternative. Um, and generally paying a lot for software is not a status symbol. That's not entirely true. Sometimes you get software that, you know, the only way to use it is to have some minimum spend or, you know, these kind of things. So there are places where you can say, oh yeah, I'm in a special club because of the software that I'm using, but it's very rarely about how it was built. And so when we think about that, when we think about, OK, so the building of it is not the thing. The focus for this mindset. Should be on outcomes over outputs, right? It is not the thing that you create. It's not the building that you that you have that is the purpose, but rather the thing that it does, right? That contrast with the sculptor. The sculptor is creating something that is not meant to be used in general, and it's the exact opposite. If you create software that is not meant to be used. That's generally not a useful piece of software, right? That's not something that people want, um. And so we want to focus on what is the thing that it does over the thing that it is. Which mirrors that question about what do I do versus who am I? And so one of the things we find in here if we think about outcomes and outputs. Is that when we talk about a software feature, the feature is the asset, but the implementation is a liability. Right, if you think about your software implementation of a feature. At best, in a perfect world, it does exactly. What you expect it to do. And everything about the real world is that it doesn't quite do exactly what you expect it to do. The only thing your implementation can do is subtract value from the feature. And so when you think about it that way, the thing that you are creating, with the feature is still something that you are creating, that is a creation that you are doing. But it's the feature that is the valuable thing. And the implementation that you had to do to create the feature is not the important thing. And so that's the job, right? The job is to build features. And so we want to stay focused on that that's the thing that we do. And when we think about outcomes. That also allows us to ask that question about, um, our place in the organization. So in Um, In the organization when you say, well, I've built this thing, I talk about the output. I get to the point of saying, OK. But how does that sit within the broader organization? How does this serve the customer? And it's hard to answer that because you go the next step in the value chain, you don't really understand what that output is, is meaning, uh, what, how that output is meaningful. On the other hand, when you talk about the outcomes, you say, well, you know, I'm somewhere deep in an organization, building something for another team that builds something for another team that builds something for the customer. But when you talk about outcomes, you're talking about what that next team is doing. And what that next team is doing, the outcomes that they need are in service of outcomes that are for that next team, and eventually you get up that chain to the outcomes that matter to the customer. And so you can trace that more easily back to the thing that you were doing. Now again, this depends on the visibility, it depends on your organization having clarity of what it is that you should be doing for the customer and all of these kind of things. Also requires that you have clarity about what the customer's needs are as well. Right, there's this, uh, old saying that people don't buy drills, they buy holes. Right, that when someone is, is, is looking for, um, looking for a drill, what they really want is a hole in something. And they need a tool that will accomplish that, right? That is the outcome and the output. The output of the drill factory is the drill. Um, But knowing the hole that you need is often very clear. But often when you talk to customers, their needs are less clear. And sometimes you take them at face value and you say, all right, whatever they told us, we will go do. But you can also look at what the outcomes that they're trying to accomplish are to dig deeper and not just take what they have decided is the solution. You can work with them to find how do we produce the outcomes that they want better with potentially something different from what they're asking for. So then, when we're focused on outcomes. When we're responding to changes, again, because our place in the value chain is more clear. It can be more apparent how these changes affect us and how we might change within them. So, uh, if for example we say, well, the customers have different needs that they have, we have different outcomes that we want to produce, OK, so you're thinking about the whole value chain shifting in, in some way, and that's going to come back to your part of it at some point. And you can understand how that shifts, or maybe that's staying the same, but exactly how that value chain is constructed within your organization is changing, but you can still understand, oh, this is how I'm fitting into that bigger picture. At the very least you can ask to say, I don't understand. I'm not getting that picture. Please help me understand. And then that can help you understand what the output that you need to create those outcomes are. So we come back to this, who am I question finally. And the important thing, right, that we've said here. Is that you are not your tools and you are not your output. Those things are not you, those things are things that you have created. But they're not you. And what I would argue, the way to understand it is that builders are problem solvers, right? The thing to be done is solving a problem. The main tool in the toolbox is building. But if you can solve somebody's problem without having to build anything, you have solved that problem better for them. Right, that having to build, that's the implementation that comes with the liability. The problem that you're solving in the future, that's the asset. So we can talk now about how to apply this mindset. Right, how do we take A focus on outcomes and not on outputs to the things that we do as builders. And so the first one is to talk about technology selection and again this is where we talk both about technology within our applications and the developer tools um that uh we use to build those things. And as we said, we don't want to identify with those tools, so we want to view them as a means to an end. And understand ourselves as adaptable. This is sort of the thing is when someone says, oh, my, you know, dev setup has to be a very particular way, otherwise I can't accomplish anything. That's very brittle, and we don't want our systems to be brittle. We want our systems to be flexible. And we want that we have an abstraction over those things to say there are different ways in which I can interact with the things that I'm using to bring the same, uh. Uh, To bring this The same output Um, are the lights changing? Is something changed, sorry, um. Uh, that the, um. Uh, bringing the output to uh. With those different tools. So the thing to focus on is total cost of ownership, always, right? Whenever you talk about, well, this is what the consequences of a decision are. You need to make sure that you are not talking about those consequences very narrowly, right? And that's the total cost of ownership for you, for your team, for your organization, for your company. You want to look at all of those and how they balance out. And I mean a classic case of this is um. That, uh, the. AWS bill is only part of the cost of the system that you have built. It's very easy to say, I've built something that runs very inexpensively on AWS and takes a whole lot of operations time to keep afloat. Or alternatively, something that runs very, very well without interference, but. Costs a ton of money And neither of those are inherently bad. But you want to make sure that you're balancing that out, and that's something where again, Those are not equal dollars when you are doing that calculation, right? When you go on the balance sheet, the headcount cost and the OPE on the AWS bill are not things that are completely fungible. And so when you do that calculation, you have to trade off in that complex space. And of course, For the code that you write, almost always you run it a lot more than you build it. And so often the right trade-off to to make is that you want to optimize for the ongoing cost of maintenance and operations rather than the cost of development. And one thing to think about here. Is uh. Is tech debt. Because we talk about tech debt as something that's inherently bad. Whenever people say, oh this will create tech debt, we mean I don't wanna do that because it's gonna create other work for me later. But if you go ask Your finance person, whether your company should have no debt at all, they will say no. Debt is useful, that is leverage. And so you don't want too much of it, but if you have none of it, you are not moving fast enough. And so you want to understand tech debt in that way to say, I can strategically take on tech debt when it accomplishes something for me that is valuable. If I can get to market 6 months faster. While understanding that it is going to be expensive to run or difficult to run or whatever it is, and you have a plan. To both stay afloat, pay down, you know, pay the interest, as well as fix it in the long term, which is paying down the principal. That can be a good choice. Other times you wanna say no, that's not the right thing, let's let's bite the bullet and we'll do it the right way, but you can have those conversations, um. Intelligently to uh to make smart choices about what you're taking on there. Um Now the next one I think is probably the. Um, Least fun slide of this whole deck, which is that the feeling of productivity. is a poor proxy For actual productivity. Right? If you think about what feels productive to you when you are coding. That feeling about your outputs. You say, oh, I'm really effectively creating code today, or I'm really effectively accomplishing this task. But whether that task is useful, whether that code that you are creating is the right thing to create. Is not something you feel. When you are writing it And so Because your feelings about, like in that moment, in that flow state are about outputs and not about outcomes. That's where you want to be very careful about assuming that something that feels unproductive. Asserting that it's actually unproductive, you wanna go look into that. And the story that I always tell about this is, um, a very long time ago, say about 2017. Step functions was hard to use. Um, it's no longer the case, you know, you can write in YAML, you've got a visual builder, got Jason Mata for manipulating the state. You've also got, as of, uh, two days ago, yesterday, yesterday, lambda durable functions, um, to, uh, as an alternative to use familiar general purpose programming languages, uh, for defining workflows. But way back when there were step functions, you had to write it in JSON, you had to use this awkward JSON path thing. The documentation wasn't great, um, your ability to figure out how to make it work correctly. Was limited. However, if you spent that afternoon struggling with it, wrestling with it, getting it to that point. To which it worked, you would often end up with something that you never had to touch again. It just worked. If you're using it for the use cases that are solidly in that step function sweet spot, the scaling is fine, all of the things are fine, and it just ceases to be something you even think about, which is not the case if you build that in a different way, right? There will be something to maintain, something to update, even if it's automated, even if you have it, part of a pipeline that periodically refreshes or whatever you, whatever you want, is something that will occupy a corner of your mind and occasionally go wrong. And so spending that time with step functions was almost always worth it for that reason. Now, you don't want to live with that forever. You want that it gets better like it has. And now I can talk about it as an old man, talking about the, the bad old days or whatever. Um, but, uh, uh, that's one of those things where it didn't feel productive, right? It didn't feel fun, it didn't feel, you were never in a flow state. In in those times trying to figure out why your JSON path wasn't working correctly. But that's the sort of thing that requires that humility to say, It's not fun. But the total cost of ownership of this decision of doing it this way is gonna be much lower. And so I'm gonna go do it that way because that gets us the outcomes we want with the outputs that we want. So that's about technology selection and again that's sort of a snapshot in time and the how do we respond to changes. Is about technology transformation, right? What happens when. The context changes, the requirements shift. And uh. We have to, we have different needs coming in and different outcomes that are desired, or, uh, a different situation that we're in. And this is again where not identifying with your output. Is the important thing there, because often you've built something, it was useful when you built it. It was the best thing, it was the right thing, and you did it really well when it was needed. And now it might not be needed. And the hard thing is to say, OK. That thing goes away. Right? You're used to that, you're familiar with it, you invested so much time, your blood, sweat and tears went into it, and throwing it away feels like throwing away a piece of yourself. But that's your output. You are not your output, and that thing is not you. And if it's not useful, you can go do a different useful thing. And so this is where I say, Throwing away code should be a joyous act. Right? That when I have something that I've made, an implementation, right, that can only be imperfect, that served a feature that either that feature is no longer needed, or maybe that feature is needed, but there's now a third party commodity that I can just buy to go do that thing or an AWS service that now does the thing that I managed to Frankenstein a couple of different AWS services together to do. And now I get to say, all right, that thing is no longer on my plate. It can no longer be a liability on my balance sheet. And I can go create something else. That's why we want that those, you know, and you see people post about poll requests and they, they highlighting. You know, the number in red. And how happy they are about that, and that's, I think the mindset that we want. So then we have organizational transformation. Which is A few different things, right? That can be reorgs, but that can be that your organization is trying to do different things. It's trying to do things in a different way. It's trying to transform in some way. And again, that's where understanding your place in it, having that view of these are the outcomes that I'm currently providing. And also these are the outcomes that I think I'm capable of. Right, becomes useful because if you are not your tools, then changing what tools you're using. Changing what you're doing, changing the things that you're using to create output to create outcomes. Allows you to be resilient to changes in the organization. Right? And you can say, for example, that you might be moving up the value chain, right? Or you may be moving into a different value chain to understand, you need to understand, oh, here's the new way in which I'm serving the organization. So having that view and understanding yourself in terms of your outputs rather than, than, or sorry, your outcomes rather than your outputs. Um, becomes useful there. The final one here, I feel like it's obligatory to talk about the impact of AI. Uh There's a few things in here. That uh are worth talking about. So the first one is that shifting responsibility to AI. He's not shifting your accountability to AI. writes that currently. If you're using AI and the AI gets it wrong. That accountability still lies with you. And that's something you have to understand, right? So, again, you're looking at those outcomes, you're saying this is a tool, right? This is a thing that I'm using that is producing something. And one of the things that we want to do in that is apply the same thinking into the things that the AI is doing, right? One of the things that I see a lot that people talk about, you know, code generation, and they say, oh, it's gonna write all this boilerplate for me. We should still be asking the question, why is that boilerplate necessary? Right, because if there's boilerplate in it, that it's generating, it can still get that wrong. If we're able to change the underlying things, the libraries, whatever it is, to reduce the boilerplate, that's a thing that it can't get wrong anymore. Right, in the same way that it would work, work for us, that if there's less code to be written. There's less things you can get wrong. And so I think that's true in general of when we think about how we want to set up our systems, our agents. Is to make sure that we say, if we can have them doing less work, right, if we can have them creating the features with smaller implementation. Then they're going to more often get it right. And that's a value to us, right? We want them focused on outcomes and not on outputs, because the more they're focused on outputs. The more they are going to, uh, get things wrong, not because they're AI but because. Humans also get things wrong, right? It's inherent in creating stuff that that things will go awry. I think, uh. That as we see them get better and better, right? That at some point there may be a time at which the accountability can live with them. I don't know what that looks like, uh, but I think we're far enough away from it that we should assume that the accountability lies with us. And this accountability lying with us has an interesting consequence. Which is the difference between AI in the hands of a senior engineer and AI in the hands of a junior engineer. One of the things that most new technologies have done through the history of humanity really. Uh, although I'm gonna say this in terms of engineers which have not always existed, so, um. Uh, but in general allow like junior engineers to compete with senior engineers, right? There's something that the senior engineers had to worry about that now something has come along and said you don't have to worry about that anymore. So now, uh. A junior engineer has the skills that they can apply to have the same outcomes as a a senior engineer. AI doesn't really work like that at the moment, right? AI because of that accountability, you need someone who knows what good looks like to be able to tell when things are going wrong and how to fix it. But those junior engineers don't have that yet. But they're using a tool that doesn't enable them to learn it because it's doing it for them. So they're not going through that process and so We find that that AI is more effective in the hands of senior engineers than in junior engineers. And eventually those people are going to retire. And so we have to figure out ways and we have to bring that mindset in as as junior engineers to say we need to figure out a way to get trained up on these things, to understand the things that we need to understand to effectively use AI to do this while also balancing that while it's doing it for me, maybe I can get away with not understanding it. And this leads into the the next thing which is of course that high quality software. Is not the point. The amount, the level of quality in software. Is something that is part of a business need. There are places that need extremely high quality software and places that things can be extremely buggy and it's still fine. Um, And AI changes the cost quality curve. Across that, because if you look at vibe coding, vibe coding can get you something that works at an extraordinarily low cost. But if you look at making very high quality software, AI can lower the cost of it, but not by nearly the same amount that it lowers low quality software. And so that changes how we think about what we might be creating, because if you ask, well, I can create something that's half as good at 1/10 of the cost. Is that the right choice? That can be the right choice. This goes back to a bit of the we are not artisans, right? If you, if you think about, oh, software is a craft, it has to be high quality. That's not how, how software works, right? That's not how our businesses are asking for us to, to, to design software. They may be asking for I want something that especially if I can get that to market faster. I can compete better. I can do this. Maybe I can improve it over time, but that option should be on the table. There are other businesses that are going to say no that's never acceptable we need it to be high quality software now in those spaces what that will look like in terms of competition from other companies that are doing taking that strategy I don't know. I think it's going to be a weird thing but that's less about the mindset, um. But so again we need to bring this that we're looking at those outcomes and what we think is valuable in there when we do this. And so Uh I've rushed through this a little bit, I'm finding. Um, Because we have that. This mindset for outcomes over output. Enables us to serve the purpose that we have been hired for, that we are as um. As businesses or sorry that businesses are asking us to do right as opposed to the hobbyist thing that we do on the weekend where we have full control to go in and do the things that interest us to create intricate things that have some inherent value or that we think are beautiful to do. Where When we're creating something as part of a business, we should be focused on is it doing the thing that the business needs that the customer needs. And so when we go back in to ask, What do I do? Right, you can talk about. Here's the features that I'm providing. Here's the services that I'm providing or the, the, uh, the things that I'm doing for the teams or customers that receive these things. But I think the answer is I create outcomes. Right, that that's the thing that I do is here's a defined set of outcomes that I'm providing. To someone else Enabling them to solve a problem that they have. And when I go in to say, how do I respond to changes. You have a similar answer You say I stay focused on outcomes. Right? Does this change the outcomes that are needed? No, but it changes that the output that I had is no longer relevant for that outcome. I need to build something different or I don't need to build something. Or yes, the outcomes are changing. Is what I have useful for that new thing. Or is it something that I can, uh. Uh That I can change? Do I have to build something new? Where do I need to, to find that balance with this? And so finally, uh, when we ask that question of who am I? And we acknowledge that we are not our tools, that we are not our output. That we can answer That we are problem solvers. Right? But that is the thing that we do. We are asked to solve problems in interesting ways. And that is where, how we solve those problems. The thing that makes us different. From other people, where we get that label, is that the mechanism by which we solve problems is to build. And that is what makes us builders. And with that I think I'm done. Thank you.