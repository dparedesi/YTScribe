---
video_id: uhrUS6vUYmg
video_url: https://www.youtube.com/watch?v=uhrUS6vUYmg
is_generated: False
is_translatable: True
summary: "This session, titled \"From punched cards to AI: The developer’s new mindset\" (DEV205) and presented by Ana Kael Najirol, explores the evolution of software development from the tangible, manual era of punch cards to the modern age of AI-assisted coding. The core message is that while the tools and methods of building software have changed dramatically, the fundamental mindset required—clarity of intent and guiding the machine—remains the same and is now more critical than ever.\n\nThe speaker takes the audience on a historical journey, starting with the ENIAC and punch cards, where every line of code was a physical investment and debugging meant sifting through stacks of paper. This era demanded extreme precision, planning, and documentation. She then moves through the ages of high-level languages like Fortran and Pascal, the rise of Agile methodologies which centered interpersonal skills and iterative feedback, and finally arrives at today's \"natural language programming era.\"\n\nA key concept introduced is \"vibe coding\"—prototyping quickly by prompting AI and checking the results. While effective for initial drafts, the speaker argues it becomes inefficient for complex, maintainable systems. Instead, she advocates for \"Spec-Driven Development\" (SDD). In this model, developers first design a clear intent and specification (requirements, design, and specific tasks) before asking the AI to generate code. This mirrors traditional engineering rigor but accelerates execution.\n\nTo demonstrate this, she showcases \"Quiro,\" an IDE fork of VS Code designed for this workflow. Quiro allows developers to define rigorous specs and \"context engineering\" rules—such as coding guidelines, tool allowances (via MCP servers), and architectural constraints. The demo illustrates building a Tic-Tac-Toe game where the AI follows a structured plan, iteratively fixing its own code to pass mandatory tests defined in the spec. This approach ensures that as projects grow, developers can modify the *specification* rather than vaguely prompting a chat window that has lost context.\n\nThe session concludes by encouraging developers to intentionally cultivate skills like critical thinking, collaboration, and precision—soft skills that have arguably been essential since the punch card era but are now vital for effectively collaborating with and guiding AI systems."\nkeywords: Spec-Driven Development, Vibe Coding, AI Assisted Development, Software History, Context Engineering, Agile Methodology, Quiro IDE, Prompt Engineering, Developer Mindset, Soft Skills\n---

Hi, everyone. Thank you very much for coming to the session. So the title is From Punch Cars to AI the Developer's New Mindset, because what we build and how we build has changed, but how we think about building, that's where things get interesting. My name is Anak Kael Najjiro, and I work at the intersection of software development, design, and system thinking. It's been a couple of years where I work at the age of where people and systems meet, and that age actually is moving again. I'm also a community leader and I get to talk with community members about the impact on our jobs today and they have questions like, how do we collaborate with AI, what are the skills that matter nowadays, and how do I stay relevant, and maybe those are some questions that you've been asking yourself. So, probably you've all received one of these. So this is a gift that I handmade it for the session, especially. I would invite you to wide open it and have a look at the cover. And the question is, who knows what the cover is? Anyone? It's a punch card, yeah. So this one is a blank one. It has no holes, and a punch card with holes actually is the equivalent of a line of code of 80 characters in your GitA hippo nowadays. Line of code of 80 characters in your GitHub repo nowadays. So please keep these notebooks close to you. We're going to use them later, uh, as a pause button. And of course, it's a design choice, but also a bit of history. So I invite you to take a couple of minutes with me and uh see how our job has evolved through time. From punch cards to high-level languages to agile methodologies, and now the AI assisted development era. So here we have an image of the first general purpose electronic computer, which is ENIAC. As you can see in the picture, the way we programmed it was quite manually. We needed to set up switches, we needed to plug in cables, so we may understand that a lot of planning was involved. Documenting, documenting everything was needed, and if something wasn't working well, a systematic approach of debugging, debugging things was needed. People worked at the time in teams and we also understand that the way of communicating and aligning everyone on the project goals was very important. This machine had no memory. So how did we input Information and where the information was stored. And then we go back to the punch card. So here we have a punch card with horse. The horse represent presence of digital information. The way we initially punched the cards was, as we see in the image here, where the lady is using a machine manually punching them. One card, one line of code. One program, one stack of uh punch cards. Then we would go with that stack of uh punch cards to a machine, input them, and then we need to wait. Sometimes we need to queue because we only have one machine available, right? To see the output. If we had an error, or, then it might take hours to find out that we had an error, and then we needed to find out where that error was, right? And we need to go back and look at like everything that was done, the design, the documentation, and find the car that wasn't right, if it was only one or multiple. But eventually, things evolved. And we actually programs finally had symbols instead of cables, but everything was still painfully close to the machine, uh, because now developers had to deal with registers and memory operations. Instruction sequences was a thing. Developer, developers still use the punch cards to input the information. Hand it over to the machine, but this time the programs were loaded into the logical memory, executed, and then we had the results. Eventually things evolved, as you might know, and we had the very first high-level programming languages. You might have heard of Fortran and Cobalt. We still have systems running that were written in these programs today, especially in the finance industry. And What changed here with this program is, is that the developers now work more with mathematical formulas and also business logic than the individual instructions as it was the case with assembly. My parents are actually working in IT and they, when they studied at university, they would code uh in Fortran. So they would design their code, they would use this kind of code sheets and then feed this to a machine that now eventually punch the cards from the for them. And here we have a line of code in Fortran. The whole process was still pretty intensive because they still needed to, to queue to do everything and they still need, took like ages and they needed to work in teams to collaborate and communicate and to debug. Things changed a little bit more with the following programming languages that appeared, and eventually my parents went from programming in Fortran to programming in Pascal. And this is the very first program, programming languages that I saw myself at home on the computer. And there are some of the, these programming languages that I used through my career. But now applications grew in size and lifespan. And programming became more a collective intense process. Teams adopted new practices such as version control, modular design, and code reviews. So, Also, at this, if you will look at the years, you also know that internet adoption grew in, uh, at a high speed. So teams started to work together and collaborate, being at distance and being online, and that actually introduced new methods of working. Who here already uses Scrum? Hands up. Scrum, scrum, I can see almost everyone. So that actually appeared in the 90s and until the 2000s, there were multiple similar methods and only in 2001, they were formalized under the agile manifesto and we know them as agile methods today. And it was what was formalized was the fact that the software development required constant adaptation. We had short iterations, continuous feedback, user involvement, involvement, incremental, incremental deliveries. It became standard practice. So agile placed interpersonal skills in the center of the software practice because it was more about individuals' interactions than the process and tools themselves. So as I went through this quick overview, you might have noticed some of the soft skills that developers had to use through every age, and we are actually still using them nowadays and they are very much needed with AI. And some of these soft skills are critical thinking, collaboration, communication, and precision. And if I take precision, developers needed precision when they manually programmed. They needed precision when they parked their cars. They needed precision when they were writing the instructions. And now we also need precision when we interact with the AI systems because we need to be quite vigilant. When AI writes code that looks right, but isn't. Yeah, you heard that? So we can say that now we are, we are in the AI assisted era or natural language programming era. And we're using things like prompts. Here I have one from a community library, prompt. dev. You might go and check that out. There are multiple community prompts. And the way we do it, pick up your favorite AI assistant, use a prompt like this, hit submit button and wait for the result. And this is called Wipe coding, who already here, uh, who here already wipe coded? Hands up. It's like, almost everyone, but I think maybe everyone. The thing is with fiber coding, having First version is very quick, having a prototype, but once you want to change things, to go forward, to implement new features. Then it becomes really time consuming and you need a different approach. And now a different approach would be going closer to the traditional way of designing your systems, building your specs, having a clear intent. And once you have your spec clear, then you move forward to coding. And on the other hand, we have the spec-driven development methodology. Now, let's see how we can apply this to our software development life cycle. So here are the Here is this life cycle that you might have been aware of. It's the ag agL one as we look through the different uh Cycles. And The question is where can we apply the spec-driven development? And actually we can apply, starting with the requirements and the design, and once our intent is clear, we move forward to development, testing and eventually deployment. Now, when you're in the development phase, you might go, uh, back and forth with your assistant or AIA system and apply some of those vite coding skills or prompt engineering skills. But this would be within the spec-driven development. So let's say if you wipe code alone, great for prototyping, you can quickly take decisions. If you decided to go forward with the product, start by implementing your specs first, designing your intent, and once that is clear, move forward. I work myself with the clients and when we talk about AI there is a similar question to this one that comes up. How do I deeply understand the system that I'm building with AI in order to ensure maintainability? Because in the end, it's all about how do we build them to, to live through time. And one way of doing it is providing better context. I have a picture that is from anthropic site website that is comparing the prompt engineering, context engineering, prompt engineering, by coding with a system prompt on top of it, and on the other side, we have the context engineering, providing better context. Now, what's better context? We already developed, we know the context that we need. We need the best practices of our team. We need the best practices of a company. We need samples of similar projects. We need to tell the AI which languages to use and what not to use. Uh, we need to tell them which tools to use and which not. And all of these we provide to the AI and based on the context, we're going to move forward with our system. So if you go back to the web coding and the spectrum in development, the question is, where are we doing this? And I think you already know the answer. Right? Hero. So I prepared a short demo. Of Quiro. Here we have the IDE. So Quiro is an IDE which is a fork of Visual Studio code, and on the right side you actually have something in you. You have the way to interact with Quiro, and we have the vibe coding mode where you are able to explore by testing and prototyping, and then the spec-driven development mode where you would first start by building your specs. And then you also have the Kiro tools. Uh, specs, agent hooks, agent steerings, and MCP servers that you can add in there. And when I talk about the context, in it by providing agent steering files, it's actually a way you can provide better context. Here you would say, hey, these are the guidelines when we are committing our messages in GitHub. Hey, we don't write files that have more than 500 lines of code or maybe less. So you're providing all these guidelines to your, your AI system. And then you would need to add also if you have some MCP servers that you're using nowadays, tools, these are, these ones are standard from AWES. It's a bunch of lists, so I, I added them here. So what you're doing here is building a tic tac toe game with spec-driven development. And as you can see, the first step that Quiro is doing is building up the requirements. For the demo purposes, I accepted everything, uh, that Quiro proposed, but normally I would go in, read through, adjust my requirements, and when I'm ready, I'll move forward to the design. Once the design is proposed, same, go, read through, work on your design, and when you're ready with your design, you will then move forward to step number 3 in your SDD or spec-driven development cycle, which are defining the tasks. You can see that some of them are in white, which are are the mandatory tasks that Kiro would need to execute, and some of them are in gray, which are optional. Here the optional ones are the testing ones, and there is one that I actually put mandatory, and we're going to see that it had an impact. OK, I'm all, all happy with my specs. Go build the system for me. And as you can see, it's starting looping through the tasks, executing them. And actually the very first task, which is the set up project structure and dependencies, took the most of the time. It was like uh forth and back. I don't have the permission to execute, then you don't have this installed. I need to install this. But once it, the first task was validated, it would run through the different tasks quite quickly. We're going to see that eventually, Kiro would stop at tasks 4.1. So the task 4.11 is actually the testing tasks for the task number 4. And it was interesting because when running the test, there were a lot of errors. The code wasn't compliant with the requirements. So we had like 445 times to go back and forth fixing the code, executing the test, not working, fixing the code, executing the test. Eventually it worked. It, it went up until the end, and then I would eventually get the game on. And here it is. I played a little bit with it. It was working. I was happy. But you may imagine that using spec-driven development isn't forbid this kind of games. I, this is nice for the demo. But now if I want to go back and modify my spec, it's easy because I have a place where I can go modify only the part in the spec that I want to modify the requirements and then ask my AI system to go modify the code that is associated with it. And if you compare that with wipe coding, you would eventually ask it in the chat. Eventually you went out of your context window, and then we're just starting to be quite time consuming and it's quite difficult to track actually how the specs evolves. OK, now is the time to take out the, your small notebook and a pen and a pen. Uh, uh, I had some pens actually to hand over, but I'm not allowed, so hopefully you all have a pen. But eventually you all got the notebooks and actually you're going to find a question in there. Um, and I would invite you to note down a skill, soft or hard, that you intentionally grow in the next six months. You. And to go forward, what you can add is a calendar reminder 6 months from now to go back and check in where are you standing. Because in the end, our jobs are evolving, we have new strategies. Tools, but it all starts with experimenting. Probably we don't have the perfect workflows for now, but things are going to come as it all did as the compilers. Developers didn't trust compilers back in the time, so I'm very eager to see where things will move forward and if it's one thing to take out of the talk with you. When you leave, remember that you're going to design your intent that you have to have clarity of what you want to achieve and you're going to guide the machine because it's more like a collaboration than only you telling what instructions to execute. So thank you very much.