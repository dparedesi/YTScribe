---
video_id: 5L7MTSJu3q8
video_url: https://www.youtube.com/watch?v=5L7MTSJu3q8
is_generated: False
is_translatable: True
---

Hello everyone. Welcome to NTA 404 and welcome to Reinvent. I hope you all are having, uh, some fun with all the nice sessions just for you. Uh, my name is Pranjit. I'm a solution architect and I have with me my co-speaker, uh, Marcus Mattson, also, uh, solutions architect, and I hope everyone's having a good day one. Everyone doing all right, enjoying its sessions. All right, a deal. Nice. And, uh, uh, uh, thank you again for spending next one hour with us. So today's topic is AI code to production context matters. How many of you, like, if I have a quick raise of your hands, how many of you are using some kind of AI coding assistant to code? Quite a few. OK, nice. How many of you have started playing or dabbling around with our agentic ID tool Quiro? OK, not bad. OK. All right. So. In today's session, what we're gonna cover is, uh, this is a code talk, so we're gonna do a lot of coding, uh, while you are here. But before that, just to set the, uh, stage today, we're gonna talk about some of the AI code production problem like when you build, like when you do vibe coding or you are doing some kind of prompt engineering and creating some nice code, uh, what is the challenge that typically happens when they go in production and how we can. Uh, like, do context engineering to kind of put those code, uh, make those code like production ready, and, uh, then, uh, the next thing that we're gonna cover is, we're gonna talk about some of the essential context layers, uh, for your success when you are building AI code, and then, uh, some of the key takeaways of from today's session, some of the workshops, uh, that we want to highlight that you can get started with. So, having said that. Let's quickly, uh, talk about a developer named Sarah, OK? She's a senior developer. She started doing vibe coding and she faced some challenges. Let's see what are the challenges that she faced and how she overcome that. Let's talk about a journey that I think every developer knows deep down. It's the move from that frantic adrenaline fueled last minute hack to the calm confidence you get from building something you know is rock solid. It's really a story about the hidden dangers of just making it work. You know the feeling, right? It's Friday afternoon, a huge deadline is staring you down, and the only thing anyone cares about is getting something, anything up and running for that demo. That pressure, well, that's exactly where our story kicks off. All right, so let's set the scene. This first part is all about a gamble. It's about a very tempting but also very dangerous way of developing software, especially now that we've all got these incredibly powerful AI tools right at our fingertips. So let's meet Sarah. She's a talented developer. She knows her stuff, but right now she's completely up against the wall. A really critical demo is just a few hours away and she needs a miracle, fast. So what does she do? She dives into what we're going to call vibe coding. She's just firing off prompts to her AI tool, grabbing the code snippets it spits out and stitching them together based on her gut feeling. There's no big architectural plan, no deep thinking. It's all about speed and that feeling of, yeah, yeah, that looks about right. And you know what? It totally works. The demo goes off without a hitch. The feature is a hit. The stakeholders are thrilled, and Sarah's the hero of the hour. She pulled it off. But that amazing feeling, that rush of confidence, well, it's kind of built on sand. Of course, that Friday high, yeah, it doesn't last long because the nice, clean, predictable world of a demo is nothing like the absolute chaos of a live production environment. And this, this is where that shortcut comes back to bite her, hard. This is when reality hits. Monday morning rolls around, the code gets pushed live, and almost instantly alarms start going off. The whole thing, the system that worked so beautifully in the demo, just completely falls apart under the weight of real users and real world data. It is an absolute catastrophe. And look at the kinds of problems we're talking about. These are not simple bugs. These are the deep, gnarly, architectural nightmares. You've got race conditions, corrupting data, massive security holes, compliance failures, and memory leaks that are crashing servers left and right. These are the huge invisible icebergs that vibe coding just sails straight into. And this is the moment it all clicks for Sarah. This is her big aha moment. The AI wasn't the problem at all. It did exactly what she told it to do. The problem was she didn't know what to ask for. She asked for a feature, sure, but what she actually needed was a production ready system, and those are two completely different things. So this total disaster, it becomes a massive turning point. Sarah realizes she just can't work like this anymore. It's time to evolve, to level up from being a reactive vibe coder into something way more intentional, way more powerful, a context architect. Now, let's be super clear. This isn't about her throwing out her AI tools. No way. It's about getting way smarter in how she uses them. It's a shift from just asking for a chunk of code to providing the AI with deep, rich structural context, so it can generate code that's not just working, but is genuinely robust. So how does she actually make this shift? Well, she adopts a new framework. You can think of it like a blueprint for success, a way to feed the AI all the right information from the very start. Let's walk through these four layers of architecture that pretty much change everything for her. OK, here's how this blueprint works. It all starts with requirements. This is where she thinks through every possible edge case, every failure mode, all that security and compliance stuff. Next up is design. Here, she's planning things like concurrency to avoid those exact race conditions that burned her before. Then comes implementation, building the code from day one so that it's easy to observe, scale, and maintain. And finally, the operational layer. This is where she's thinking ahead about monitoring for things like memory leaks before it becomes a 5 alarm fire. This table really just lays it all out, doesn't it? On one side, you have the vibe coder. They're reactive, they use vague prompts, and they get code that's good enough for a demo. They're asking, what do I build? But the context architect is systematic. They use structured prompts to get genuinely production ready code. They're asking the deeper questions, why are we building this and how will this thing behave under every possible kind Of stress. So armed with this whole new mindset, Sarah gets a shot at redemption, and the stakes, they could not be higher. Another urgent, super critical request lands on her desk, but this time it's right before the biggest, most intense traffic day of the entire year, Black Friday. But this time is different. There's no panic, there's no last minute vibe coding. She just calmly and methodically works through her four layers, building out a comprehensive plan. She then uses that plan to create these incredibly detailed, context-rich prompts for her AI assistant, guiding it to build a system that is resilient right from its core. So Black Friday hits, the website gets absolutely slammed with a flood of traffic unlike anything they've ever seen. The entire team is just holding their breath, glued to the monitoring dashboards, and the number of critical errors, the number of outages, the amount of downtime, it's a big, beautiful 0, a perfect performance. The system she's so carefully designed as a context architect scales up perfectly. It handles the insane load without a single hiccup. I mean, if that's not the ultimate proof that this new approach works, I don't know what is. And really, that's the core lesson of this whole journey. The magic isn't the fact that AI can write code for us. The real skill, the thing that truly marks the leap from a good developer to a great one, is knowing what context you need to feed it. And so that brings us to the final question, and this one's for you to think about. The next time that deadline is looming and the pressure is on, which one are you gonna be? Are you gonna be the vibe coder, crossing your fingers and just hoping for the best, or are you going to be the context architect, building for reality? OK. So, having seen that, right, uh, these are some of the challenges, right? Uh, or why AI code fails in production. AI models, they're trained on a lot of code, right? But they don't know your business. There are certain AWS environment specific information that you have in your AWS account, but it is not aware of it, right? Uh, it Is not aware of any kind of regulations or security compliance and any kind of other compliance requirements that you are supposed to take care of when you're developing code. It is not aware of the cost implications. Are there any challenges in respect to how you want to architect your AWS environment for any production of the application, right? So, having said that, These are some of the context, uh, that we're gonna see how we can address, like how we can layer this context into our solution which is called Quiro, the agentic ID, uh, from prototype to production, which gives you a lot of flexibility how you can inject context in runtime, how you can use the long term memory within, uh, the application itself to build something which you can deploy on day one in production, right? So some of them are like the how you can create. Business context and feed that still utilizing the entire context window because context window is something that you don't want to fill with all your documents dumping into and filling all the space to leave nothing for the LLM to be creative enough to come up with something useful for your production application. So you need to know how you can utilize your context window efficiently. Uh, for your production ready application, last but not the least is the AWS context. So you need to make sure the application that you're building, which you're planning to deploy on AWS, are also following the best practices. We call it well architected framework, right? Uh, it, if you have certain cost related constraints, you want to also give that information to the, uh, the AI coding assistant, how you can do that. So all those things we're gonna look into, uh, the Quiro part of it and then see how we can use Quiro. And some of the features that we have in Qiro to come up with the production of the applications. So I'm gonna switch to my, uh, other uh demo laptop, and we're gonna talk about a gaming company. Let's say Sarah is a, uh, is working in a gaming, uh, company, and she's supposed to build a game application, right? And how she starts introducing context, how she is utilizing those contexts to be able to come up with a production application that is ready to deploy on AWS. So with that, I'm gonna switch to my. Yeah, and if you're like me, you've seen AI coding assistants generate some really impressive stuff, and then you've seen it create some stuff that uh lacked a little bit. And so you're probably thinking, show me, and that's what Pranjeet's gonna do. All right. Uh, can anyone confirm, like, are you able to see or do I need to zoom more? You're good? OK. All right. So this is uh the Kiro ID. There are two flavors to Kiro. One is the CLI part of it. One is the ID. So if anyone is like familiar with like coding using keto CLI, you can do that. Uh, folks who are actually like maybe working on Visual Studio, it's a VS code for hero, so you can get all your visual code settings. On boarded to Quiro when you're deploying like the uh installing it and you're uh you're starting to use it. So for our session we're gonna use the Quiro ID not the Quiro CLA, but you have two flavors. So just to let you know now this is a I've just set the stage. So what I've done is initially I have. Let me do, OK. So I've set a folder called a game app and I have placed a Kiro logo over here. That's just a blank uh application with nothing inside it other than a logo page and then. What I'm gonna, uh, if you see the ghost icon is where you would see a lot of additional features like agent hooks, you have agent steering, and you have MCP servers, right? So we're gonna cover all of them. Now, uh, in the agent steering, you see there's a global steering rule called SE global rules, which is a condition that I put for all my. Applications that I'm gonna build with kiro agentic ID. So what I want is this is the global steering rule. So how do you, when you actually go into the agent steering and hit this. Plus button, you have like 3 options over here. The first one is creating from scratch where if you have any code base already there in this repo, if not, it's going to create some basic uh markdown files. There's one which is called global agent steering, and there's one foundational steering rule. So for the one that I'm showing here, it is the global agent steering. That means it is stored in the home folder of kero under the steering. So that way this global. Rules are applicable for any application that I build through Kiiro and I'm gonna show how it is going to take care. So I have given like a specific information of that when I'm gonna use spec driven development, uh, instead of vibe, uh, always, uh, create the requirements, mark down document, uh, and then, uh, also list, uh, different persons, right? Uh, when actually the requirements documents are created, it doesn't give the persons, but I want that the user stories and the acceptance criteria that it creates should have a personal attached. It, I also want like when it is creating a design document, it also should include an ER or entity relationship diagram for me if there's a database schema involved, right? And then the other one is like when it is creating the tasks, it should also, uh, organize the task so that like after each and every granular task I should be able to like demo uh a unit test like what exactly the application looks like after this task, right? So for our project what I'm gonna do is. I'll go back to this folder structure. Uh, Bear with me. So I'm gonna create a, a specific steering rule. Steering rules are something that is uh specific to this application. It is always going to refer to the steering rules when it is trying to come up with the requirements and the design and the task. So, Let me create it from scratch. Uh, building rules. So these are my standards that I always want hero to take care of when it is building an application. So it comes with this template. It has inclusion always on the top. That means it is always going to include the specific instructions that I'm gonna put over here when it is trying to come up with the, uh, requirements and a design. So I'm gonna paste it over here. So what I've done is, like I've mentioned. Let's say a game building application rules. When you're, you're a helpful game building agent, you must always adhere to like the preferred languages. So let's say you're like creating any Python applications, so you can put those specific information specific to your scenario, but you can give any number of information based on what your stand like standards are, what your company standards are, what kind of coding rules that you follow. So you can give all these over here and then I'm gonna save it. And I'm going to create one more markdown file, which is specific to the styling part of it. So what kind of colors that I want. And anything related to to design. So I'm gonna come here. And then I'm gonna create one more. styling guy. And light and then. I'm gonna Paste it over here. So if you see over here, I've given like specific color schemas. And some of the usage guidelines and some design guidelines that I like to uh adhere when I'm actually building this gaming application. Now, I will switch to Y. So as I mentioned, right, Hero gives you flexibility. So we, there are certain scenarios where Y coding is relevant. Like if you want to build a quick prototype, Y coding is still the go to path, right? If you are building something which is production ready, uh, definitely advised to use peg-based coding which follows the typical SDLC process of like planning first rather than just prompting and praying like wipe coding, right, so that it gives you the right code because like typically in vi coding what happens is that when you give a Big prompted all the information, it starts coding without even thinking, and then the code that it comes out, you probably have to like revise it so you go back and ask, OK, can you add this? And then it goes and tries to address that specific, uh, last, uh, chat history, and then it forgets what it has created initially and then you go into regression and you keep on troubleshooting to come up with a appli like a a code that you can really play with, right. Whereas in spec based is more of like doing all the planning, making sure they are approved like either by your product manager or your architect team, or even if it is you're a senior developer and you have the ownership to, uh, approve all the use cases, and then you start then, uh, building the code so that the code that is being built is adhering to all the requirements and a design that you have approved, right? So that's kind of difference between vibe and spec based. Right now, so, so just a quick on, on these documents you just created the, the, uh, steering docks, the rules basically the global are gonna be your organizational standards and the others are specific to this project and one of those was marked always so that means whether you're using VIB or spec it's gonna refer back to those steering dock rules. Yes, so you can set certain guidelines at the global steering level and then you. Have certain guidelines at the like the workspace level right? but then typically the workspace level steering like if there's a collision between the global and the workspace, uh, the, the global steering rules are not getting the precedence it's basically the workspace specific guideline that takes, uh, precedence in respect to what it is going to build, right? So that's how that takes, uh, precedence, right? So yeah, good question. Thanks, Marcus. OK, now. I just have an idea of this game that I want to build. I want to build a flappy kiro game right now. I can use Vibe to just go and ask, like, uh, build a very basic version for my prototype for my ideation, right? So maybe I can start with Vibe instead of like starting with the spec best. So I have an. Idea and I paste a prompt over here and if you see I just mentioned I want to build a flappy kiro game please create a very basic working version. I've given some information like uh what kind of canvas you should use for rendering kiro character I mentioned there is a uh. Image over there in the document so it can refer to that. So I've given some basic information. I just did vibe coding and I told, OK, go and do for me now while it is building that like, uh, while it is coming up with the code, if you see over here there are certain options like one is the autopilot. So autopilot in the sense I've given some autonomy to this agentic ID so that it can take some, uh, like, uh, it can take some. Actions without even asking me or prompting me, OK, approved for everything. If I toggle that off, it's gonna ask me for everything that it does on the code base, right? There are options of like selecting different models from here. Like you can select Opus model, you can select cloud, or you can go in auto mode so that like the agentic ID can decide based on what kind of context and what kind of task that it is doing. It can toggle between different. Uh, models, right? So for me I've selected cloud 4.5. So, uh, I stick to that. And then the other option is there's an option of adding images. So let's say you are coming out of a meeting, you did a whiteboarding of a gaming application and you took a picture of maybe an ERD diagram that you have drawn out in the in the. Uh, uh, meeting or you might have drawn an architecture diagram, uh, with, with your stakeholders, right? You can take a picture and you can upload it over here and then it can, you can ask you to kind of come up with the plan so it has like a multimodal feature as well where you can take some images and put it into the context to come up with those requirements for you, right? So it can do that now. If you see over here, uh, it has, this is what I, I wanted to show you. So when it started like vibe coding it included the steering documents, so the one is the global one and then the couple of them that I mentioned I created specific to this workspace, right? And then it says, OK, let's build a flappy game together. So it went ahead and it created some stuff. So if I go back here in this one it. Let's see. Once you answer this, OK, so it has asking me to answer. So I'll create a playable version and all the games. So it, it is asking, so if you see over here, what I mentioned over here in the app building rules, right? I asked. That suggest creative ways and then take user's input and create a user context MD steering file to store user preferences as you help the user build a game. So it just didn't go and started creating code just like vibe coding does, right? So now it is asking me, OK, can you address these questions. That I have for you, uh, before even I go and code, right? So that's why like you are actually acting as a driver in the seat, not giving the whole autonomy to the ID tool to come and, uh, uh, uh, create the code, right? So maybe let me give you, give some instructions over here, right? So what visual studio do you prefer? So let's say. Classic flappy bird game. And then it says, obstacle. What should the obstacles look like? Traditional. And then scoring, how should scoring work? plus one? Wine based on. Sulfa equal time. All right. So I've given that information and then Quo goes. And starts OK. So now it has started the HTML page for the game. And if you see over here, it has started appearing over here, and then it has started creating the JavaScript. Uh. So once it is created, we're going to look into the The code itself. So, let me go here. And then let's see what it is building. Yeah, it's starting to already give us hints that this could start to become a more complex application. It's, it's asking about user preferences and you're starting to wonder maybe vibe coding is not going to be enough. So let's see what it's got put together so far. So it has. Yeah. So, it is a very basic one, right? It just doesn't do anything. It doesn't have any kind of scoring, uh, like sto, it is not storing any information over here. So it's a very basic one just for ideation, right? Now, Once I'm done with the Vibe coding, OK, I have a plan now, and now what I want to do is I want to add some features like I want to store the player's score and also the high score. I want to add some visual effects like some kind of trail particles, some kind of explosion effects, and some sparkles like when it passes. Through some obstacles, so there's like a lot of like additional features that I want to, uh, add that means that I'm gonna touch a lot of like code base as well as I'm gonna create a lot of additional files, and I want this keyro to kind of come up with a plan before even it starts coding, right? So that's why like what I'm gonna do is I'm gonna switch. Over here So I'm gonna open a new context, uh, and then I'm gonna a new window and then I'm gonna move to spec, and this is where the fun will start. So what I've told, OK, help me add like save game history and sports, right? I told about some of the visual effects and then I told creative. Minimum viable product for the above features and I wanted it to list only 5 tasks rather than going more granular. Like if I don't give this specific information, it probably will come up with like 9 or 10 or maybe 11 steps, and it's very granular. That's fine for some developers for the sake of today's time. I just wanted to limit it to 5 tasks. So once I'm given that, I'm gonna hit enter and then if you see. It now reads again, always like when it starts doing something, it always is looking into the steering documents, and then now it is reading the existing code base. And now it started creating the requirements document. Now, if I hover over here, And then if I go to specs, it has created a folder and then it has started creating a requirements document for me and as I have shown you the first time I mentioned that I want so it has created the requirements document and now it is waiting for me to like move to design phase which is the next step but before even I go there is the user stories and the acceptance criteria but what I mentioned is that I mentioned give me the. Personals as well, right? So if you see over here this is something that it created based on my specific global steering rules where I mentioned introduce the persons and tell me which user story is related to which persona, right? So if you see over here. It has some user stories and some of the person is attached and what is the acceptance criteria so it's the EIR's notation right now if I have validated everything looks good, uh, I move to design phase or else I can say, OK, um. Have you Taken care of. Deploying this code to AWS using serverless. Services. So if I, I can still chat, right, just like vibe coding, but I can ask, OK, have you done that? Let's see. Now, I haven't moved into the design phase yet, but then it says, OK, no, the spec, OK, so it has come up with, no, the spec focuses on the game enhancement features you requested, and it says the current game runs on HTML 5. If you would like to add AWS deployment or back end, OK, save, so it has given me, OK, would you like to continue with the spec as is for visual or add AWS deployment? So, let's say I select 2. As an option And then it goes back and then updates the same requirements documents. So until and unless the requirements is finalized and I approve it, it's not gonna move to the design phase, right? And so, yeah, so if you see over here, it has started. Updating the requirements and I can look like I can select here and you can see the diff. So what is the additional information that it is adding on top of the existing one, right? So it gets highlighted. Over here now while it creates those spec docs, it refers back to the steering docks so that it makes sure that it follows the rules that you've given it and these requirements, I mean it's requirements gathering, right? That's one of the things that often misses or gets missed in vibe coding and and as we get further along, you'll start to see how these specifications are actually used invalidating the code that the AI is creating or generating, yeah. So now if everything looks good, OK, let's move to the design phase is where I hit the design phase, right? Uh, and then, And I say, OK, government's good. And then it went to the design phase. All right. So, let's go back here. And then I move to design. So it's gonna start building the design which is basically the technical architecture and the mermaid diagram, uh, for me to validate right now while it is doing that, I wanted to showcase over here like when I select the hosty button I have additional like tools that I've added like for example some of the existing AWS specific MCP servers like one for the documentation so that I always like whatever I am building, I want to follow the best practices. So I always want like Quiro to. Go and look into the best practices for that appli like uh based on whether it's a serverless or a container based, right? So I want to follow that so I, it can go and look into these tools, uh, using the MCP servers. I want also like, uh, and I'm gonna do that, OK, like create an architecture diagram out of the entire application that I've built so I can use the diagram MCP server. So there are additional like third party MCP servers like for example Fetch like let's say I'm building a trading system application and there is some exist. Existing trading system applications out there. I want to like ask Quiro to go and uh check the URL of the trading system and compare with the one that I'm building or maybe any application and see if there's any additional features that I want to use in my uh application, right? So it can go and like look up existing like external URL to come up with some comparison and features say that I'm missing in my application. So it can do a lot of like based on what kind of incentive server that you want to integrate. Uh, the other thing which is important is the agent hoax, and this is very interesting, and I'm gonna, uh, show you like while it is building, uh, still the design document, uh, let me go over here. And this is something is built on um the event-driven architecture of AWS whereas let's say I want this hook like whenever. Any codebase file is. Updated and saved. Please do the. Unit testing. To ensure it doesn't. Break any? Existing features. So if that is a very basic like hook that I want to use for an event ribbon like whenever a new file or an existing file is updated, I want at the back end, uh, for the agent to go and make sure like nothing breaks because of some additional code that I've introduced or or uh updated an existing one. So I can like create a hook and what it does is that. You can see like it has execution queued, that means the design is still being created when uh this execution is queued so I can open the task list so I can see like multiple tasks right now. So right now if you see it is in the design phase, so it's doing the uh design document creation, whereas this. Task creating the hook is still in the queue, right? So once the previous one is completed, the next task is going to, uh, execute. So you can see the queue as well. All right, now I'm gonna switch back into my design and let's see. So there's an icon here where you want to like look it, look in a better one, OK, so you can like even expand this and you can look into the design in a better view like. Let me scroll this part of you so that it is much more visible to all of you, so you can even. Look, OK, this is the high-level architecture. was the client side, server side, and then the component interaction flow. And everything. So you can look into the data model and then Still executing, so let me Right over here. OK. So now it has, yeah, so it has now completed and it says, are we good with the design, right? Now, I'm gonna close this one and then I'm gonna say, OK, looks good to me. Now, if you see over here, It's OK, so now it says, let me see what it is doing. OK, so it has, perfect. Now I will create the implementation plan with task. So that's the next step. So until and unless that's completed, it's still waiting for the generous spec. That means the entire 3 steps that it has to complete, uh, before it creates the hook for me. So now if I hover over to the task list, which is very interesting, where it gives you the granular task, but if you see over here, it's gonna create only 5 of them for me. Because I've mentioned, OK, don't create more than 5 tasks, right? And if you see there are some that are not highlighted, which are like optional tasks. So, here, once the task list is created, uh, you can see there are a couple of options. One is the Keep optional tasks, uh, that is faster in VP or make all tasks required if you, if I select this one, all the non-highlighted ones also becomes mandatory so all the task has to be, uh, like executed before even I start the application. But for the time being I'm not gonna, uh, do all the tasks. I'm gonna just keep optional tasks so I hit that and now it just tells, OK. Perfect. So now it is going to do only the 5 steps that I mentioned, right? And the optional testers are marked as a star, so you can like skip them for a faster MVP. Now, I can hover over here and I can look into the first task. I can select the thunder button next to the start task. It's gonna start this task first and then it, it is going to wait for me to then once it is completed, go to the next task, or else I can do over here. Execute. Our tasks in Sequence. Now, if I do that, you would see. OK. Now, it started the first task, right? And you can like look into view changes, uh, what it is doing, which, OK, still not yet. So, you can, once it is Started editing some existing. OK, so. Let's see. It has executed. OK, now it has executed the hook, which is the one that I mentioned. OK, the hook is running right now. That means some of the, if you see over here, which was interesting, uh, it actually went in and updated the game. Dot JavaScript file. So hence the auto unit testing for the hook that I created that whenever it updates the existing file it's gonna uh execute the specific hook to ensure that nothing breaks, right? So it's still executing. I can look into here. It's waiting for that to execute. And then it's still doing, yeah, and this is a good point to point out when you create agent hooks, this is something we created that was very basic so that you could see it in action, but in a, in a real development mode you're gonna choose something that's meaningful and impactful, uh, that's going to, uh, be appropriate for the amount of times it gets invoked and the, um. Second, uh, thing that I was gonna point out is you, you'll notice there's broken up into tasks. One of the reasons you may not want to execute all tasks consistently on a larger effort is because we talked about a context window, and these tasks, if you're going along, uh, you'll find that Kiro also keeps track of that context window and if you're doing a large or a long development. Uh, effort, it will stop that session, start a new context window, summarize it, compact what's in your context memory, and move it into a new session. So one of the things you can do with these tasks is usually or use them to break up your work, uh, whether it's because you've got a large project that has multiple chunks or because you want to break up your context window and have a clean window for another large task so that your context window is clean and works more efficiently for you, giving you better answers and getting faster processes. Yeah, when it does that, what does it do? It does. It, it brings over that summary and it brings those, uh, steering docks and the spec docs back into the new session. Yeah, that's right. And then, uh, talking about context window, right? So I just invoke the kiro CLI within the ID itself. So you just like run the kiro hyphen CLI in the terminal and then as Marcus mentioned, like you can check at runtime how much of context window you're using, right? So. You can just type like slash context and you can see, OK, I'm using like 12.8% of the entire 100% context window and then what are the different, uh, like areas that this context window is filling up, right? Uh, so you can see that on runtime and then like the other thing that is very important is like let's say the first task is completed, right, and it's still running the hook for me doing the unit testing. The first task, it addresses this requirements. So if you go to a requirements document and see the 1.1, 1.2, right, all these specific requirements, it is basically tackling through one single task, right? So it also gives you that granularity of like which requirements we are actually completing based on which task and then like. The other thing that is important is like the checkpointing that means like let's say right now it is doing an execute hook unit testing and then it has updated some of the like at the previous step it has updated some files. I want to like I probably have done something wrong, OK, or I want to like revert back. I have an option of restore. So if I select restore. Like I can just Remove those. I just. I can just OK. It's just, OK. It's just like, OK, so I think it did something wrong, but what I wanted to say is the restore option is like you want to like re-update the code base, OK, to the previous state you can do that by executing that restore button, right? OK, and let me stop this, uh, I think, let's see, OK, enable for the time being, but then. Let me open, uh, the other thing. OK. So, uh you mentioned about the Context window, let me bring that up. So this is Let me show you here. OK, here is the thing. Uh. I'm going to bring this one. So I was To your portion and let me enlarge it. Here's the thing. So, I was building a, let's say, a trading system, right? Uh, and I deployed it on AWS. Now, if you see over here, Uh, let me go here. This session was too long, right, for you, so it did the compaction, right? So it basically went through all the conversation history and then it created a new uh session for me, OK, with all the history for it. So it has created a new session over here and then it did the same thing like. If I go on the top like it again including the steering documents, so it came up. OK, I understood the previous context from your conversation we did the compaction of the context window and then yeah, so it starts and while you're talking about this one in particular, it, it's another, uh, interesting call with Kiro. Those tabs each have their own context. So let's say you're working on something that's more in depth in one tab and you want to open up another tab but keep that context as clean as possible, you can open up another tab, just use haiku in it, for example, have a conversation about it, do some more planning, maybe create some more steering docks, more specs, more requirements, and then work them back into the other, but keeping the other context as clean as you, uh, can. Yeah. So, while that is like executing, OK, this is something that I already, like, for example, Built it, right, the same uh gaming application, right? And What I did is that, OK. The other thing is very important is like if you are using any kind of git report, right, you want to commit. So I, the best practice that we typically uh uh advise is like whenever you have something which is, uh, a demoable solution, right, do more git commits, right? OK, connect. Twitter get report and do a commit, do an iterative, OK. If you think, OK, this is the right time to commit it, uh, just commit it and then come back and, uh, uh, like build on top of that, right, so that you don't lose the code base that you think you really like it. So that's another best practice, right? Uh, now. If you see over here, uh, let's see which, OK, so. Here's the one thing, right? So, let's see which one. This one, OK. So, it created a, so this, this is an existing uh gaming application, OK. It did all the advanced features that I mentioned and then if I open the. Gaming application with all the updates. And then if I bring it over here, I created a pack kilo, and it has an ability to save the high scoring. It has those. Like trailing effects that I mentioned and all that. So I created this application in like maybe less than 20 minutes, right, uh, building that so I can like use VIP like, uh, spec-based coding, move from VIP coding for like doing proper planning, uh, approving all the requirements, design and task and everything, and then, uh, that's how like you build like any kind of production ready application which is, uh, and then the final thing is like the AWS deployment, right? So if you see over here, uh, in this one. If I go back here, I know, page. I'm struggling. OK. So, I did, like I told, OK, even Quiro, right? I asked, OK, can you create an AWS cost analysis because I'm very concerned about cost. OK, tell me, like if there are 10,000 users right now, OK, using this application when it is deployed, uh, on AWS, how would that look like? So it created an executive summary for me. Right? Something like this. So it went in and looked into all the uh infrastructure that it is using for hosting this application, and then it did a cost breakdown by service. So it created a very detailed analysis of like cost analysis. The other thing is, uh, I asked him, OK, can you create, like if I ask here. Can you create Uh, AWS, uh, I think it is too small, right? So architecture. Diagram using AWS. Diagram Server. So this is something like, OK, I have built the application, but I want to create an architecture diagram, right? So it says, OK, I'll create an architecture diagram for you for the Pack hero game. Now what it is doing is that it is using the MCP tools. So here you have the diagram MCP server. So it is taking all the icons from there and then. is creating an architecture diagram for me. And then It's gonna wait for me and then, OK, I want to allow it to generate the diagram. So you can like, so this is something more of a runtime, OK, where you're not like putting everything into the context, but you are like calling on runtime some of the additional external tools, right? And then the other thing if you see over here, there's another option here which is the hash button, right? So. OK, there is. My screen froze on me for some, OK, interesting. My screen froze on me, but then let me. So generated, if you see over here, this is a folder. It created an architecture diagram for me. Let me bring to this one. OK, that's a nice small architecture diagram that it has created using the diagram server, right? Now, I don't know. I cannot. You, OK, here is this, so you, if you type hash and then there are like certain additional context that you can inject, like let's say I have this URL and I can reference the URL like, OK, I have an external URL something like example.com and then look into that. Look into this gaming. Application and come up with a Comparison of the feature set that I want to utilize so you can like use peg-based coding and the conversation with that using some additional tools that is there within the kiro agenttic ID uh to do some kind of additional analysis use, uh, so, so that's kind of something which is very interesting, right? uh. Yeah, I think pretty much that's all any questions so far based on the ID? Yup, good. A bit of a question between the specs and the steering. Show here we had a very fairly simple demo here but in a more mature application you see those getting quite longer. So yeah, so the question is pretty simple application. The steering and the spec docs here pretty small. What does the context window look like when you add. A larger project you're doing a significant refactor of an enterprise application. What happens? So that's when you start talking more about. Uh, you will have multiple phases. You break the whole project into phases, uh, is one piece, and I'll, I'll come back and bring it together in more detail. Uh, Pranjeet showed how some of these rules and these, uh, steering docks are listed as always. You've got other options. Don't always include them, uh, and also, so when you've got multiple phases of a project, you can have different specs. So I've got one example that has 10 different specs. And each spec has its own set of requirements, uh, design, and tasks. An example, uh, I could have the, or I, I've got, um, a particular enhancement. I've got a feature, a new feature. I got an MVP first that took, you know, two specs. Then I'm like, OK, this is great for an MVP. Everybody loved it. Let's do some feature enhancements. Call it sprint 1, sprint 2, whatever you've got. And then so you build that in there and you create a spec doc for that set of feature enhancements. I've got another spec doc where I added a feature, and I really want that feature but it broke some stuff. So now I've got another spec instead of um. Design and implementation tasks that go back and help me uh refactor that piece and so that's how you would do it now getting back to the context window. Uh, if you haven't found it before in your AI uses, uh, model.gov, it gives you a list of all of the different models that are, I don't know if it's all, but most of the models that are out there, you can see, uh, approximate price per million tokens. You can see size of the context window, and when you look at that, try to match the model with the work that you're doing, because, yeah, it, it what could you do a context, uh, show like, uh, back in the KOCLI. Do you guys have like a Is there like a good ratio to shoot for? We were talking about ratios and that's, it's interesting and, and I, it may not answer. So the question was, is there a ratio we shoot for? Um, uh, what I was gonna say is the context show. You'll notice now I'm not getting just how much is used per category. I'm actually seeing what files are being used. That gives you a better idea of what's being used and what goes into it. Do I really need this? So, um, ratio, uh, the ratio that we found, uh, is it could range when you're creating code. You could have a simple, uh, you know, generate a spec for doing an enterprise billing solution. It could be 1 to 100. You could do what Pranjit was doing, which is a little more detailed, and, and constrain it, and it's more of a 1 to 10, 1 to 20. But one thing you'll find just in general context ratios or or token ratios into input output. Is that what you're getting at is inputs and outputs? OK, so input. Uh, generating code 1 to 10 to 1 to 100 depending upon things. Um, if you're doing translation, uh, 1 to 1, if you're doing something along the lines of a summarization, it might be just the opposite. I've got 100 to 1 or 10 to 1 where I'm giving it this and say summarize this for me. So it's an inverse of that, um, just general Q&A 1 to 31 to 5. I ask a question, you give me. Some degree of concise or verbose answer, but in for what we're talking about code development, it could range from a 1 to 10 to 1 to 100 ratio, depending upon things like steering docks, constraints, and how you prompt it. Yeah, it's typically like, uh, if you input like I've seen like at least for Kido like or some other tools like it's like 100 input token, you get 1 output token, right? So that's the reason, right? Like we consider context window as the real estate that you want to utilize it efficiently because like you don't want to dump everything within the context and like think like it's gonna create something wonderful for you, right? So very like important how you want to utilize the context window. That's why like this key OCL and the tools that you have is like showing you those how you're utilizing the context window and how you can like. Are you nearing to the compaction and things like that? You can do it even up front, OK, like using some of the commands like slash Compact and all that, right? So yeah, that's important. Now, uh, like, as I mentioned, like I was just showing like when you guys were having a conversation, a trading system that I built, right? OK, so you can build like this is just for like the time of that we have like an hour, OK, how we can showcase some of the features and some of the tools that are there within the kiro agentic ID, OK, which will help you from a context engineering side of it. Right now we have gone through this like just. A summary of what we went over, uh, we use like white coding to start the ideation phase, then we moved to the spec-based coding, and then we, uh, like it created the user stories and acceptance criteria at the requirements phase, uh, just like any SDLC process, we call it AIDLC or artificial intelligence DLC, right? Uh, and then the design phase is where you're gonna look into all the architecture diagram, the mermaid flow, the, the system architecture, and everything, and then, uh, once you are fine with those, you move to the task which can be more granular. And whether you have like additional optional task as well which you can make them uh like mandatory, right? And there's one very important thing that was uh like after it went GA uh just a few weeks back, uh, a property-based testing or PBT which is basically not just unit testing of just a specific module that you have developed with agentic ID but making sure like if you're doing some code update or creating new code, is it gonna, uh, go back and look into the requirements document and see like if it is. Like aligning to what you initially said to build, right, so the property based testing is something, uh, it talks about like correctness property, and then it's basically embedded within the design markdown file where you go scroll all the way down. It shows all the property based testing. Like these are the property testing that is aligned to these requirements, and it's gonna check those OK at certain interval based on what, uh, you're building, right, using some of the tasks. So that those are the important thing. And then you come up with a working product. Now some of the advantages both for developers and for the. Organizations like, uh, you reduce time for fixing some of the code that you generate through AI, uh, you build production ready solutions from day one rather than just like, uh, prompting and praying something good comes out. You become a context architect, not just a code reviewer, right? So you're gonna use your own, uh, knowledge, right, that you have acquired from so long working on different tools and technologies and frameworks, right? So that's very important. That's not gonna go away. And also how you can use like if you're building on AWS, the best practices. Like I've shown some of the MCP server. There are like more like cost related MCP server. There's like, uh, like cloud formation, uh, MCP server and all those things. Like there's like more than 50 of them already out there, right? Uh, and then from the organization, OK, you're not, they're not gonna get a very big AWS bill just because like, uh, uh, AI code didn't even, uh, uh, like understand the cost implications of like is it building something like is it like spinning up big containers or you see to instances, things like that, right? So very important, and then. Now the security and compliance like mostly for financial industry, insurance industry, how you're dealing with PHI PII data, right? Are there any other government standards that it has to adhere to, right? You can do those vibe coding and the spec-based coding. You can like have that conversation and like make sure those are like embedded within the markdown files or add those phases before even it starts coding. So plan before you build, right? That's kind of the idea. And then, uh, faster time to market and, uh, the tech debt, right? Like when you do vibe coding, OK, you gather a lot of like. Technical debt because like there's a lot of unnecessary code that is not needed, right? So how you can improve that and reduce some of the tech. So those are some of the benefits for the organizations and this is something that I wanted to highlight like Andres Karpati, you probably know the founder of OpenAI, one of the co-founder, has mentioned in one of his session LLMs are the new CPUs, which is more of like context processing units. So context is very important and how you move from prompt engineering to the context engineering is a new era that we are gonna go into right next year. So. Uh, as I mentioned, some of the resources, this is, these are some of the QR codes. Please take a picture if you want. The first one is very, uh, interesting, which is like the context engineering versus white coding, when to use what. It's not and or or. It's basically based on your use case. OK, if you're building a quick prototype for going into a, uh, uh, uh, a meeting, OK, where you want to just show the art of the possible, probably why coding is the. A way to go. But if you're planning to build a production with the application, it's not the right step, right? Uh, the Quiro website to get started, how you can download and set up your workspaces, and then this is an interesting workshop, like AI-driven dev with Quiro workshop. It takes you to the workshop of the AWS where you can like actually do hands-on, how you can use white coding spec based on some of the other additional resources that I shared today, like some of the additional features. Uh, and with that, I think we come to the conclusion this is, uh, our email address if you want to connect or happy, uh, like connect over LinkedIn and please, uh, like feedback is a gift. So if there's anything that we can improve upon, if there's anything that we didn't meet your expectations based on the sessions that we have, please feel free to give your honest feedback, right? So yeah, any questions if you have some time. Gives you microservices and you're just getting started over there. What are some steps that you should follow for existing. Yeah, so that, so let me rephrase for the audiences, for someone who is going to offline, uh, hear this, uh, the question is basically what about the legacy applications, right? Like how do we modernize or how do you like start you like playing with those and like modernize this was the same question I was having with someone else like. There's a use case over here, OK? It's just one, like two patterns that we have showed here. They're like 100 types of patterns. So one of the patterns that I have seen is like there is a, and just to give an example, uh, legacy Java application, right, that's been running for like 1015 years with some outdated Java version, some of the security challenges, right? So there was this use case where like the stakeholders are really concerned and they want to migrate to a more modern architecture, but it's a lot of significant investment for the key resources, probably the developers that have built. OK, have left the organization, right? So how do you like squeeze that time frame and use Quiro, right, to give that code base, like point to the code base and then let it like use the spec-based coding to come up with that modern cloud native, like if it is cloud is the right way, uh, come up with the discovery and the analysis part of it and what would be the to be architecture so you can do all that roadmap analysis and come up with that, uh, plan, uh, in a detailed fashion, OK, which you can use like once you get approval from your stakeholders to kind of then. Start building on like uh small task or sublevel task on addressing some of the specific components within the legacy application to move to a more modern cloud native architecture at like it's like a crawl walk runs process right that we typically follow. So there's use case over there, OK, we have workshops of how you can get started on dealing with some of the legacy applications and how you can use that, uh, key road to kind of, uh, build modern architecture and like, uh, like modernize the legacy applications. So there are use cases around that as well. OK. If I can add my 2 cents, agree with everything he just said, but I got 2 minutes. I think I can, I can enhance it. Yep, Greenfield's really easy, right? It's the brown field that you got to do a little more work on it. So you've got an enterprise architecture diagram, right? I, or if not, make one, or he'll I have, have Claude Kiro help you, but Claude is multi or Kiro's multimodal. So you can take a picture or an image of that enterprise diagram, feed it in. And then start at that level and then, you know, provide anything you want about your microservices architecture. Do you wanna change everything? Are you, uh, updating for versions, etc. but something you can go back to your hotel room tonight, get the diagram, feed it into Quiro as an image and say help me develop a solution, uh, for updating, upgrading, refactoring, whatever you need to do. Start from there, work your way down into the details, you break up each one of those microservices into its own set of specs. All right. If there's any questions, we'll wrap up here, but thank you again for staying with us. Hopefully, it was helpful. And yeah, thank you.