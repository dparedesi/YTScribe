---
video_id: Y4iT7tDYMzw
video_url: https://www.youtube.com/watch?v=Y4iT7tDYMzw
is_generated: False
is_translatable: True
summary: "This session, \"Building Production-Grade Workflow Patterns with AWS Step Functions (API313),\" presented by Eric Johnson, uses a fictional pizza business scenario to demonstrate advanced strategies for optimizing AWS Step Functions. Eric illustrates how to transition from inefficient \"Lambda spaghetti\" to robust, cost-effective orchestration by leveraging native features like **Direct Service Integrations** (reducing Lambda usage), **JSONata** for inline data transformation, and **Distributed Maps** for high-volume parallel processing. The talk details specific architectural patterns including the **Callback Pattern** (Task Tokens) to eliminate expensive polling, the **Activities Pattern** for worker management, and resilience designs like **Circuit Breaker** and **Saga Patterns** for handling distributed transaction failures. By implementing these optimizations, the demo shows a cost reduction from ~$1770 to ~$212/month while adding new capabilities. The session also addresses the choice between Step Functions and the newly announced **AWS Durable Functions**, advocating for a \"right tool for the job\" approach."
keywords: AWS Step Functions, Workflow Patterns, Serverless Orchestration, Cost Optimization, JSONata, Circuit Breaker Pattern, Saga Pattern, Distributed Map, Direct Service Integration, AWS Durable Functions
---

Yeah, it's about the quietest I will ever talk in my life right there. So here's what we're gonna do. Can y'all hear me OK? Thumbs up. OK, very cool. Alrighty, uh, I see some of you. OK, there we got the headphones. OK, very cool. All right, I think we're good. All right, I am so glad you're here. I feel like I have to talk really quiet, but let's wait and see how long it takes before we get dirty looks because I get too loud. So we'll see how that goes. Uh, let me get the clicker here. All right, so. My name is Aaron Johnson. Actually, let's do this first. Are you uh in the right place? Step functions? All right, how many of y'all are using step functions right now? OK, excellent. All right, well, like I said, my name is Eric Johnson. I'm a principal developer advocate uh for serverless here at AWS and I live, eat and breathe serverless and step functions is one of my favorite services on the planet. For years I've been saying step functions first. I build almost everything in step functions to the point where it gets a little ridiculous. I'm not joking. I have an MCP server that runs in step functions. Should you do that? Probably not, but you can. So, uh, we're gonna talk today about, about, uh, this kind of stuff. Now, how many of y'all have heard me speak before? OK, good amount of the room. Well, let me tell you, here's the deal. It's all the same jokes. So if you wanna get up and leave now, you can. It's OK. So, uh, all right, well, I'm glad to see you stand. Welcome. Glad you're here. Uh, for those of you, uh, all right, if you've heard me speak, does anybody know the rules? OK, couple, you know the rules. All right, I know a couple of you out there who know the rules. Um, for those of you who don't, I'm gonna give you the rules for what I'm talking and. Rules is probably kind of an overstatement. It's a strong statement, but it, it will help you, uh, as, as, as I'm doing this. So the first rule is this, this is any number I want it to be. OK, now I'm gonna say 5 or 30 or something like that, so you gotta listen to what I'm saying. You can't watch the hand. Now the other part of that is you can't do that. I'm the only one that does that. If you do this, people are gonna look at you like you're silly. So I say 7, and the reason I do that, I, I learned a long time ago because they'll put me, you know, I'll go into a restaurant. I have 5 kids, by the way, that's not a typo, OK? I'll have 5 kids, and so I'll go in, I'll go, yeah, table for 7, and they'll put me alone at the bar, so. You learn, so that's, that's any number I want it to be. These are quotes. This is rule number 2. These are quotes, not apostrophes. I know that because this looks better than this, right? So there you go. And finally, these are thumbs because this will get you beat up. So those are the rules. Uh, I do make a lot of one finger jokes. I'm very comfortable, uh, with that. I was born this way. I, uh, did not wake up this way for the first time today. If I did, I would not be here with you. You'd be like, Where's the speaker? So there it is. But like I said, I'm very comfortable with this. However, if that makes you uncomfortable. I am also comfortable with that, so I'm good. I'm gonna have a good time. So, all right, so let's get started here. Today we're gonna be taking a, kind of taking a ride with a friend of mine. His name is Tony. I'm gonna introduce you to Tony. Tony is like so many of us, he's a developer turned something during the pandemic, right? He did back in time, he did something, and Tony decided to bake, to make pizzas. He's a very good pizza maker, right? So he in COVID, he pivoted to doing pizzas. He is now in 2025 up to 80 stores, about 4.5 or 4.3 million orders a year, and he has a massive orchestration challenge, right? And so, and he kinda like, like so many of us, we went with the spaghetti, the lambda spaghetti architecture because he's a serverless developer, right? How many of y'all, now I saw a lot of people raise their hands, how many of you are developers? OK, all right, how many of y'all are not committed to saying you're a developer and kind of went. OK, alright, there's some of us out there. Let me tell you this, there's 2 types of developers in the world, OK? The first type is the one that can sit there and code and code and then push and it works the first time, and while they're coding, they can have conversations with you, and here's the truth, we hate those people, OK? And I know a couple of them are sitting, I actually know some, someone like that in this audience. I will not point. Matt out or say his name, but there are those people, right? And then there's the other people more like me who can develop and try it. It doesn't work. Develop again, try it, it doesn't work. Type again, doesn't work, it doesn't work, it doesn't work, doesn't work, and we do that iteration until finally it works. And we don't know why it works, but it works, right? So this is, this is the way developers go. And so a lot of times, you know, we, we, we, we go with what we know, and this is the story with Tony. He went with the lambda functions and he built the spaghetti kind of architecture. Anybody ever seen an architecture like this before? Come on, don't lie to me. Who's built this? Yeah, exactly. We've all built it once or twice. We've broken the rules. We've done lambda calling lambdas, things like that, because it does work. But is it the best way to do this, right? When we think about this, right? He had functions calling functions. He had shared state without coordination, uh, manual orchestration everywhere, hand error handling, and so he knew he needed a better way to do this. Now, here's something I wanted to say very clearly, right? This is not a lambda problem. This is an orchestration or architecture problem. Alright, lambda is a fantastic service. I'm a huge fan of lambda. It's really funny when I talk about step functions. I'm often saying you don't need a lambda direct integration, VTL, all kinds of crazy stuff, and people are like, are you anti-lambda? I'm not. I love lambda functions. I just think that, uh, you know, they're, they're, they're not always the right move, right? It depends. It's, it's right tool for the right job is where I, what I believe. So here's the solution that Tony went with. He looked at his architecture, he said, look, I need to do something better, and so he chose step functions like so many of you had. So we're not gonna start and say how do I build into step functions. Today's talk is more about how do I improve my step functions. What are some, some ways of making my step functions production great? So we're gonna help Tony out with that, all right? So first of all, to understand anybody brand new to step functions in here. OK, great, we have some hands. OK, so I'm gonna, just a coup couple of things, I'm gonna tell you about step functions just a little bit. Basically I'm gonna tell you the step function superpowers, and, and why they're, why they're really cool. Alright, so step function number or superpower number one is drag and drop visual design. Now, this allows you, you can see just an example up here where I'm dragging things in, and what's really cool is what's going on under the hood is by dragging things in, you're tapping into the SDK, the software development kit that we create. It, it, it, when we first built step functions, we had about 7 integrations, 7 or 9, and they were all custom built, and they were nice, they were cool, and then I remember one day the director of step functions came over and he sat down at my desk, he said, Eric, I wanna show you something. And he showed me how they were gonna start using the SDK under the hood on step functions, and I thought that's brilliant and why did we wait so long? That's brilliant. And so what happens when we moved to the SDK, we opened up thousands upon 10 thousands of available services and calls that we can do or calls in services, right? So that's what's happening when you're dragging these in. Right, so you get a real-time execution view. You're not guessing. You get colla you can do it collaboratively. You can send it out, uh, and you get, uh, uh, uh, a, a lot of times an instant understanding of what's happening. So you can see how I've got parallel things happening in here, and I'm, I've got, I'm doing things in order. So there's a lot of power in the drag and drop design. And if you're not familiar with it, I will tell you that you can do this right in your IDE. You don't have to go to the AWS console. Anybody using the AWS toolkit? Oh, not enough of you. OK, all right, so I'm gonna tell you, install the AWS tool kit because what happens is when you open an ASL file, it'll automatically open up in the same designer you're used to using in the, in the AWS console and you could test from there. You can do test state, right? So you could do your ASL. Right there and it generates the same ASL but you don't have to grab it and copy it down and move it around and we're all guilty of that. We did it in the console we copied it down, we substituted things like that so this makes it a lot easier. All right, so the second superpower we've got is direct service integration. I already kind of stole my own thunder on that a little bit ago, but the idea here is. When we build, if you think about Tony's architecture, it's a lot of code, right? And so spaghetti code, and so he's handling, uh, you know, the calls and what he's doing is he's doing SDK calls in his code and so he's calling out and he's saying, yeah, I need to, uh, you know, save an order. I need to send a confirmation to SNS. I need to update inventory. And what we find is when people are building step functions, a lot of times they'll use step functions to invoke a lambda function to make a SDK call, but you don't need to do that, right? You can do the SDK call straight from step functions, right? So that's bull, that's a superpower number 2. Now this is a quote. I love this quote. Uh, Jay Nair, who used to be the director, previous director of, of lambda, he said this, but I plagiarized it. Sometimes I just take credit for it, but I think he's, he might be here. He has people here, so I'm gonna give him credit. But he said, don't use lambda to transport, but use lambda to transform. And this is where that really comes in. And why do the dirt, why do you use the lambda function when you don't need it again, I'm not anti-lambda. Let's be very clear, OK? So I love this. All right. Superpower number 3 built-in air handling. Now I wanna tell you why this is super important, OK? I've already talked to you about the two types of developers we are, right? And, and there's me and then the rest of you who are good developers. My title is developer advocate. It's such, it's such a misleading title. So, uh, I'm an architect, but I'm an average developer, and I am not good at writing error handling. Who loves to write error handling? OK, good. OK, there's one person where I think you're lying. I'm gonna be really honest. I'll bet you're gonna tell me you love Coors too. Not the beer, that's OK, but the, you know, like, yeah, I love cores, I love wrestling with browsers. So, all right, fair enough, VTL VTL, that kind of stuff. All right, so yeah, error error handling, writing error handling, there's nothing wrong with that, but a lot of times we end up doing that instead of actually writing code that counts. So superpower built in here is we can handle errors right in step functions. We literally do a catch, and I'm kind of showing the example over here where we do a catch and we give it some description. You can catch different errors and say, look, if. Anything happens, do this, or maybe I'm just saying if this fails, then do this, right? So there's a lot of strength in that, and you can add multiple catches to do different things, right? So you, so this is really cool. And then you could also configure things like dead letter cues, right, where you can actually say, well, look, we've tried, we built a retryer, it tried again, it even the retries are failing, so let's go ahead and save that, and then we'll have someone work on it, and that's really good because the, the worst thing possible. Is when you have to call somebody and go, you know, I know you gave us your credit card and a payment, but we lost it. But we think we got it now. Could you give it again? That's a horrible conversation to have, right? So being able to save data, work on it later, super important. So this superpower number 3, built-in error handling and retry scheduling. Number 4. OK. A lot of you are using uh step functions. You already told me this, good, we can see this. How many of you have started using the variables? OK, alrighty, man, I encourage you to stop and drop and, and. I don't know where I'm going with that to start using that. Stop dropping variable, right? Do that as soon as you can. This is gonna save you a lot. I'm the first to admit that I really struggled passing data from state to state, and variables makes this so easy, right? And so this is assigning variables. And so the number 4 data transformation. There's a couple parts of this, but this is what it looks like to assign a variable. Customer email. I'm looking at the result and now something to understand, and I'll actually say this again a little bit, but to understand is. When to assign the variable and I'll make that clear in just a few moments, but you can see I'm grabbing it from the results. I can grab the or the input. I can also use some Jasonnata to do some, some business logic or to some formulas, right? So this is assigning variables. So what does it look like to consume a variable? Well, anywhere down the same scope, it's gonna look. Something like this, I assigned it and now I have it available through the rest of the state machine. There's some caveats around that, some asterisks, and so, uh, about, you know, child scope versus parent scope. We have documentation on that, but overall being able to pass variables down is gonna save you a lot of code and a lot of times a lot of transitions too. And then finally, so that's, that's assigning and consuming variables, then transforming, I'm sorry, this is what I wanna say. I wanna point this out, you cannot consume variables in the same step. So what that means is I can't assign a variable and use it in the same step because it, uh, variables will. Always be assigned after the step is run and you get the results, so you can't assign it before because they're they're assigned after, but I can use them following and going, going on to the rest of them. And the reason I, I normally I don't take a moment to say that, but I think some people trip up on that so I really wanna pull that out and, and, and explain that part. All right, so finally, the last part of data transformation is Jasonnata itself. We released this last year and you will be blown away at how many just past states you can get rid of. In fact, I would go crazy and say you could probably get rid of roughly 99% of past states. Because you can use the transformation at the beginning of the next state or at the end of the previous state. Now for cleanliness you might have a past date, and I do that sometimes, but these will help a lot because you can do a basically Jason Ata replaces Jason Path. We still support both, but Jason Ata allows you to query that Jason and do a lot of, of really cool logic in there, uh, and so I encourage you to check it out. All right, So, the next one, superpower number 5 is advanced workflow, conditional logic. Uh this probably, now we're getting to stuff you probably know about this stuff, but understanding, hey, I can make choices and do what I need to do. This is how I was able to build an MCP server because I was looking at what are they asking for? Is it a tools list? Is it an initialization? You know, and so you can do the different things, so dynamic routing, business logic, no code branching, and you can have multiple conditions built in there and error handling all built into each one of those. So along with the advanced workflows is parallel processing. This is really cool and you may again this is something you're like yeah we know about this, but are you using this effectively? I look at a lot of, you know, talking to companies and things like that. I look at a lot of them and their step functions is a line from top to bottom. Do this, do this, do this, do this, do this, and when you ask them, did, did you need the output of this to do this, no. Well, why do you have it below? Because when I dragged it out, that's where the line snapped to. Well, OK, but did you ever try snapping it up here? Right, so think about if you understand your workload and your process, think about parallel conditioning map. It'll help you move much faster and safe transitions. So, uh, these are super powerful parallel processing. It also gives you access to, to, we've seen companies that, uh, video processing, they'll take a video and then. Using parallel here they'll split across, you know, well, let's say, let's take a 5 minute video. They'll take the video and break it into to 1030 seconds. I'm doing math in my head. It's killing me. I can get to 2. I can get to 4 if I take my shoes off, but then it's weird for everybody. But I, yeah, math is not my strength, right? So, but anyway, I, they're taking, uh, a video of 5 minutes and bringing it into 1030, 32nd segments, and then they parallel on this and then stitch it back together. So now it only takes 30 seconds, right? Because they're doing parallel processing built right in here. All right, Dynamic or inline maps same thing and I already talked about a little bit using inline maps here you've seen these and finally we get to parallel uh or I'm sorry, uh dynamic. I'm, I can't they pay me to talk here and I'm having a tough time talking today. They do, uh, the distributed mapping. Anybody use a distributed map now? OK, you get a couple of things out of this, uh, first of all, you get a map, right? Well, we already had a map, so it's like, oh, OK, but. What we didn't have was the ability to spin up a bunch of separate step functions. How this works is when I tell it, hey, I want you to process our single pizza order and save the update, uh, and I'm processing through a bunch of back orders, I could just tell it churn on this and it'll bring up and do inline and stuff like that, but if I'm doing a lot of processing, I can spin up a bunch, up to 10,000. Express step functions to do these in parallel and and I could set concurrency so I can protect my downstream. I could say how much do you do. I can batch things so there's a lot of power in these and then the second thing you get is the ability to read directly from S3. So you put because it used to be you'd, you'd say. OK, hey, get a list or use the lambda function to get a list from, from S3 and then pass for each one of those. You do this, but instead with this, you just say, look at that bucket, get do for every object in that bucket, do this work. It's really cool. We use this example. NFL came to us last year, uh, yeah, well, it's been 2 years ago, 1 year and a half years ago. They came and said, look, we have this image processing. And, and we're doing, uh, we, we, we're sending, we get 3000 new images, you know, from all the football teams, and they have to be updated all the time. We have to send them out to contract, and it, it costs us roughly, you know, uh, some, some in the neighborhood of, I don't know, $80,000 and it takes weeks upon weeks to months to do this. So we wanna work with Adobe and so we set, and I was actually part of this project, so I get to talk about it, we sat and, and I built this workflow using this, and it said, OK. When you drop 3000 images in this bucket, start spinning up step functions. And so I would rather than spin up 3000 step functions of the standard kind, I would say point my, my distributing map at it, list those images for each image. I want you to do, we did some fun stuff with recognition, uh, we did some stun then we sent it to Adobe, and they cut out the back using their APIs. They cut out the background, and we did some tone stuff, and then it dropped it back in. And it reduced the time for them to do their image processing from roughly. 6 weeks, anywhere between 4 to 6 weeks to roughly 32 seconds. They were pretty happy with us, right? And it also reduced it, saved them about $50,000. So it, it, I think it was $4000 and a lot of that was Adobe charges. So, um, really cool way to use this, right? OK, so with all this in mind, we're kind of, you know, we're talking through these. This is what Tony's first pizza workflow looks like. Right, so he's got this, he's got, uh, you know, the order's placed, you got payment processing, you got a bunch of different things, right? So this is where we're gonna start. So we wanna take this and see, and, and there's so much to it that even some of it's hidden, right? So we're gonna take this and see how can we reduce this cost and make it more efficient and maybe add some features. So here we go. All right, so the first thing we do when we're talking about this is we need to understand how step functions charge and, and understand. So, if you're using it, you probably understand, or if you're like me and somebody else pays the bill and you just want the fastest and the coolest and you get yelled at later, that also may apply here. So here we go. All right, so I'm starting with express step functions. I'll tell you why in just a minute, but this is request and duration based pricing. Right, and so what that means is the request is charged at $1 per 1 million requests and the duration charge, and I can't even think like this, OK, but let me throw this at you. The duration charge is 0 and then there's a dot and then 123, 40s and then 1667. Figure that out, right? Well, I'll help you out. What that basically comes out to is 1 penny by 600 gigabytes roughly of compute, OK? So it, so that, that helps price that out. So you can see some pricing scenarios here and when we use express step functions, they're volume friendly, memory, and, and duration sensitive, right, because, because they're, you're looking at how much are you using and the time you're using it. So that's express. Who's using express right now? OK, who's using standard? All right, OK, once you start asking yourself, do I need standard, and yes, you may, but I, but I'll give you a thought on that in just a minute. So this is standard step functions. They're transition-based pricing, state transitions of 0.025 per 1000 states or, or transition, state transitions, yeah. Right, so a simple workflow of 5 states, uh, 300K executions comes out to now in my math up here you have executions times transitions and then I put plus start and end. You may already know that, but a lot of people get confused. The transition into start is the first transition. That's one, OK? The transition to end is. Two, OK, and then everything in between, so you count those up and we'll kind of explain that more, but sometimes, and even explaining to, to the models when I was because I was doing this because I can't keep track of all this, mm, you know, so I was having the model. I was like, remember you gotta count the start and the end, right? And so those, and that equals, uh, and then times 0.000025. All right, so give you some idea. So the basic breakdown is the standard they're duration friendly. They can last up to a year, whereas express can only go 5 minutes. Express runs in memory durations or these do not. OK, so that gives you an idea of how to do those. Complexity sensitive. The more complex, the more transitions, the more it's gonna cost you. So how do you choose? Well, here's, here's kind of a, a good rule of thumb. I don't usually do rule of thumb, but there you go. Choose express when you have high volume, short duration, cost sensitive, real-time processing, simple logic, OK. Choose standard when you have long running complex logic, audit requirements, uh, so some logging and stuff like that. Human interaction when you gotta wait for a callback, uh, and exam exactly one semantics, right? So. The way I think about it is this. Start with express and move to standard when duration or feature set requires it. So if you gotta go longer than 5 minutes, go to standard. If you need features that aren't offered in express, go to standard. Now you'll see there's a little squirrel up there. It looks a lot like the squirrel on my shirt, right? Yeah, yeah, I was, wasn't sure what shirt I was wearing, right? Anybody know Sam? OK, couple of you. Alright, so the reason I do this, it doesn't have to be Sam, it could be CDK something like that. Sometimes you can't take and go into an express step function and say now be standard. You have to redeploy. Basically you create a new one. But if you're using SAM or CDK or Terraform or or SST or any of those, then that's really easy because it's literally just a change standard to express or express to standard and redeploy and off you go. So if you're not using IAC for your uh for your step functions and for your applications in general, talk to me. You really need to be, so I encourage you to use that. Excuse me one second. All right. So, let's go back to Tony's story here. And I wanted to throw just some, some assumptions and specs out to you to get some real pricing, right? So, no, we're only pricing the step functions and the lambda functions. We're not pricing all the stuff behind, right, because there's a lot of variables there, but I just want you to see what we're saving on step functions. Right, so here's his business volume, 4.3 million orders, 360,000 orders monthly, and he's using standard. Because he's polling and things like that, right? He has lambda function specs 1024 lambda memory. He has multiple lambda functions, order validation, payment processing, and so on. And then he's got one external API that, uh, handles some, some routing, and there you go. So this is the general kind of uh assumptions and specs for this now. We gotta count up our transitions and stuff to figure out how much this is gonna cost. So you'll see some of these are blocked out. So here's how this works. Here's how I do it. In this step function, we have 11 transitions that run one time, including the start and end. OK, it's probably the last time I'll remind you, but maybe not, right? So they run one time so you can kind of get an idea. So we count those. Then we've got some loops, right? So we've got a payment loop and it checks the payment process every 5 seconds. Average payment time is 30 seconds, so it's about 17 transitions, give or take. We have another loop in here that checks fraud status, and it's calling out to a system, uh, and it checks every 5 seconds. Average fraud check is 90 seconds. It's 53 transitions. And our final, final loop checks prep status every 1 minute, and the average prep time is 30 minutes, so we have 89 transitions. That's probably a little aggressive, but that's what Tony does, right? Cause he wants to know how it's going. OK. So here's Tony's baseline costs and also what I call the wall of text. You don't have to memorize all this, but kind of getting this idea of everything going on, but our monthly total is $1770 or roughly 0.0049 cents now. Business wise, there's a chance Tony's like, yeah, I'm good with that. And move on, but there's a lot we can do to bring this down and to improve how it runs. So let's, let's get started with that. Now we're gonna talk through the patterns, OK? And this is the production great stuff. So let me jump into this and we'll kind of talk through some of this. We'll start with some simple and we'll kind of get more complex as we go. All right, so the first pattern we're gonna talk about are the foundational patterns. So the first thing we need to do is we need to get rid of the callbacks, right? Callbacks, sometimes they're a necessary evil, but if you don't have to do them, don't do them. There's a, there's a buddy of mine who actually used to do a presentation, uh, the, the, uh, previous one called Ben Smith, and he's, he's actually running around here at Reinvent Somewhere. He works for a different company now, but he tells a story, and it's so, so good, you know, when you're, when you're driving with your kids and your kids sitting in the back and every 5 seconds, are we there yet? Are we there yet? Are we there yet? It's chatty and annoying, right? So same with polling, it's chatting and annoying and it's expensive. So how do we take care of this, right? So here's, here's 2. Now I said there's 3 in here, but we're just gonna look at 2 for the moment. So we have two loops right now. We have the payment polling and the pizza preparation polling, the first and the last one, and there's 17 states and 89 states combined 106. They're costing us roughly $956 a month. That's over half of our bill. So we need to think about how can we get rid of these. All right, so, here's what we're gonna do. We're gonna, the callback cure. And we're gonna do the wait for callback. Now there's 3 ways we can do this, and we'll talk through the different ways, but the first is what we call the request and response pattern. The request response request a res OK. Anybody else wanna take over? The response and request, request a response pattern, what that does, it's literally a fire and forget. Hope you've heard of that term, right? So we say, here it is and I'm moving on. Do your work and finish. I don't care how it works. This works for some things, um, it's not, not always a lot of times you need to know when it's back and if it was a success or fail. Sometimes you need data, so. The next one we can do is what's called the dot sync pattern, right? So the dot sync pattern actually, when you send it, it, it sends it out and then it waits. So this doesn't work with all services. This only works with, uh, there's about 17 or 18, but you send it and then it, the step function stops. It says nope, I'm not moving on until I hear back. Either a fail or success. However, you still don't get data back, right? So if that's OK with you, so your first pattern says go and I'm moving on, your second pattern says go and I'll wait, but I don't care about the response. I just need a 200 or 400, right? But a lot of times we need to know what happens. So the last one we, we have is what's called the task token pattern. And so how this works is we send out. A request, it, it comes here and it stops and sends and, and you can do this a lot of things. You can invoke a lambda function. You can, you can invoke an ECS, uh, container. You can call batch. You can do. There's a lot of different things. And so what happens is it says go do that and then when you're done, call back with this task token. And step functions will say, OK, I know where that test tokens is related to. Here's, and you can send data. Here's the data. Here's the results. You can now move on, all right? And so that's the one we're actually gonna look at here when we set this up. We're gonna do two things, OK? So. What I'm gonna do is I'm gonna take our process our payment process, and I'm gonna send it. We're gonna use external. We, we chose Stripe because I think they're here and I got buddies that work there, but this could work with any of them, OK? But one of the cool things that Stripe does is they have an event bridge partner bus that you can set up. So the way this is gonna work because normally we would do web hooks and we got to expose an endpoint for them to call, but the way this works is our system is gonna send out a payment with a with a token. And then Stripe is gonna process that and then kick an event in the event bridge into event bridge, and we're gonna add a second or another lambda function that's called a task token listener and it's gonna listen for these event calls and grab the token and send it back into the system. We're gonna do the same with our kitchen for the prep time and we're gonna give them a uh an IOT button where they could go done. Or smiley face, sad face, I don't know, maybe we'll give him a computer, but we can do that also that sends an event and our task token listener sends an update back in. Right, so what does that look like? Well, Here's where it is. So I'll give you a little bit of code. Here's some Python code. Um, so when we do callbacks, timeouts and heartbeats matter. You don't wanna send it and say sit forever because like Werner Vogel says, everything fails all the time, right? So you wanna say if I don't hear from you in X amount of time, I'm gonna cancel it. If I don't get a heartbeat back from you. Within X amount of time I'm gonna cancel it and so here's some code for sending heartbeats, uh, and so you can set a task heartbeat to say, hey, I'm not done, but I'm still working on it. Don't, don't, don't give up on me now. That's a there's a song in there somewhere. So, all right, so that's how that works now I really encourage you, and I said it earlier, proper timeout settings are critical. You've got to set these, make sure that you're doing the math to figure out how long you're willing to wait to figure that out. So let's take a look and see what that did for Tony's baseline workflow. Well, first of all, it all fits on the screen, that's a pretty big step. Right, we were able to crunch it down. We got rid of some of the loops. We eliminated 104 transitions. We added a task token listener, so we added a lambda function. We dropped 3, so net we dropped 2 lambda functions. So in step functions we saved $936. In lambda we saved $108 with a total of $1,044. So that brings us now to $594 for step functions, $138 for lambda, a total of $732. We could quit if we want. But that's not who we are, right? We like cheap pizza that tastes good with no pineapple on it. That's the biggest part. All right, so I saw some heads there, yeah, yeah, yeah, there should never be pineapple on pizza, but that's not why we're here, OK, but I will die on that hill. OK, so that's, we got that far, so now let's take care of that other pole. Now this is a little different situation with this they're actually sending out to uh in a VPC to a pool of containers, right, that they, and, and this containers does uh uh handles all this uh fraud stuff. So what we're gonna do, we got, we're, we're saying it's a VPC lambda function that calls ECS hosted fraud detection API. So how can we get rid of that? This is a pattern that quite honestly, I didn't learn about until last year and now it's one of my favorite patterns. I love this, and it's called the activities pattern. Now I'm gonna bet my right arm and Matt's salary that nobody here is using. The activities pattern anybody? OK, hopefully next year you will, and here's why. Here's how this works. So you go into step functions and you create a, an activity. You literally just go to the console and say create an activity, and then any number of step functions can send data into that activity here, and what activity really is, is a, is a step functions managed queue. And that will actually take care of that for you. And so this will, this will actually handle that. And when you send it back in, then they move on. So super, super strong pattern, and I love this. You don't have to just take my word for it. Uh, this was posted in September, a few months back, inspired by a great session by EDJ Geek or whatever. OK. Uh, we made changes to an AW step function reducing its cost from $450 to around $1. Now I gotta ask them, wow, one step function that was $450 for one invocation. What were you doing? But still, they were doing a lot of stuff that they were able to move into an activity and saved them a lot of money. Super cool pattern, I encourage you to check it out. All right, so here's what that looks like. So we're able to do that and I'm gonna read all the numbers this time, but you kind of get the idea. We had a total monthly savings of 587 because we've cut all the loops. So that's a huge thing. Getting rid of the loops is the big thing. But let's look at some integration patterns that we can add. First of all, this is a really simple one, and there's a couple of ways you can do this. I chose the first one to show you, but this is what I call the crud machine. OK, red, when we say that, create, read, update, delete, standard rest, and the way it works, and I told you we have this external lambda function that's actually handling that routing and then invoking the step machine, but we really don't need that. It's easy because a a Amazon API gateway automatically proxies a lambda, so it's an easy pattern to do, but we really don't need that, and I'll show you why, because you can actually talk from API gateway directly to the step function. Now, it's not for the faint of heart because it does require VTL, but this is an example of what a VTL template looks like. Who uses VTL now? Oh nice, I got a couple of. Do you love it? OK, yes, you do. Come on, yeah, do you love it? OK, alright. VTL stands for, uh, velocity templating language, and that's an Apache thing, and it allows you to at the API gateway level change that request to what to what step functions needs and the response, because once it tells step functions go, step functions just sends back a 400, so you can add something like your, you know, your, your response is good or if it's synchronous or asynchronous, however you wanna do it. So super cool pattern, but again not for the faint of heart, but with things like Quiro, uh, it makes it a lot easier. You may not know VTL I don't know VTL Quiro knows VTL and it works really well, so good challenge. All right. So the other way to do that is you could actually have a, you can either have, and I, and I'll show in this, the way I like to do it is I do a separate one for each thing. I have one step function for crud, one for or one for create, one for read, but you could also write in the step function, look at what's coming in. Is this a create, a read, or update, and go into, uh, different lanes depending on that too. It's really up to you. Like every good technical answer, it depends on how you like to do it. All right, so the next pattern we're going to look at. It's called the private API connections. So get a drink here real quick. We also announced this last year. In this, in our HR system, we do a check driver availability and what that does is who's who's on, who's, you know, all kinds of, where are they, you know, we've got 80 stores, that kind of thing so it actually calls an HR system, but it calls it in a VPC. Right, so what we have to do is we have to have a lambda function sitting in a VPC that we invoke from our step functions and then the lambda function calls that and gets the answer back. Perfectly viable system, but we don't really need it because with Amazon VPC lattice and direct connection with Amazon EventBridge, you can do a secure connection directly to a private endpoint inside of there. So now we've dropped the lambda function and we're talking directly to our ECS cluster. And all that is, is now in step functions it doesn't look like a lambda. Now it looks just like a little API call. You could do this for public APIs and private APIs. And what's really cool is you can call it from multiple different places and use the same event bridge connection, right? So you create the connection in Event bridge and then you use it for security for the actual, uh, endpoint. Alright, so what does that do to our baseline workflow? It, uh, it brings us down some more, saves us $12. OK, all right, we're not dancing around, you know, popping champagne corks and stuff like that, but it's $12 right? That's at least 6 Diet Doctor Peppers. OK, so there you go. All right, Texas references right there. A lot of you if you're from Texas, OK, OK. So the next thing we're gonna do is not actually remove anything, we're gonna create a chatbot. Because we like to do ordering, we have people that say, you know what, we wanna, it's all API based, we want, uh, conversational order experience. Tony's a developer. He wants to play around with this. Yeah, you may say, well, we got agent core, we have durable functions. Anybody hear about the durable functions? We, OK, good, we'll talk about that in a little bit, um, but you can also do these in step functions, and they're really a cool way to do this because you can have API gateway invoke the step function. Then you can have, you can validate the input, then you can in parallel get conversation history as well as the knowledge base, and then we get back, uh, the general response we use a lambda function to call Bedrock because we want to do streaming and we can send that back through WebSockets and finally we store the conversation. So this is a very basic straightforward bot that we control all the knobs and levers. We control the history conversation history is in Dynamo DB. We can, we can, uh, and my icon has apparently disappeared. Uh, we use maybe. We use uh Kindra. We use, uh, Bedrock agents or, or Knowledge Base for the knowledge base there. So this gives you real-time web socket streaming agent run entirely in step functions with just the lambda that handles the, the the just the streaming responses. OK, so in this one we, like I said, we didn't remove anything, so this is gonna actually add some cost, but it gives us a lot of benefit because this, the whole thing here allows them to order through the, through the AI and makes Tony feel modern and cool, right? So what does that do? It's gonna cost us about 88 cents. Now I'm again, very clearly I did not add the bedrock costs. I did not add, so there's gonna be some of that, but from a step of functions and a lambda point of view. 88 cents There you go, so we've added this feature. OK, so there's our integration things. Now we're gonna look at scaling and performance. And I'm moving pretty fast and I know that I wanna make sure I can get through all these. OK, so Nest of workflows. Tony has, he's gone from one kitchen to 80, and that pro that that introduces a lot of things. We, we have, uh, 80 stores that are going. We simple check inventory state is insufficient. We need to add more to this. So what we're gonna do is we're gonna create a location finder and. Location finder is going to be a nested workflow that does several things. It's going to check location capacity, check inventory levels, calculate delivery logistics, use Bedrock to figure that out, kind of take all that information. So we've got parallel, then a single call, and then it's going to kick that back to our primary step function. Right, so I could run it in standard which would cost me $40.45 dollars, or I could run it in express which would cost me $17.07 72% cheaper, right? So really think about what do I need here and in this type of thing going on, I don't, I just need express because it shouldn't take longer than 5 minutes. If it is, then your, your customer's annoyed, right? So good way to do nested so you can see here in the nested we've got we're, we're inserting that, uh, right here. It's kind of hard to see there, but that's the, that's the find optimal location, right? OK, so that costs us $17 a month. So we have 88 cents we've added and $17 and that brings our total cost for running, and we kind of missed the big drop again, but $150 a month is where we're at. That's absolutely worth a, a point of sale system, right? We go, OK, we're done, and we're handling so much, but Tony's an overachiever. So let's see what else we can do, right? So the other thing he has now he's got all these stores, he has monthly analytics across all locations, right? So he's got all this kind of data and he has to collect a ton of data. So this is a really good place to plug in something like distributed maps because we need to do a lot of processing. So this is what that looks like. So we're gonna do S3 integration. So we're gonna say, hey, here's the bucket. Every month we can use event bridge or a report scheduler, uh, to do that. It's event bridge for the scheduling, and we say every month run this, and it's going to grab all the information. We're gonna use a. Lambda to process it. We actually have two different things happening here, right? So I can, and, and this is where it gets really clever because I can actually control what's happening through the different ones. So like maybe our HR system isn't fast enough so I can control that, but I'm calling through that same. Uh, through that same connection, I could call our HR system and get the data, and I could control the concurrency so I don't beat up the downstream systems. But this is where dynamic map gets really powerful because I'm calling two different ones and doing the work in parallel to pull that all together. I used to be a night op and this kind of stuff would take hours and hours and hours. Now this takes seconds and seconds and seconds. It's very fast when we can process that fast. So what does that add to run this? Roughly $21. So now we're back up. So we're $172.52. OK, so the next thing I wanna talk about, we've, we've gone through some integration, some scaling patterns. Now we need to deal with resilience patterns, OK? And I'm moving fast. I hope you're staying with me. You're all still orange. That's good. So I'm excited. We'll get some orange over here. That's good. All right. All right, there we go. All right, here we go. All right, so the next thing is resilience patterns, production grade reliability for Tony's workflows. So External dependencies, who loves them? Love external dependencies because we have no control for them. Uh, Gregor Hope says the amount of, uh, dependency on an external or dependency on an API, I'm destroying this quote, is basically on how much control over you have it. The amount of coupling should be based on how much control you have over it. Third party dependencies, we don't have a lot of control over it. So we need to be able to deal with or degrade gracefully when something doesn't work. So step functions, I'm sure you've heard of this. Anybody heard of a circuit breaker pattern? OK, pretty common pattern. step functions makes it really easy to implement. Let me show you what this is. So here's a general, I'm just gonna show you a general one here first and then we'll see what it looks like in ours, but basically how this happens is we come in and we check the database when the call comes in we say all right. Is the circuit breaker open, meaning it's not working, or is it closed, meaning I can loop through. So if it's open, then we're gonna go ahead and evaluate that. OK, it's open and we fail because payments aren't working. But what if we don't fail if it's, if it's closed or doesn't exist, and you can do these can look a little different basically if it's closed or doesn't exist, then we're gonna go on and we're gonna try the payment process. If that fails, then we're gonna open the circuit and we're gonna fail the payment. And then, and now the next one that comes through will know the circuit's open. However, if it works, then we're gonna, we're gonna actually write to the database. If it didn't exist, we're gonna say close the circuit. It's working now, right? So when you have time, you. What you do is in the database you have time to live so that these drop out after a while, OK? Finally then we go to circuit breaker. So when we add that into our, our workflow, it only adds about $27 but think about how much money it saves by not double charging people and not frustrating your customers. So that's a circuit breaker. But sometimes things go wrong when you're paying, you know, or when you're doing that, and you have to handle what we call compensation logic or you have to deal with compensation for things that, that didn't go through. For that we use, uh, a Sega pattern, right? And so we wanna keep transaction, transaction consistency while we're doing payment and inventory. So let me show you how this one works. With this, this is how a Sega pattern works, saga, saga pattern. All right, so we process the payment. If it works, then we go ahead and allocate the inventory. If that works, then we reserve the driver and it's complete. We're happy, pizzas are delivered, all is good. But what if reserve driver fails? So then what we do is we compensate our inventory by putting that inventory back. And then we compensate by by refunding that payment or stopping the, the, the from going through and then we fail that out again. This is gonna help you not to take payments that you shouldn't have taken and then you have to call them and go, yeah, we blew it. That's the worst and that's frustrating. I've gotten that call, hey, we're not gonna be able to deliver your pizza, right? so. That's how, that's how Sega works. When we add that, interestingly enough, it doesn't cost us too much because when you think of Happy path, and that's what, that's what I'll run the most time, we're only adding, uh, one net transition to do this. We got rid of some others and we added one, so it's an increase of 1,282. Uh, some pictures on that one. All right, so hopefully. That helps you kind of understand we've done a ton of stuff, so let's see where that takes us, OK? We've, we've added a lot of patterns, we've added some features, so here's the journey. What we did is we went from $1770 a month and we reduced it to $212.34. That wasn't the lowest. We went down and we came up a little bit, but we gained a chatbot, a location finder, an analytics processor, and we added circuit breaker and Saga to the system. So this helped us a lot to have more efficient step functions at, I mean just a ton less money. Now I wanted to, and I don't have a slide for this, so I'm just going to do this for a moment there we go. I asked you earlier, how many of y'all raise your hands for durable functions? How many of y'all heard of durable functions this week? OK, so for those of you who didn't, durable functions is an orchestration. That works in lambda. So it creates kind of an elephant in the room, doesn't it? Right? So the question we get and the question we're prepared for and I'm gonna talk about it real quick is which service do I choose? Right, well, here's our approach. Here's our saying. If you're, I can give you some guidance if you're like, look, Eric, I need to know when is when. Things that I think about is if I'm doing large cross AWS services, I'm probably gonna stay with step functions. If I've already got stuff in place, that's gonna be fine. If I'm doing more application level, I'm going to, I'm gonna go to durable functions. However, the truth is you can do almost all that stuff with both. And the reality is we unapologetically offer you both and say if you like to drag and drop, if you like to do if you want that visuals do that if you want code and you prefer code and local testing do that we want you to be able to use both so choose what you like, uh, and have fun with them. I really encourage you to check out durable functions, but I can tell you. There's a lot of stuff that I'll stay with step functions with, and there's a lot of stuff that I'll go to durable functions for, and more importantly, most likely I'm gonna be orchestrating durable functions with step functions. You see, you see where you see the meta there, right, it's inception right here in at AWS, but it's gonna happen. So that's what I encourage you to do when we talk about that, um, step functions are cool, durable functions are cool. Use them, right tool, right job. All right, a couple of takeaways I would give you on this. When you're building, when you look at Tony's story, you start with the problem, not the pattern. Tony's lambda chaos wasn't a lambda problem. It was an orchestration problem. Set function solved orchestration, error handling, and state management. Cost optimization comes from smart architecture. There's a lot of things you can do to be smart about your architecture to save a lot of money. Production patterns improve or prevent production problems and improve your reliability. Sega patterns, circuit patterns, things like that, super important to understand and to use, uh, and they save a lot of manual work. Modern features accelerate development. Man, I, I, I, I noticed a lot of you hadn't raised your hand for Jasonnata. I'm not scolding you. I'm really not. We have so much, and it's like, ah, but I do encourage you, for you, check it out. Kiro knows Jason Ata really well. It, it does a good job. So, uh, observability is built in. Use that. You don't, you don't have to bolt it on. It's ready to go. Scaling comes from design, uh, not infrastructure. So when you design and get, you can, you can obviously step function gives you a lot of flexibility. Now I don't wanna leave you with just that. I have a set of resources, uh, that I encourage you to look at. Uh, this is S12D.com, uh, and, and, uh, check out this link. I put together some resources for you that, that'll help out. We've got a few other sessions I really encourage you to look at, uh, and they may be, you, you know, we may be too late, but, uh, 4:30 Mandalay Bay, uh, simplifying orchestration with Jason Otto and AW step functions, man, if you can get over there, check that out. Uh, API 304 was, is a little later, so it's gonna be a rush, uh, and that's, uh, G AI powered workflows, uh, and that's a builder session, and then, uh, service press. So first of all, get the coffee in the expo hall. Hopefully you've gotten some coffee already. Second of all, do the workshop. It's a lot of fun. Uh, I encourage you that couple more resources we've put together some overall resources for service here at AWS. Uh, I encourage you to check this out. And then finally, I really ask you, uh, I fill out the survey. We wanna know how we did. Uh, I hope that, I hope you enjoyed today's session. We, it was fast paced, but it was designed to be that way. With that, I hope you have a great rest of your reinvent and replay. Thank you very much.