---
video_id: bZjF_LU8cPw
video_url: https://www.youtube.com/watch?v=bZjF_LU8cPw
is_generated: False
is_translatable: True
summary: "This presentation, titled \"What Database Would Your AI Agents Choose - Escape the Frankenstack\" (DAT203), addresses the growing complexity of modern data architectures, dubbed the \"Frankenstack.\" The speaker highlights how systems often evolve from simple, clean designs into unmanageable monstrosities featuring multiple databases, caches, message buses, and fragile ETL pipelines. This complexity doesn't scale linearly but factorially, leading to \"haunted\" production environments plagued by latency spikes, data inconsistency, and nightmare on-call rotations.\n\nThe talk emphasizes that while a multi-store architecture might look impressive in a POC or hackathon—bolting on separate stores for optimizing, vectors, analytics, and search—it becomes a liability in production. The speaker illustrates this with a customer story of an e-commerce platform's pricing engine. A simple user request fans out to independently operating systems (key-value stores, time-series DBs, vector DBs, search engines), creating a fragile web of dependencies. This \"Frankenstack\" results in stale caches, drifted embeddings, and high operational costs, with engineering teams functioning as \"skeleton crews\" just trying to keep the system alive.\n\nAI agents exacerbate this problem because they are interactive, stateful systems requiring real-time access to structured, unstructured, and vector data. They cannot afford the latency or inconsistency inherent in disjointed architectures. The speaker argues for flipping the problem by starting with the AI agent's needs: a single system that can handle enterprise data and run common functions (like vector nearest neighbor search) with minimal data movement.\n\nThe proposed solution is a unified database approach (implicitly championing SingleStore, though the focus is on the architectural pattern). By consolidating workloads into a single data store, teams can achieve significant benefits: 3x fewer lines of code, fewer database connections, reduced failure points, and simplified CI/CD. This shift moves production from a \"haunted house\" of forgotten cron jobs to a predictable, well-lit system. The ultimate payoff is speed—not just system performance, but \"human speed\" and \"feature speed,\" allowing product managers to ship features in weeks rather than months and engineers to enjoy quieter on-call shifts."\nkeywords: Frankenstack, AI Agents, Data Architecture, Unified Database, Operational Complexity, Vector Database, Real-time Data, SingleStore, System Scalability, Technical Debt\n---

All right, thank you for coming. So who here has intended to build a Frankenstack? None of us, none of us say, you know what sounds like fun? 6 databases, 3 caches, a message bus, 2 streaming platforms, a homemade ETL pipeline that runs only on full moons. It just happens. Like when you forget about that Halloween pumpkin and it suddenly collapses into an orange pile of goo on your porch. So, again, quick show of hands, how many people here maintain more than 5 data stores right now? And how many of you suspect there are even more than that, that have not been touched since the year 2020? All right, so you're in the right place. This talk is really for all of us. We're gonna explore how Frankens snacks happen and why AI agents make them worse and how to aven and how we avoid ending our careers managing something that looks like it escaped from a haunted data center. So teams tell me the same story over and over again. The demo's easy. Production, that's where the real work is. And not just like a little work, like a village of work with like guilds and blacksmiths and stuff. Complexity doesn't grow linearly with systems or even exponentially. With data sources, it grows factorially, and nobody wants a system that scales factorially. It's like adopting a kitten and waking up with a herd of blood hungry lions. So let me ask you. How many of you feel like your system works great until suddenly it falls apart? That's at the end of the day, the Frankenstack effect. And here's the twist, AI agents are actually going to amplify this effect. Significantly. So let's dive in. The. So of course this is how it starts. You have hope, you have ambition, you have a clean architecture diagram. In this case, we have an AI agent stack, the web mobile app, an OLTP system, a vector data store. It's good enough To win a hackathon, it's good enough. To get your boss to give you an applause, and it's good enough to maybe even win a trophy, with the very at the very least, get yourself a free t-shirt. We're in the honeymoon phase at this point. You've wowed the team. Your POC works. Maybe even you have a demo video with some upbeat music. Someone in the back shouts from rags to riches, and you don't even groan at that dad joke because you're so proud of what you've made. Your architecture feels extensible. You need search, no problem. Bolt on another store. Need recommendation engine, no problem, bolt on another store. Need analytics, no problem, bolt on yet another data store. And of course this is the point at which we all say we'll clean it up later. But we all know the truth. We've all built these systems before. We're not cleaning anything up, ever. So a monster starts. The complexity doesn't start very loudly, doesn't start with a bang, it starts with little whispers. Grows at the seam with every new data store, every sync job, every environmental variable, someone adds, just for the time being. Frankens stacking is not one bad decision. Happens because of 50 reasonable ones. And once the symptoms appear, the creepy crawlies have made home in your system. And the symptoms come out latency, cash inconsistency, schema drifts, surprise cost, a debugging process that takes 3 slack channels, a seance, and goat's blood sprinkled 3 times over your left shoulder. There's aren't big dramatic failures, they're annoying, creepy crawly ones, like the little beetles that get inside your pumpkin and turn it into mush. So let's move from the theoretical to a customer story. A high scale e-commerce platform running a pricing optimization engine. Here's where all of these little decisions have added up. So we're gonna start with a user who's clicking buy now on. I don't know, maybe a Frankenstein costume, let's say. We want to personalize a discount based on their intent. In live inventory, very normal, very normal. At this moment, your system springs into action. You're, it's gonna hit the inventory system, your OLTP database, event stream's gonna work. All very classic patterns. We're about to see like a tiny spark hitting those dry fall leaves when an agent comes into play. All in the request fans out. All the different systems that we're going to touch, and each of these different systems is going to operate independently. With its own SLAs and its own quirks. So the next step, our agents brings an action. It's gonna be in orchestrating by pulling. Uh, cash profiles from your from your key value store. Recent behavioral trend from your Time series database, and blending that together with a pricing engine. Next, we're gonna add search and discovery. So it's it's gonna queries your search DB for similar products, queries your vector DB for embeddings and similarity matches, going back to your product catalog and your inventory levels, pulling all of that. And of course we're, we're hoping that this returns in under 50 milliseconds. But of course we're not even done yet. There's more. You want to improve your models. So you're adding in your lake house, you're adding in your analytics warehouse, reporting tables. Model training orchestration, all of that data is now exported, transformed, re-ingested, versioned, stitched back together to be put into the online system. Not only that, we essentially have two parallel stacks, one for our real-time and one for our batch. Our architecture is now basically a giant spider web of interdependencies. In our POC our life was simple. We had maybe 3 systems, a web app, OLTP database, a vector store. Fast forward to production. We now have a small village of systems. So, quick show of hands, how many of you have an architecture diagram more like the one on the left than the one on the right? It's OK guys, this is a safe space. You can raise your hands. I see some, I see some paint smiles. Not on the left, right? So it's OK. This here is your support group. Instead of going with the clean architecture diagram, we have an architecture diagram that looks like we've disemboweled a Martian, put it on a slide, and said, yeah, sure, ship it. It's perfect. And the worst part here is those of us with experience know. That over time, supporting the architecture diagram on the left is even worse than building it. Right, cause like, Let's look at some zombie pipelines over here that should have died years ago. We have skeleton crew for support that isn't even pictured here, the, the real human cost. And a web of connection that feels like the world's saddest haunted house. And the whole thing works because you have an entire team of people who are living and breathing every day just to keep this propped up. So let's go ahead and enumerate some of these costs. Latency, which spikes unpredictably. Embeddings that drift, caches that are stale. In complexity that ramps up. Suddenly, everyone, instead of getting a good recommendation, is getting a recommendation based on your interest in clown shoes. You fix one problem, and there's more problems decomposing over in the corner. In a week or two, you know you're going to have a whole field of rotting pumpkins, but don't worry, you know that you have a new project upcoming, a new job offer, and we're going to get over to that new one before anyone notices that field of rotting pumpkins. And of course, the hiring burden for this, to keep it up. We haven't even talked about that because you need experts in each of these different data stores in order to operate them. Our agents aren't dashboards, at the end of the day. They aren't batch jobs. They're interactive, stateful systems that need real-time access to structured, unstructured vector and event data. If even one of these pieces is slow, the entire system collapses faster than a rotting pumpkin on December 4th. So let's flip the problem around. And let's start from the agent's needs. Instead of the systems that we've inherited. Things are about to get simpler. First, agent needs one system that reads their enterprise data and runs common functions like vector, nearest neighbors, with minimal data movement, and ultimately minimal overhead. Needs faster development patterns, fewer lines of code, fewer dependencies to babysit. Ultimately, that's also fewer tokens going in and out of the models that are, that are building them. Every external system you remove is one less SDK to upgrade, one less client library to patch. And one less, why is this suddenly failing in production message that you're getting at Slack at 2 a.m.? Of course, agents need fewer processes to monitor. Every background job, every sync task, every streaming consumer you bolt on becomes one more ghost haunting your on-call rotation. We want fewer demons involved, and of course that's both the technical and Halloween sauces. So when you start with the agents' needs, architecture looks less like a haunted house. It starts looking like something you can actually support on Monday mornings. So our customers won't let us play with their production code, but I can recreate something, recreated a demo of what it is they did, just to get some metrics behind the Frankenstack effect. Huge differences, these are measurable differences, measurable cost, measurable differences in velocities. Just look at lines of code. 3X difference between single store versus a bolted on system. Database connections With each database connection, again, that's more maintenance that has to be done. 1 verse 2 failure points. Only 1 to manage instead of 3. Just, you can, with each different edition of databases, data stores, that's more room for gremlins to hide in your stack. So let's talk about the part every engineer in this room feels. Why a single database makes production feel sane. With everything living in one place, your production stops being a haunted house, maze of pipelines, caches of sink jobs, and why is this table only updated at three-quarter moon cycles? Your debugging is predictable. CICD much easier with one system. On call is quieter. Significantly quieter. Many fewer people involved, much faster incident resolution. Not to mention scaling, scaling gets easier as well, with one system to scale up, one system that's billing. One graph to watch. One team of experts who can do all the hard work to debug your one system. So we've gone from a house full of spooky corners, dangling cables, forgotten cron jobs, to a clean, predictable, well lit system that your agents can use and your teams trust. All right, so let's go ahead and we'll bring this home now. When your team moves from a Frankenstack to a unified database, the very first thing you will notice is speed. Not theoretical speed, but human speed. Team speed, feature speed. Because everything is now working on a single data store. You can ship updates without having those 3 team meetings or that one meeting that really should just be an email. Product managers like me can get features out in just weeks rather than months of wrangling all of the different engineering teams to get it done. Nobody has to maintain that one mysterious ETL job. We know that ETL job, the one that only runs on full moons the day after February twenty-ninth. So Here's the big message that I wanna leave everybody here with. Your Frankens snack doesn't happen because of a bad decision. Happens because our architectures are built for dashboards. And now we're asking them to power real-time multimodal AI agents. AI agents that need real-time state, they need low latency access, they need consistent vector, structured and unstructured data, and no surprises. So I want to go ahead and thank you all for joining us. Thank you for being here. Thank you for putting up with all of my bad Halloween jokes. And I hope you have a great rest of your reinvent. By the way, if you want to learn more about Single Store, we are at booth 1559, or ask the guys in the back over there with their hands up. Thank you all very, very much. Have a great reinvent.