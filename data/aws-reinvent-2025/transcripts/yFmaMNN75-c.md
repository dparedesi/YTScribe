---
video_id: yFmaMNN75-c
video_url: https://www.youtube.com/watch?v=yFmaMNN75-c
is_generated: False
is_translatable: True
---

Welcome to CNS 367 and good afternoon, everyone. Debugging lambda functions can seem challenging, but it doesn't have to be. Today we'll share some exciting new features that transform your development experience and make it a breeze to code, test, and debug your lambda functions. I'm Shridhar Pandey. I'm a principal product manager and I lead developer experience in Servales. With me today is Harold Sun, senior software engineer on Serves. Let's get started. OK. Let's do a show of hands. How many of you spent 30 minutes or more debugging a lambda function recently? Who looks like many of you. Does this sound familiar? Debugging lambda functions has traditionally been a time consuming process. Where you have to reportedly, sorry, repeatedly add logging, deploy, invoke and check logs. This can disrupt your flow and impact productivity. But what if there was a better way? What if you could seamlessly test lambda functions on your local device without even deploying to the cloud? And what if you could debug lambda functions in the cloud as easily as your local code? That's the desired state we've been working toward. All right, so here is what we will cover today. First, we'll discuss the current serviceless developer experience and its challenges. Then we'll introduce new features designed to transform this experience. And we'll share best practices to make the most out of these features. Finally, we'll look at what's coming, what's coming next. So, before diving into the session, Let's start by understanding the surveillance development workflow. Surveillance developer experience can be conceptualized as two distinct but interconnected loops. The first is the inner loop. The inner loop is where you spend most of your time on your local development environment. It's all about rapid iterations. Write code, test locally, debug, and repeat. The goal here is fast feedback cycles. And the loop begins when you push code from your device to a production, staging, or integration testing environment. It includes CICD pipelines, staging, deployments, testing, and observability. The cycles are less frequent, but the stakes are much higher. The outer loop involves team collaboration and coordination. And this is where works on my machine meets reality. So Let me, let me ask you this, what do you think is the most important required uh requirement for the inner loop? Venture a guess? It is speed. Developers need fast feedback cycles to maintain flow and productivity. When the inner loop slows down, developer developer productivity plummets. And there are many challenges that can slow down the inner loop. Now anything that slows down your inner loop can be frustrating. Today we'll focus on three main challenges in the inner loop for your surveillance developer experience set up friction, local testing limitations, and issues that occur only in the cloud. Let's dive into each one of these in more detail. The first challenge is set up friction. Today setting up a local development environment for Lambda can take 30 to 40 minutes. That too, if we're being generous. You need to find and install the right set of tools, manually copy code, configure credentials, and set up dependencies on your local device. Now this creates a significant barrier in getting started with building on your local device. And a major chunk of this effort to effort needs to be repeated every time you create a new application. The second challenge is limitations with local testing. Seamless, excuse me, serverless applications are generally made up of multiple AWS services. But testing service workflows, multi-service workflows rather locally is pretty difficult. You need to get the integration right and also set up IM rolls and permissions. Most developers end up deploying to the cloud for testing, which slows down iterations because of the complexity of using services in the cloud. And then there's the cost of using services in the cloud, even though it's generally not significant. The third challenge is debugging what's running in the cloud. Some issues, as we know, manifest only in the cloud environment. For example, VPC configurations, IM permissions, and service-specific behaviors cannot be fully replicated locally. Traditional debugging approaches can take 20 to 30 minutes for every bug, again, if we're being generous. This significantly improves productivity and the time required for resolution. To address these challenges. We've introduced three new features that complement each other really well and come together to form one unified experience, namely seamless code to console to ID transition, local stack integration, and remote debugging for functions running in the cloud. Together, these features significantly transformed the developer experience for serverless applications. First, console to IDE reduces your setup time from 30 to 40 minutes to just under 30 seconds. Local stack integration enables 75 to 80% faster iterations for local testing. And remote debugging reduces debugging time by about 80 to 85%. Overall, these capabilities accelerate development cycles by 40%. The first challenge we addressed was set of we addressed a set of friction. Traditionally, like I said earlier, setting up takes 30 to 40 minutes with manual, multiple manual steps. You need to install tools, copy your code, set a project structure, install dependencies, and so on and so forth. You get the gist. This creates significant friction, especially for new members on your team or your organization. We solved this with a slick new feature, seamless console to IDE transition. With one click you can transfer code and configuration to your local VS code IDE. This completely eliminates any need for manual setup. You can also easily manage dependencies for your functions using package managers like NPM and PIP and use development tools like linters, formatters, etc. all of this without any setup overhead. Now you can follow the link in the QR code to learn more about this launch, and we have embedded such QR codes throughout the presentation. Let me show you how this works in practice. So I've created a simple hello world function written in Node JS that returns hello from lambda. And now I'll now click in the VS code, um, opening the VS code button, and this takes me to VS code ID on my device, and as you can see, it downloads and sets up the code and all configuration. Now I'll go ahead and change some text in the body. It prompts me, you'll see it prompts me if I want to deploy this to the cloud, to which I say yes. Now, let's go back to the console and see what this did. All right. So look at that. The change is now automatically synced back in your function in the cloud. As you can see, the process is incredibly streamlined. And if you're authenticated, all it takes is one click. So the time savings are obviously dramatic. 95% less time to start using your local ID. Earlier you had to go through a series of steps, after which, which would take on an average 35 minutes. Now, 1 click and you're ready in about 30 seconds. This removes a major productivity barrier. The second challenge we'll address today is testing application workflows that are made up of multiple services. For example, here is an application architecture. In this, we have an SQSQ triggering a lambda function which then writes to a Dynamo DB table, which triggers another lambda function invocation. Now this function sends an event to an event bridge, uh, with EventBridge bus which writes to an SNS topic. Traditional approaches require deploying all of these services to cloud, setting up event sources, configuring IM roles and policies. This obviously results in slower iterations, typically 10 to 15 minutes per cycle. To address this friction, we'll launch a new integration with LocalStack, a a local cloud emulator in the VS code IDE. This integration makes it easy to set up local stack in your IDE. One click is all it takes. And you get access to emulated AWS services and resources to test against. This significantly accelerates your local feedback loop for server development. Let me show you how the local stack integration works. So here I'm building a simple vote counting application. The SQSQ pushes message about voter data to a lambda function, which tallies the data and stores the results in a Dynamo DB table. Now, as you'll see, I'm in my local stack profile and I kick off a SAM build command. The bill will take a second. Once it is complete. I'll go ahead and fire a deploy command again in my local stack profile. All right, looks like the deployment is now complete. So I go ahead and run list commands to validate that the resources are actually created in the, in the local stack environment. So first the lambda function, then the SQSQ, and finally the Dynamo DB table. All right, we can see that everything looks good. Now, let's run this application. What I've done is created a script to send 5 test votes to the SQSQ. And I'm gonna go ahead and um run that script. There you go. As you can see, it has started processing. And it's waiting on the 5 2nd as We desired and Here are the results. They're looking good. So, you saw how simple and streamlined all of that was. No more deploying to cloud, just to test your app and see if it works. The benefits are clear, 75 to 80% faster local testing iterations. Essentially, you can now bring the cloud to your local device. Locally emulated resources let you discover issues early in the development cycle. No more deploying to the cloud after each change. Simply deploy and test on your local device using local stack. And now on to the 3rd challenge which is issues that occur only in the cloud. There are a whole host of bugs that will only surface once you have your app running in the cloud, for example, VPC configuration related issues. This could be in VPC endpoints, security groups, or a number of other areas. Similarly, IM permissions. Related issues like service control policies or role assumption chains and so on. And then there are service specific behaviors like Dynamo DB throttling SQS timeouts, etc. Now these cannot be replicated locally. This means that every time you have to debug such issues, you have to resort to detailed logging, deploying, testing if the change worked, and repeating it all over again. Obviously, that slows things down. Uh, especially when you're trying to rapidly iterate through your application development process. So presenting remote debugging for lambda functions, this is super exciting and truly a unique feature. Now you can debug functions running in your account in the AWS cloud directly from the local VS code ID on your device. You can debug directly against the real function set up and. Excuse me, and the data it handles, not emulated resources without requiring any setup. So debug issues that occur in only in the cloud like VPC and IM related issues and interaction between services. This delivers faster time to resolution for cloud-specific issues. Remote debugging also bridges the inner and outer loops that we talked about earlier. You get the IDE experience with breakpoints, step-through debugging, and vari variable inspection combined with the production fidelity of real AWS services, VPC and IAM. It's truly the best of both worlds, lightning-fast iteration with production fidelity. Let me show you how remote debugging works in action. Here we have a simple authentication application that we built using API gateway and lambda. The logic is straightforward. If the user's name is Harold. It returns a login successful response, else login failed. Now Let me do a curl against this API with Jason at the input. No offense, Jason. No points for guessing this login failed. We knew it would. And Let me do another curl with Harold. Looks like that is failing too. Um, all right. I guess I need to debug to find out what happened. So for that, I will go to the application builder interface in, in your VS code editor. This is something we built, and I start a remote debugging session. Now, as you can see, I picked up the local, it picked up the local route path on its own. I just provide, um, the post-event payload. And run it. I've also set up a breakpoint for it for it to step into the stop at the function code in the function code. All right. Looks like the user info field is not getting the value, so. Yeah I think the field name in the request is uh payload has an underscore, whereas the, whereas the, the in the code does not. So that was uh that was thankfully a uh easy one to find. So I stopped the debug session. And, and fix it. And now since I have Sam's sync running. It automatically deploys this, this change to cloud. And let's see if it works this time. Looks like it is working. There you go. You can see the success 200, uh, response code. All right. Remote debugging reduces debugging time by 80 to 85%. Traditional methods require logging, multiple deploy cycles, and sometimes looking through volumes of logs. With remote debugging, you set breakpoints once and get the exact state information and go to the heart of the issue fast. This, this reduces debugging time from some 20 to 30 minutes to just 3 to 5 minutes per bug. We saw an example of remote debugging in action earlier with a simple example. I would now like to invite Harold to show us how you can use remote debugging with some complex scenarios. Thanks, Srida. So we have seen remote debugging in action. Now, let's see a more complex example here. In this, uh, diagram, architecture diagram, we are showing, um, order, order processing, um, service application, which reads order information from uh SQSQ and a lambda function process it and send it to an external payment API to process that. And this application use a parameter store to store the external configure um payment API configurations like URL or API keys and stuff. Lambda function is put into a private subnet, you know, VPC. And it has a VPC endpoint connecting to the parameters store. And they also use um In a net gateway in the public subnet to reach the external payment APIs. This is a pretty typical setup, um. The problem is this application works in USE one. But it recently deploys to EU Wes one, and the application is not working. So, let's go see the demo. How, how do we troubleshooting this issue? So in here, we have a script that can send test scripts to the SQSQ and then it tells the lambda's logs to see the processing. So first, we're gonna send a few uh one order to the EU US one. So the scripts generated a, a sample order and put it into the SQSQ in US is one. And you can see the um lambda logs. It has started processing it, and we can see the results. It actually successfully processed it and sent to the external API. So this is a successful scenario. I Sorry. I think I pressed. Sorry, I pressed the button too fast. Yeah. Let's see this uh failure scenarios. If you want to send um Order to US EU West one. Just Oh. Sorry, I need to move it a bit more. OK, actually, from here, we should be able to see from the log that the orders sent to you West one just come out. And from the uh lambda logs, we see that the, the message, order the information is read from SQS. Uh, but it was stuck somewhere and the function just came out. There is no more log information so we can troubleshoot and figure out where this function stuck. So What we can do We can actually fire up the remote debugging. This is our function, which um handle, um, handle the messages from SQXQ. Uh it's pretty typical function that reads from the queue and process order one by one. And we can use application builder to initiate the remote debugging session. Uh, application builder, it works with SAN. If your function use SAN templates, it automatically read that template, and it knows, uh, a lot of information about it. So we set up. The remote debugging, loaded the test messages events. And invoke it. We set a breakpoint at that to process a single order code line. When we Hit the remote invoke, now it stops at the break point. We can step into that function. We can see it's logging and go to next, and here is a getting configuration. We can into that function again. So we can see there, there is a quitting a client and try to reconfig, get parameters. But once we step through that, The function seems stuck. There must be a problem there, right? So I think we have identified where the function got stuck. It was trying to read. The configuration from parameter store. So Um, how do we get deeper to find what is the problem, actual problem there. Since we have, uh, this architecture, we see lambda function try to read from parameter store and it didn't get through. Um, the parameter store is having a VPC endpoint, the lambda function will read, will reach that to read the uh data from prem store. It's a premise, uh, VPN endpoint has security groups, also IM roles. So those are two common problems that can cause this kind of problem. So that we can quickly Go to look at the functions configurations. We can see this function is attached to a VPC which has a 10.2 side range. Right? And we can open that VPC configuration. And go to the um VPC endpoint sections. To check the um Parameter stores VPN. First, we want to check the uh security groups. So look at open uh security Group's uh detailed information. We can see this inbound rules is allowing 10.10 IP range. So this doesn't match um lambda functions 10.2 range. So this is the reason actually caused a problem, right? So we, we can, we can quickly identify that our VPC endpoint actually has the wrong security uh group inbound rules, which caused our problem. This works in US is one, but I think during the deployment in the US was 2, the lambda's VPC's cider range changed, but uh VPC, uh, but the parameter stores endpoints security inbound rule was not, uh, changed as well. So that caused a problem. So we can quickly fix this. This is a very simple fix. We just change the set range of the security group. Then we can do the um send another test order to one as well. To verify that this thing actually got fixed. Yes, you can see the test order is generated, lambda is running, pulling the order from the queue and process it and send to the external. Um Payment API It still take some time, but finally succeeded. I think I will end the demo now. You can see, sorry. OK. You can see during this, uh, uh, more complex example, we can use, uh, remote debugging to set breakpoints and quickly identify where the problem is, and quickly resolve the issue. This is much easier than adding logs and go through a deploy and troubleshooting the logs uh multiple times, and it's much quicker. From here, actually, there, if we want to do more, we can troubleshoot more because from the logs, we can see that uh the response time from external payment providers are much higher in US one than the US East one, but Uh, that's something we can still troubleshoot, but, uh, I will not, I'll leave it there. But if you want to, if you, you see the remote debugging in action, Um This is how lambda remote debugging works. It basically contains 3 components. The, in the, um, in your desktop local device, your VS code uh server, uh VS code IDE. We, uh, you, you can install AWS toolkit. Database toolkit contains um Components that set up a local uh tunnel to uh AbaS security tunneling service that running Adobas. This is the middle piece. It's very critical that enables both sides to connect seamlessly. On the lambda side, We provide a lambda layer, which attached to the lambda function when, when you uh set up the remote debugging. And that layer will intercept your invokes, and also, also set up a, um, Local proxy that connects to IoT security tunneling. Once those both sides connect to the tunnel, your local Debugger in this code can use that tunnel to connect to the lambda runtime that, that was set up in the debugging mode. Then you can use all the familiar debugging tools to debug your lambda function. OK, in the summary from the previous, um, demos and features, you can say with all these things, we are able to achieve much faster, um, debugging time, and, and we can solve issues much, much faster and improve server developers' productivity. We got several uh quotes from our users that showing that their enthusiasm about these new features. This one is from Luke, um, who is a principal engineer at Post and now. There's another one from Aur, uh, it's Ominiki, service um software engineer at Omminiki. They also think these, these features are game changer for server developers. Now, you have seen all these features. We want to share with you a few best practice that how to use them better, um, get most out of them. We see a lot of tools. Um, you can use those tools in combination at each stage of your, uh, development, so that you can, uh, get better results. You, if you start from lambda console, you can use console to ID to quickly move your function to local environment. If you are, uh, if you wanted to add more, um, like dependencies, and want to use CCD. Uh, all this stuff. And once you move your code and set up your projects locally, you can use Sensor I to test it. You can use send local to invoke your function. You can use sendlo. API to, to stand up a local API endpoints to test the function. And also you can use the new localStack integration to test multi-service interactions locally, without even deployed to the cloud. And once you get, uh, your project gets into progress, and you deploy into the testing environment in the cloud, and you can use remote debugging to quickly debug issues, identify problems, and quickly fix them. And once your application put into production, you can use CloudWatch, uh, logs, traces to monitor your system and other different issues. Putting everything together, that will help you to um improve your um Developer experience. Another thing is security. So, friends don't have friends to debug in production. Please use your, uh, please use remote debugging in your D or testing environment. You can use this uh uh IM policy. Um, to stop debugging features, uh, in your production account, um, or in, in, uh, use SAP to stop that in organizational, organizational level. Or if you want to be more specific, you can apply this to a specific IM user or IM roles. Um, and in the production environment, you can, you, you can also lock down this, uh, function update actions, only allows SCD rows to do that. There's a lot of things you can do. And When you do remote debugging, Remote debugging allows you to check the status around the code, see the uh variables and the steps through, but it does not allow you to change code. If you want to change code, you would have to do a deployment. There is a tool. Sensor has a command called Sun sync. It will continue to watch your code. And if there is any change, it will uh combine the code and sync that code quickly into the cloud, so that you can start another debugging sessions to try to see if your fix has actually worked. Uh, in the previous demo, we actually already showed that. And in the QR code, you can see more information about, get more information about Sensync. So for remote debugging, when we hit that remote debug button, The toolkit actually modify, attach a layer to your function, make some changes, like extending the timeout to 15 minutes. And It actually published a new temporary version of your function. And then invoke goes to that temporary version. We make these changes so that you, we want to avoid, um, disruptions to your other, uh, traffic. But There are some scenarios that uh some situations we may want, we may, we may don't want to publish a version, because if your function has snapstart configure or provision con uh concurrency configure, to publish a version takes time, like 2 or 11 minute or 22 minutes. So that actually slows you down. So if you are actually debugging in an environment where that you are sure it's just you are debugging it or you are sending traffic to it, you can actually check the uh box or uncheck that box to not publish version. We can just debug the latest. So this will be much faster. And if your function Has uh even triggers like SQS or uh even raw API gateways. And if you want to test the function using those even triggers directly without sending um test payloads. You can also do this. If your SQSQ actually try to trigger your function latest version, then you set it up, uncheck the published version, you can send a message to SQSQ, then the queue will trigger a function, and it will stop at your break point. OK. So that's a few best practice I wanna share with us, with you. And next, I want to invite Shraer to talk about what's what will come in this space. Thank you, Harold. All right. So let's summarize what we saw today. We saw 3 new lambda developer experience features that meaningfully transform serverless testing and debugging experience. These capabilities complement each other really well and help bridge the inner and outer loop experience for service developers. These new capabilities also work seamlessly with existing capabilities and accelerate local surveillance development through unified tooling and integrations. Put together, they can accelerate your surveillance development time by 40% or more. Now, this is new. Super excited to present to you the lambda roadmap on GitHub. Go scan the QR code and check it out to see what's coming next. We are continuously working on improving Lambda's developer experience based on your feedback. And we invite you to take a look at it, share your feedback, take a peek into what we are building, what, what are the things we are exploring. This goes beyond just developer experience. This applies to everything in lambda. So if there's anything that you want to see us build next, you're absolutely welcome to provide your feedback because we want to take your input into consideration. Um, while, while we deci uh, while we determine what to build next, previously there were mechanisms for, for, uh, folks to send this to us through individual channels or through, you know, AWS support and various other channels, but now we've decided that we are going to make it, make our roadmap public. So once again you know you can visit the roadmap where you can learn more and contribute your ideas vote on any existing ideas tell us how you plan to use something that others are asking for. And now that we've made it so easy to build surless applications and you know, debug and test and locally develop your lambda functions, there's no reason to wait, is there? You can get started in 3 easy steps. It's that simple to transform your civilized development experience. Follow the link in the QR code. It will take you to our documentation page with, uh, uh, with a lot of additional details. And with that, thank you for taking the time out of your busy schedule to attend this session. We are excited to see how these new capabilities transform your surance development experience and please, please complete the session survey in the mobile app. Your feedback helps us improve.