---
video_id: z0G0DznBqzI
video_url: https://www.youtube.com/watch?v=z0G0DznBqzI
is_generated: False
is_translatable: True
summary: "This session, \"Developing Serverless Applications Locally with AWS and LocalStack (CNS415),\" introduces LocalStack, a cloud emulator that allows developers to run AWS applications entirely on their local machine. Waldemar from LocalStack and Sridar from AWS explain that traditional cloud development suffers from slow feedback loops (deploying to the cloud for every change), context switching between IDEs and consoles, and the difficulty of testing complex integrations (like Lambda with DynamoDB or SQS) locally. LocalStack solves this by providing a Docker container that emulates over 120 AWS services locally. The session highlights a new partnership between AWS and LocalStack, specifically the direct integration into the AWS Toolkit for VS Code, which enables one-click local setup, seamless switching between local and cloud resources, and powerful features like setting breakpoints and stepping through Lambda code locally. They also mention \"same-day launches\" for new AWS features (like Step Functions updates) within LocalStack, ensuring parity with the cloud."
keywords: LocalStack, Serverless Development, AWS Lambda, Local Testing, Developer Experience, Cloud Emulator, VS Code Extension, AWS Toolkit, Debugging, API Gateway
---

So it's great to be here, thanks all for coming to our presentation here to talk a little bit about Lo stack and uh you know developing service applications on your local machine. Um, so maybe just a quick show of hands before we dive into the agenda. Can we just get a quick show of hands? Who has heard about LocalStack before? Um, maybe even use it? OK, so there's about half of the people here in the room, so that's great. Um, so we're gonna keep it relatively high level and also want to talk a bit about the AWS partnerships that we, that we've been doing recently, which is really exciting to share with you all. Um, so this is the agenda we're gonna go through. I'm not gonna spend too much time here. Let's, let's dive right in. So generally speaking, what is Lo stack? We are um a um imagine you have like local AWS sandboxes, right, giving you the ability to develop and test your applications on the local machine without being connected to the cloud environment or before connecting to the cloud. So what you see here is kind of a traditional workflow. You start with some local environment, right, do some local testing, maybe ID integration, then you run some tests in the CIC environment and then finally you push changes up to the real cloud once you're happy with the application you're developing. So some of the benefits here you see is that you get these these instant feedback loops by running things locally, not having to push every change into the cloud. You have fully isolated test sandboxes that run in your CICD process, so no overriding of changes of each other, and again, you ship to production with confidence once you're happy with the changes you've made locally. So there's more than 100 AWS services that we have in our stack today, so I think it's 120 at this point. Everything from Lambda, SQS, DynamoDB, um, IM, you name it, and we also integrate with most of the existing infrastructures, code tools, you know, Terraform, CDK, you name it. So we really try to meet the developers where they are, uh, make sure that you can just run your applications locally. So how does it generally work, right? So it's basically a docker image that you spin up as a container, right? So you just basically install a CLI, you say localsli start, it spins up, you can see the banner here in the terminal, and then the second thing is you just interact with it, which basically just means setting the AWS endpoint URL to localhost, and then you're off to the races. You can just use the AWS CLI and all your native tooling there. So one of the questions we often get is, OK, how do we actually keep up with, you know, the, the amazing pace of AWS and all the great innovation that's coming out there. We heard many announcements at reinvent already this year. So almost everybody visiting our booth has this question. So basically it boils down to, you know, a couple of like combination of factors. So first of all, we've built a lot of internal tooling. One of them is. Is called ASF, uh, the AWS Server framework, so we do a lot of, um, automated scraping of the API specifications. We always detect when there's a new change coming out with AWS services. The second part is we have an enormously talented engineering community in-house and also, you know, the open source community. So there's a lot of people just rambling behind building these emulators, which is a phenomenal effort really. And then thirdly, what we're gonna talk about today also is there's more and more partnerships going on specifically with AWS so we can do same day launches uh and make sure that you actually get all these, these great new features in the local developer experience uh once they're released by AWS. Um, so with that, I'm gonna hand over to Sridar and he's gonna share a little bit from AWS perspective, the surveillance the challenges. Thank you, Valdemar. As we've discussed local SA capabilities and how it keeps pace with AWS services, I want to shift our focus to, there's some loud music playing back there, so if you hear any feedback, just know it's not me. Uh, uh, we should shift our focus tourist developer challenges, uh, developer service developers face when they're building surveillance applications. Now these challenges represent the pain points we are, we are collaboratively addressing, right? The AWS, um, surveillance team has been at work and, uh, I'm particularly focused on improving the developer experience, which is why this partnership is so valuable. Let's start with the with the challenges. Let's break it down into, we break it down into 4 key areas that affect the developers on a daily basis. The challenges significantly impact productivity, code quality, developer satisfaction, and just the way the quality of your overall application when it comes to even things like operational efficiency and so on, right? So we'll explore each of them in detail in the upcoming slides. The first is testing in the cloud, you know, cloud-based validation slows things down. It slows down your duration cycles. AWS research shows that developers spend a considerable amount of time on their local devices, uh, where they're, you know, testing and writing code rather than in, you know. So what what that means is it is critical to get them to get them going fast as soon as possible to the stage where they're able to see what they're they're building, what it looks like. Now each code, uh, each code change requires a full cycle if you're deploying to production, so you have to go through validation, testing, deployment, and the feedback loops could stretch anywhere from hours. This dramatically reduces the developer productivity and innovation velocity, which is obviously not a good thing. So what should be a quick test usually becomes a cycle, a lengthy process, and this forces developers to batch changes or, you know, make educated guesses rather than actually relying on real validations. The second challenge is context switching between tools. It comes with a significant cognitive overhead of constantly switching between different tools. Developers routinely shift between IDEs, CLIs, and resource emulators. What this does is it creates fragmented workflows, and each context switch disrupts what you're trying to build. It disrupts your flow. It reduces. Activity managing multiple tools increases the likelihood of errors and creates significant mental overload as well. Now this is particularly noticeable in surveillance development while you are where you're working with multiple services, for example, the likes of Lambda, SQS, EventBridge, API Gateway, you name it. There's there's always a myriad of services that you're working together with, and there this, this challenge is the most pronounced. The next is configuration complexity, port mapping and code edits for local service integration tests. They introduce inconsistencies between local and cloud environments. Developers must maintain separate copies of configuration for local versus cloud cloud computing or cloud testing, and this leads to the classic, you know, works on my machine problem that you've all run into at some point. These manual configurations are not only error prone, they, they, they can be time consuming, and it requires a constant maintenance cycle as applications evolve and get bigger and bigger. And the last one is. And this one I want to stress is is super important for several developers is integrations. I touched upon multiple services earlier. Integration testing is difficult, period. Now troubleshooting lambda functions in the context of AWS service integrations with Dynamo DB S3 SQS, this requires complex setup. And event driven architectures can be particularly challenging to test locally, and what ends up happening is developers resort to test in production approaches, and we all know that we shouldn't rely on that. So the hidden complexity of service integrations is much larger than the function code itself, and this, this, this creates a significant testing gap. So now that we understand the challenges, look, let's look at the solutions Local stack and AWS developed together. The collaboration between AWS and Local stack addresses all these challenges through a seamless integration that brings the best of both worlds. I'll in the in the next slide I'll talk about how this simplifies the experience of working on a local IDE and scan the QR code if you want to read more about offline. So the AWS toolkit for VS code now integrates directly with Local stack. We, we launched this integration back in September. This creates a unified development experience. The integration enables local testing of lambda functions with full AWS service integrations. It provides consistent behavior between cloud and local environments, and it eliminates the manual configuration of service, various service integrations and service connections. This results in accelerated development cycles. It reduces context switching and it simplifies the integration integration testing cycle, and it also helps you ascertain the code quality, meaning that the code is of high quality before you actually send it to production, integration testing, or even staging environments. And let's get more specific first on what are the benefits. I know that I, I talked about addressing these challenges, so let's, let's talk about them. So you get one click local stacks local stacks set up directly in your visual Visual Studio code IDE. That means no more complex Docker commands or configuration file. It's all handled for you. The second thing is that you can access all your emulated resources directly from your VS code IDE. This means that you can get, you get to stay in your development environment without having to switch context between multiple tools and interfaces. You can also easily switch between local and cloud resources with a simple click, making it seamless to test locally and then deploy to the cloud rather than deploy to the cloud and then test. So we're kind of reversing the paradigm here and most importantly, you get a dramatically faster local feedback loop. Changes that would take minutes to test in the cloud can be validated in seconds locally, and this significantly accelerates your development velocity. With that said, let's take a quick look at the the live demo that Valdemar is going to talk about. Awesome, thanks so much, reader. I just wanted to emphasize we couldn't be more excited to stand up here in the booth or at the stand as local stack together with the AWS Lambda team PM. So it's a really exciting integration for us all here to talk about this, and we would have loved to show you like an actual live demo. This is a recorded video that I'm gonna play here and I'm gonna speak to it. It's, uh, it's about a 3 minute video and uh we'll see what's what's going on there. So basically what we're showing here is uh the VS code integration um that Peter was talking about and we're gonna deploy a simple sample application fully run it on local stack via the AWS toolkit, and then at the end also show how you can do breakpoint debugging directly from the ID. So I'm just gonna kick off this video here and speak to it a little bit. Um, I know it's, it's pretty fast, but uh let's let's just, you know, dive in and see what it does. So what we say here we're we're creating a new, a new project here that's called Local stack Hello World. This is actually a SAM, a service application template, um, so it's basically, you know, renders a cloud formation template that you can directly deploy via via SAM. Um, and the nice thing is you could just take the whole thing and deploy it against AWSS, you know, uh, totally works out, but what we're going to do here is we're actually doing a SAM deploy and specify the profile local local stack. The profile local stack is just a local AWSS profile like any other. The only thing is that we actually define the endpoints to be a local host, right? That's literally the only difference that you see there. So we're doing the SAM deploy, specify a couple of parameters like region, um, stack name, uh, and just the basic information. This is all standard AWS deployment, right? But again, the deployment is actually happening against local stack. So we see the, the stack resources here, um, it's pretty snappy, which is, you know, in a couple of seconds everything is deployed, and we see now we have, uh, you know, an an API gateway with a lambda function deployed that's running fully locally. This is our web app app.local stack.cloud if you want to give it a try. It's a bit like the AWS console where you can browse your resources locally, and this is the lambda function which was created here. And now we're actually doing an invocation, so at the bottom of the screen you can see a curl command, we're just doing a curl, um, we're just removing, replacing AWS Amazon AWS.com with localhost.locostack.cloud. Otherwise it's exactly the same kind of endpoints, and we see the invocation was done. So this is a full round trip of an API gateway lambda invocation that connects to Dynamo D Beam. Now we're making some changes in the lambda, um, you know, which is, you know, change the messages coming back here, uh, to another SAM deploy. Um, so this is basically just redeploying the changes which is made in the ID, uh, and again it's just gonna take a couple of seconds. It's doing the cloud formation updates, uh, and we should be done in a second. And then we're gonna run the curl command one more time, and it will show you the updated output. So now this is fairly, what we've seen so far is pretty much table stakes, this is just local stack basics in a sense, but now the exciting part is gonna come. Uh, for all those of you familiar with LocalStack, so what we're going to show here now is the remote debugging capability in the AWS toolkit. So what the toolkit provides is effectively a remote debugging where you can set a breakpoint directly in the lambda code, and on the right hand side you see the remote debugging configuration. You can use that against AWSS as well, and also natively the same experience against LocalStack, so it's just literally the same experience that you get there. So we have the local endpoints, um, we do the remote in vogue, and it actually, you know, hits the break point right there. We can make changes, we can step over the code, just the regular debugging experience that you're used to in your, in your day to day work. Um, So that is, and then we see the the updated output in the end, um, so that was a, a quick walkthrough. I know that the video was, was pretty fast, but hopefully we were able to give you a bit of a glimpse into um the experience that you have to, you know, with the AWS toolkit together with Locustack, and it's worth mentioning as Rida said, no more need to configure any, you know, docker compose files or complex setup. It's all fully integrated, it's just a, a turnkey solution in that sense. Um, so with that, um, I just wanna sort of close out with, um, just mentioning again the partnerships and the collaborations that we're doing together with, with AWS which again is super exciting for us as we're kind of growing the open source community and also our, our, our business, um, so we have been, um, launching, uh, in the past already a couple of, I, I think it was probably half a year ago. Um, also step functions testing integration with local stack. Um, so, um, there's actually a couple of features that were coming out in step functions recently, um, test state API, Jason auto support, and variables. So for those of you, um, using step functions once in a while or on a regular basis, those. Some really killer features that AWS put out, uh, you know, some time ago, and we basically were able to do, um, same day launches together with AWS, right? So we're partnering up very closely, um, with the folks over there to, to make sure that all the good stuff that's coming out is available to you like in an instant, right? Um, tested API I think it's actually something very recent, um, at reinvent if I'm not mistaken, a couple weeks ago, a couple weeks ago, yeah, um, so that's just another example even besides the, the toolkit of, of the partnership that's now taking shape more and more. Um, and there's more to come. Um, there was actually literally at Reinvent a launch around, uh, lambda managed instances. Uh, if you haven't seen the announcement, then maybe you can check it out. We also put out a blog post there, and again it was like a same day launch that we were able to do as we're very closely partnering up with AWS. The second part that we're of course focusing on, uh, on an ongoing basis is just improved parity, so we want to make sure that, you know, any stack you deploy really has the high fidelity that you would expect from, from a local emulator. And we're working very hard together with our team, with the community to make sure that this is a high fidelity, a digital twin of your cloud environment, if you will. And then the third one is around, of course, developer experience is becoming a big, big topic. Also AI, it plays into our day to day lives of how we're building cloud applications. So we're building sort of on top of the emulator developer experience features to give you more debugging capabilities, more insights into your stack, debug your IM policies, for example, and much more. And AI is also coming as a as a new means of developing applications, and we have a secure local sandbox that you can, you know, use for your agent decoding there. So with that, um, uh, I wanna, wanna, you know, close out the session. We have a couple of minutes left, but, um, definitely wanna give a shout out. Please visit us at, at our booth, uh, 1626. It's right over there, um, just literally behind the, the, the radiiest booth. You'll find the Loco stack booth. Um, we're gonna show you some live demos, show you the AWS toolkit integration. Um, the team's gonna be there to answer any questions you might have. Um, again, we'd love to, you know, get your feedback and, and, and see what's, what's coming out next at Locostack. Um, also, please do, um, give us feedback. That would be great. So in the app you have a way to provide feedback for the session if there is anything we can improve or learn from it, uh, we always appreciate any feedback you can share with us. So with that, I'm gonna close and again thank you so much for your attention and being here and um very much looking forward to everything that's coming next in local cloud development. Thank you all.