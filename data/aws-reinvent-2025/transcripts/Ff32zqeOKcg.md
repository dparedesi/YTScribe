---
video_id: Ff32zqeOKcg
video_url: https://www.youtube.com/watch?v=Ff32zqeOKcg
is_generated: False
is_translatable: True
---

Good afternoon everyone. So how is it going? How is reinvent? All good. So, uh, welcome to this code talk. So this is code talk, so I assume that you love C code more than like seeing PowerPoint, so this is the goal of this session. And also I assume that most of you have a .NET developer background and you are dealing with some legacy.NET framework applications that you need to modernize. So welcome everyone. I'm Alex. I'm Prasad, and I'm based in Stockholm, Sweden. I'm based in London, UK, and here in this session, we will show you how you can modernize your legacy.NET framework applications using agentic AI tools, uh, like, uh, Adlas Transform and Kiiro, and we'll do a lot of life coding because of this code talk. So, before we get started, you know, just raise of hands, like how many still managing some kind of like .NET framework applications like legacy stuff? OK. Almost everyone seems like in the room. Perfect. So we're in the right, you're in the right session. Good. OK, let's get started. Yeah, so when we talk about legacy.NET applications, there are 3 components to it, uh, which are legacy, which, uh, we need to modernize. The first is, uh, the framework, you know, the language that is written is in .NET framework. Uh, uh, so .NET Framework, as you know, can run only on Windows. It's proprietary. So we'd like to modernize it to the latest version of .NET, .NET 8 or .NET 10, like both are the long-term support versions that we have. So that's the first part of modernization that we'll be doing, the code modernization. The second is the architecture modernization. Which means that your application might be a monolith, right? And when you're modernizing, you would like to use the uh best practices, architectural uh patterns. So you'll be using microservices, event driven architectures. So that's the architecture modernization. And finally, it is infrastructure modernization. So as you know, your uh .NET framework applications can run on Windows, so you would like to run them on Linux. And most probably if it's the ASP.NET application, it will be running on IIS. So instead of that, you would like to run it on server lesser containers or EC2 Linux. So we are going to look into that. So in this particular session, we'll why modernize all these three aspects of the legacy application. And to do that, what we have done is that we've taken an open source application called Kantoso University. It's an ASP.NET application. Um, it has standard features. It's a university, uh, management application which has features like, uh, student enrollment, uh, course management, instructor assignment, right? And as you can see, it is built quite heavily using Windows components. For example, for your queues, it is using MSMQ for your database, it is using a SQL Server. And if you look at the presentation layer, it is using razor views uh with MVC controller, and then it has your service layer, not a typical service layer, but it has a notification service, uh, which sends out notifications via your, uh, MSMQ. And then in the data layer, it has Entity Framework, which it, uh, uses to connect to, uh, your SQL Server, communicate to SQL Server. So that's the architecture, uh, which you're going to modernize, but let's look at the code, and how the current code base looks like. Alex, OK, let me move to my keyboard. So as you saw like, this is quite typical .NET framework application which contains like quite typical components which probably you see in your applications, I know from the last 20 years, but let me switch to the code. So I have this application in my GitHub repository. So as you can see, it's .NET framework 4.8 application. Uh, yeah, it's like this huge uh project file, so all the configuration is in web config, and then what we have, so we have a bunch of controllers, we have a database with like some initializer with database context. We have some views, as I said, this is a university management application, so we have used to manage courses, departments, instructors, students. So this is not like a small hello world application, but it's not like enterprise application. But again, this is a very good application for demo purposes which we picked. So, what are we going to do with this application? Yup. So let's switch to the presentation again and let's see what we are going to do, right? So, we have seen the code base, uh, of the legacy application, architecture of the legacy application. Let's talk about the tooling that we'll be using to modernize this, right? So first we'll be using AWS Transform for .NET, uh, through which we will be putting your .NET framework application to, uh, uh, latest version of .NET. In this session, we'll be doing it .NET 8. And then we will be using Quiro. So what we'll do is that we'll take the ported code from uh from ADbasetransform for .NET, and then we will use Quiro to fix any compile time errors, build it locally, and then we'll modernize the code base. We'll look into each of the steps at what we are going to do when I say modernize. So, the step number 1 is automatically put, that'll be using AWS Transform, your codebase, to the latest version of .NET. Step #2 would be fixing any compile-time errors and building them locally. And that's when we'll start refactoring. We'll replace your SQL Server with Postgrac SQL. Then we are going to replace MSMQ with Amazon SQS. So what we are trying to do is that we are going to remove all the Windows components, legacy components, and make it a more cloud native application. Then we're going to extract a microsurface from this monolith. Then we are going to refactor the UI. So currently, as you have seen, the, uh, the UI is based on your MVC uh controller, um, uh, razor views. We are going to move it to React app. And then finally, we are going to deploy it on AWS by creating a CDK project. So, like, in the next 45 minutes or so, we're going to go through all of these steps and why modernize it. With that, let's start with the step one, updating your .NET framework application to .NET 8. OK, let's switch to the code. So, as Prasad said, the first service we're going to use is Adverse Transform, and yesterday we completely changed the UI of Es Transform like added the new features. So this is the new UI of Advers Transform. So I already have a workspace created. And if I go to this workspace, I already have a connector configured to my GitHub repository. So adverse Transform can access the code like in my GitHub repository. So this is the sample Kantoso University project. So this is the connector, it's is active, and then, yeah, it's connector for GitHub, Github. So what I'm going to do, I'm going to create a new job. I'm just saying create job. How many of you here have, you know, like used ADBS transformer? OK, a few of them. Have you heard about this service? It went GA earlier this year. OK, a few of them. OK, cool. OK, so now it asks me what kind of transformation job do I want to do because, uh, adverse transform can do like multiple things. So it can transform your mainframe applications, uh, VMware-based applications, but in this case, we're going to do .NET modernization. So, uh, now it's called Windows modernization, because yesterday we launched a new feature, so it's can not only modernize your .NET framework applications, it can also modernize your SQL Server database. So I'm saying, OK, I want to do Windows modernization, and in this case, I'm going to do .NET modernization. OK, so this is the job is going to create for me. So as you can see, it's a more agentic AI experience, you would be having, uh, you know, a, a modern UI to go through. Yeah, and this is like not full uh fully automated experience, so it involves me as a developer in the loop. So as you see it's saying, OK, I'm awaiting user input, and what it wants me to do is to say, OK, like where do I get the source code to be transformed from. And we have like two types of connectors supported. One is through code connections, so, OK, if your source code is in GitHub, Github, Asia develops, then you can do it through code connections. Or if your source code is in your S3 S3 bucket, so maybe you're not storing it in, uh, GitHub or whatever. So, OK, you can connect to your S3 bucket. In my case, it's in GitHub, so, OK, I'm just saying. My coat is in the. You use code connections to connect to my repository. And now it will start discovery, so it will connect to my source code repository and try to see what kind of .NET framework projects or older versions of like .NET Core projects do I have in my repository. And again, it's in awaiting user input. So it discovered that in my GitHub repo, I have like two projects with Gadgets Online and with Kantoso University. So, uh, the beauty of ABS Transform is that it can do, it can transform like multiple projects at the same time. So I don't need to go like project by project. I can select like multiple projects and transform them like in parallel. But in this case, I want to do like a transformation of only one project, so I'm selecting, OK, this is Kantoso University. And then I'm saying, OK, start assessment. So on the assessment phase, it will look at my project to understand, OK, what kind of .NET, what versions of .NET it's using, what kind of Nuat packages it's using. Other like any dependencies to third party Nugat packages or dependencies to other repositories, so it can automatically discover what OK, I have like two projects in my GitHub repository, and actually this project is using Nugat package which is produced by another project, so it will automatically map like these dependencies. And then, uh, yeah, so I will select the project, I will say like, OK, submit the job and then I will run the job. So for this project, the job took like maybe half an hour to run. So I will go back to my workspace and show the results of the previous run because we don't have time to do, do like a live run of this job. So I have it here. Again, I mean, I choose the connector type, discover the repository. And did the transformation, and here are the transformation results. So, uh, because it does, uh, it can do transformation of multiple projects at the same time, the outcome of transformation is a new branch in each and every project. So in my case, uh, it created the, this branch which I named one transform because it's the first step of our seven-step process. So it created this new branch, it transformed like 3000 lines of code, one repository, one project. And then I can go deeper and see like uh all the transformation details. But OK, this is our starting point. We did the transformation using Ebus transform, and the transformed code is in this transformed branch. OK, what's, what's next? So what Alex showed here is AWS transform for .NET and for those who have, uh, who are not aware of this service, uh, uh agentic AI experience for modernizing your .NET applications, and there are other features also like your VMware applications, mainframe applications, but specifically for, uh, .NET. If we talk about what Alex has shown is a large scale porting, and what we mean by large scale porting is that you can select more than one applications to be modernized in one go. But we also have an IDE extension, a Visual Studio extension for, uh, Arabia's Transform for .NET. It's for developers who want to be in their, you know, developer friendly experience environment. They can, they can use the Visual Studio extension and have the same, uh, experience. So irrespective of which pathway you go, whether you go via web console that Alex has shown all by ID experience, it does three things. First, it analyzes your code base, which is the assessment part. Then it does the transformation. Uh, replacing, uh, your code base in a way that it is compatible with the latest version, and then finally it validates, right? So the outcome, the goal here is to, uh, come up with a code base that is, uh, you know, Linux ready application be compatible. Right? So, now that's what we have done now. Now, we will take this ported code and we'll, uh, use Kiiro to fix any compile-time errors and build it locally. Right, so let's, uh, have a look at the step two now. Yes, let's switch to the code. So I'm switching now to Kiro. So, uh, this is the branch which uh was created by adverse Transform. So if I go to this branch, so this is my one transform branch, and you see that it was committed by Edvas transform, 50, 55 files were changed. There's a lot of code changed, and if I go to the source code, you see that now it's a .NET 8 project. So how do I see it if I go to the project. Yeah, you see, like the project file is like much smaller because it's .NET 8, yeah, the target framework is .NET 8. My configuration is now, uh, uh, moved to application settings. All the static files were moved to WW roots. OK, this is, I, I have like program CS. I have like startup CS, so. It was transformed, did like all the undifferentiated heavy lifting of like porting my dot and frame application to .net 8 But, uh, there are like still few things left. So for example, if I go to this project and say, .NET build Actually, there are a few build errors, so, uh, in many cases it was transformed, uh, the output will be good like compilable project. In some cases, for example, in this one, there are still some things are missing. So here it's, uh, mismatched some, uh, versions of Nugat packages. And again, as a developer, probably I would be able to fix it like in a few minutes, like in a half an hour, but let's see if we can fix it automatically using Quiro. So I would just Clear that and then this is the chat with Akira, so I'm saying OK. I got Build errors. Please fix it, and I, I'm, I'm trying to be polite with Kiro, so it works. Yeah, so first thing it's going to do, it's going to build the project itself, so it can hook to the console output and see what the build errors actually are. OK, so. It got the output and says, oh, I see the issue. There is a package Russian conflict. So it reads the my project file, updated some uh versions, so I can see all the changes that were done and says, OK, I want to build it again. OK, so it build it. OK, there are 2 more errors, it looks like. Some still it's using like MVC namespace which doesn't exist in the .NET 8. OK, so. It did a few more changes, tries to build it again. So again, these are the steps which I will do myself as a developer. So this will be like my, you know, debugging experience, but I'm like offloading this debugging experience to Kiiro, and I'm just following, OK, does it make sense from my developer perspective. And then it found like there is also an issue in this error error uh razor view, but OK, it's using the system webMVC which is not available in uh .NET ISP.NET core. OK, so it's fixed it. OK, one more error. It says that OK, there is a. Post-built copy task which it fixed. It keeps patting itself backne. Great progress. Yeah, and OK, .NET built. OK, no more errors, but it looks like there was a warning. And again, Kira says, OK, like there is a warning, OK, let me fix this warning as well, so it's trying to make it as good as possible. And. We run it. OK, it's fixed. Build succeeded, 0 warnings, 0 errors. So how long it took for me and Kiro to fix this build issues, you know, one minute, a couple of minutes, probably. So, OK, so now our project is comparable locally and it's .NET 8 project already. I'm running it Mac. It's not .NET framework, it's .NET 8 project. OK, what's next? Cool. Now, it is like building locally, so let's see what next we can do. But how did we do that? We did using Quiro and AI IDE, uh, that went into, uh, GA, uh, last, uh, a couple of weeks back actually, uh, it was on preview for some time. Uh, and what's beautiful about this AI ID is that you provide the intent that what you want to achieve in actual language, not the actual code. You don't write the actual code, Quiro writes the actual code on your behalf, right? And there are two ways to provide your intent. First is what Alex has shown, right, uh, which is mainly known as VP coding, like prompt engineering. You provide the prompt and Quiro does the changes, uh, on your behalf. And it's pretty good for tasks like, uh, as we have shown, uh, fixing errors, troubleshooting, or, you know, in case if you want to build rapid prototypes, like I use it all the time for creating, uh, POCs for customers. But in case if you are, uh, doing more, uh, like, you know, complex, uh, uh, tasks uh and building, uh, you know, uh, you know, production grid applications, then probably you might want to use spec-driven development, you know, VP coding might not be the best way to, uh, you know, go forward, and this key role supports spec-driven development, and we'll dive deep into it in a moment when we'll be doing the more complex aspects of the modernization that we are showing. But for now, let's look into where we are in our journey. So we completed the first two steps. The 3rd step is now replacing SQL Server with Postgrace. Uh, and Alex, I believe you are going to continue vibe coding for that. Yes, yeah. And here, if you see in the, if you look at the Aklia diagram, what is happening, the 1st and 2nd is done, and we're going to focus here on the SQL Server. We'll replace this with Postgrace SQL. Go for it, Alex. Yeah, let's switch to the code. So again, I'm like running it on Mac, and with pro uh it's uh there is dependent on the SQL Server local DB so I still cannot run it. But I have a local instance of uh Pogrid SQL running on my machine, so I want to switch from SQL Server to Porid SQL. So first, uh, let me switch to my, uh, Pore SQL, so you see, uh, let me create a new database, so it's brand new empty database. Create database. Cantoso 99. I know, I don't know why 99, but OK. So I just created this new database and then let me switch to Kiiro. And then, uh. I'm just writing, OK, like again in wipe coding mode. I'm saying, OK. I want to. Switch to. Paul's Greer sequel. I have local. For instance, Running Database. Name. Cantos of 99. A user Name this is my name and. It's my local database, so I have an empty password. OK, so this is my intention, what I want to do with this application. And Kira says, OK, I will help you to switch from SQL Server to Posgrid SSQL. Let me check your current setup, make necessary changes. So it's checking the, uh, My project file, it's checking my application settings, uh, database contact start-up file, and it's now, uh, starting making the changes. And I'm doing everything live. Nothing is recorded. Let's see. How it does and what model are we using, Alexia? So currently we're using Cloud Sonet 4.5, so this is the latest version of Cloud Sonnet. Yeah. OK, so it's ask me to do do do not restore. Can you point in the in the screen where you know the model can be changed just for everyone in your case they have not used Kiro so we are, yeah, we can switch between different models. How many of you here have used Quiro or, or, you know, like have hands-on experience with Kiro? Very few. OK. And has, has anyone used Kiro to modernize old applications or only for prototyping? Yeah, I'll highly recommend to, like, you know, it's a free, uh, it's not a free, but you know, once you, uh, install, it'll give you a good amount of credits, uh, and then every month you get some credits free. So try it out. Uh, it's a folk of Visual Studio, so you will be still be in a very developer friendly experience that you might be having. Sorry, VS code, it's a folk of VS code, so you'll be still be in a very friendly development environment. So you install it and you plug it into the studio. Uh, no, it's a, it's a separate ID. You can simply install the ID and that's pretty much. So you don't need to install VS code for it. You can simply go to Quiro and install Kiiro. OK, so it did the first uh batch of changes, so it says, OK, it's updated application settings, uh, it's updated the project file, uh, updated the. Database context. OK, so let's, let's try to run it. While you're running, you had a question. studio plug-in. Uh, so for Visual Studio, we have plug-in for AWS Transform. Uh, for Hero, I'm not sure yet. OK, so I tried to run it and there is an error, so there is a. OK, so it says that unhandled exception entity framework, uh, they. Daytime 2 is not supported. So, OK, probably I'm using this daytime 2 in my SQL server code, but daytime 2 is not available in Pos SQL. So again, as a developer, I can fix it myself, but what I'm going to do, I'm just going to. copy with Stick trays. And say, ask Kiro. I have Run time. Exception, and I'm just pasting the. That's a new way of development, right? So as a developer we keep guiding, let's say Quiro is a junior developer and they keep doing it for us. So it's a kind of a, uh, programming pairing or, you know, uh, whichever way you would like to associate a friendly developer is always there for you. Yeah, so it's trying to find like the references of daytime too in different projects, uh, updating the notification. Accepted the edits to it, and then now it's saying, OK, let me check the other models. So again, this is something which I as a developer would do. OK, like if I fix an error, I will try to see, OK, if there are similar errors exist like in other code files. OK, so I was able to build it. Uh, let me run it again. It looks like there is daytime to exist somewhere else. Yeah, now it's in person table, but again, let me just Copy this stack trace. And saying God. Run time. Error And I'm like pasting it in the same session so Kiro knows like the context. OK, this is my conversation about positive SQL migration. And he says, OK, I found like this issues in person model and students model instructor model, so it's trying to fix it in all other classes. Well it is fixing. Yes, you have a question, please. What makes different than using like cursor. with the same model. So, it's like it has much deeper integration with your AWS services, and we'll see, show you how you can deploy it all using CDK project in AWS. OK, so let me build it. And let me run it again. Dot net. OK, so now, at least I don't have like runtime errors and it's running on a local host 5000, so let's see. So this is my application. So again, it's up, so it's like .NET 8 application already it's running on my Mac, and if I go to students page. OK, something is not working. So it looks like I get another runtime error, so let's see. So the page is loading, but it's not able to load the data, right? Yeah, so the connection string was not. Initialized, OK, again, let me just Copy it. Yes, while Alex is fixing it, please go ahead and ask the question. Does it support other models than? Yeah, we'll show you in a moment what our models it supports. So currently, as you can see you can see the difference like try it out, experiment. So you see there is like with Cloud Sone 4.5 4 haiku opus. And then, yes, it's oven coder. OK, but now, again, uh, now it's trying to fix another runtime error, but the connection string was not connected correctly initialized. So let's see. So it's trying to find, OK, like whatever control, I mean. Yeah, please go ahead. Regarding the, the sort of the AI part of it, if you have like GitHub copilot or some other thing, would it integrate with that, or is this like a separate service? So it's an ID in itself, right? So, uh, and it has the inbuilt, what do you call the, uh, AI capabilities. Um, I don't think that it is going to integrate with GitHub or co-pilot now. I will try it out. I'm not try it out. OK, so yeah, we're still like in this, maybe it's not VIP coding mode, it's like VIP debugging mode, we're trying to fix this issue with Pore SQL. So, but, OK, let's see. And let's. Run it again And I think it's still on the port 5000. OK, so now the page is loaded, so it looks like uh I don't have like any runtime errors, but there is no data on this page, and I know that this project it has the. Uh, database initializer which sits the sample data. So again, I can ask Kiro. Or not ask, I'm just making the statement with sample data. He's not. Seal it. So as a developer, you still need to know what needs to be done, and then you keep instructing Kiiro, but OK, can you please do this on our behalf, and they'll keep doing it, hopefully. Again, this is like my pair programmer. I'm like talking to Kiro and trying to solve like the issues together. Yes, please. It's, it's a lot more efficient, I would say. the same Yeah, similar capabilities, and as I mentioned, it has a much deeper integration with the AWS services when it comes to deployment. We'll look into how we'll create a CDK project and we'll deploy it on AWS. Yeah, so like what we see that it's. Database initializer was not called, so now we are called initializer. OK, let's build. OK, yes, please continue. We escort our visual studio. This is VS code uh for uh the keto ID. automatically comes with pilot, right? Yes, so now we have to install. Councils. You can continue using that, but in case if you would like to, so Quiro is a great alternative. So. Maybe let's like leave it for the discussion like maybe after the session because we're really short of time like to show what we want to show, uh, so we're like still progressing with like this upgrade from SQL Server to post SQL and there is this, maybe, I hope this is the last error that it's uh. Yeah, it's a, it's, so there is an error when it's trying to see the data. So, yeah, let's see what it's all about. And yeah. Go A Run time E See in the data. Yeah, so again, this is like still issue of daytime, but you need to specify if it's like UTC or local, so this is the postre SQL specific feature. So let me, yeah, you did some changes. Let's build it And Let's run it. I'm talking that wrong. OK, update the page. And OK, so here we have the data. So we just upgraded. So now this application is running locally on my Mac OS. It's a .NET 8 application, and instead of SQL Server, it's using Postres SQL, and it took us, I don't know how many, maybe 20 minutes in total of like VIP coding with Kiiro. Yeah, and until now, yeah, exactly. So cool. What's next? So let's see where we are in our journey. So we did modernize from SQL Server to Postgrac SQL. The next step is MSMQ to Amazon SQS. And if you look at the architecture diagram, uh, if you look at like where the 3 is written, so we replaced, uh, SQL Server with Postgrac SQL there. And now we're going to focus on the MSMQ and make it Amazon SQS. And this, I think we're going to do it with spec-driven development. And this is where the actual differentiation would come into the picture, uh, the spec-driven development. OK, let's switch to code. Yeah, let's switch to code. So I will start the new session and instead of like VIP coding, I'm now going into spec coding mode. And I already have my prompt. I don't want to type it. But OK, so I'm saying current application is using MSMQ for notifications. I want to switch to SQS implementation. I want just base functionality like no extensive error handling, no unit test, no like local testing, so I want to keep it like at MVP level. And I already have SQSQ created and this is the URL of the queue. And now I'm like in the spec uh development mode. So what does it do in spec development mode? Yeah, so first it's going to create the requirements document. So the, uh, and it will create requirements document based on my project. OK. Uh, what does it mean upgrading. MSMQ to SQS. And we will see this document in a second. OK, so it's created the requirements and now it will ask me to review it. So you see there is a new folder created .kiro and under .kiro there is a specs folder, and it created this SQS notification migration folder. So again, like the name makes perfect sense based on my intent that I want to migrate to SQS. And it's created with Requirement document. So this specification defines the migration of this notification system from in memory. To in memory queue implementation to SQS. Some glossary, but here are the requirements. OK, as an administrator, I want notifications to be sent to SQ SQS instead of in memory queue. So notifications are persistent across application restarts. Second requirement, as a developer, I want to use ABSSDK for .NET so that application can communicate with SQS. OK, also makes sense. As a developer, I want Queue URL to be configurable, so like different environment and so I can have different cues for my production environment, for my testing environment, and so on. And then also as a developer, this is quite important. So as a developer, I want existing notifications API to remain untouched. So like, I want to change the underlying implementation but not the interfaces. So like all the services which use notification, service I mean should be untouched. OK, so all these requirements make sense to me. I'm moving to design phase. So what design phase is, but OK, these requirements are quite generic, so I would say that OK, uh, these are requirements for every project where you migrate from MSMQ to SQS. Now what I, what uh Kira will try to do, it will try to apply these requirements to my specific project. OK, what do I need to do in this project in order to implement these requirements? So this is the design phase, and it will take into account like the whole project structure, my classes, uh, my dependencies, and so on. So it's working on this design document. So the design document is created. And yeah, let's see, so. It says, OK, look, this is the current architecture. So again, it went to my source code to understand like what is the current architecture, how it looks like. I have notification service. I have base controller, I have notification controller. Then, OK, how the target architecture should like, like, OK, these are the changes which has to be implemented, and then it says, OK, like this is the, uh, it shows also some code pieces, OK, this is how the new notification service should look like. This is the interfaces, some key design decisions, this is the configurations, OK, I will add this, uh, into upsettings, the configuration of a queue, the new dependencies, OK, now the project must be dependent on ESDK SQS. And so on, so again, uh, when the notification uh is saved in SQS, it has to be serialized. So this is the class and this is how the serialization will look like, and so on and so on. So again, I can review this uh design document as a developer. I can make like the changes to it, but OK, for me, now it's good enough. Move to implementation plan. So the whole process is that once you provide the intent, you first get a requirement, then design, and then the implementation plan. Yeah, so now it's creating these tasks. So tasks with a single like units of implementation, which Kerry is going to do with me. And now it's asking me, OK, like, do I want To make it fast, so some tasks keep as an optional ones, or do I want to make all the tasks required? OK, we are in a Short of time, so, OK, let's do this. MVP MVP level of implementation. So it's created the task list, so let's look at them. So these are the tasks. OK, first task, we need to add SDK dependency. Add the NG package and then add the configuration to upsettings. Then I need to update the notification service to use SQS. This is how it's done. And then, OK, I need to implement the send notification with SQS instead of using MSMQS. So I need to do the serialization, send the message, get result. I need to implement, retrieve notification and so on, so these are like this list of tasks which has to be implemented in order to implement my requirements. And then for each task I can just say, OK, start task. And then Kiri will do the implementation of this specific like first task, OK? It will add the dependency to SDK. It will add the new package, and it will update my configuration so that my upsettings. So it's working on this task. So it kind of follows the full SDLC cycle like first you're creating the requirements and then the design tasks and then it starts implementing the tasks on your behalf. Yeah, so actually like it follows like my own mental model. OK, as a developer, probably I will do the same steps. I will figure out, OK, what our requirements are, then I will figure out, OK, like how these requirements are applicable to my specific project, and, OK, like in order to implement it, OK, what do I need to do, like exactly what tasks. So Kiro is. Working And this is the beauty of a live demo, so you don't know what to expect, but uh. OK. Uh, You got the idea, so let me quickly switch to a new branch, so I will just undo all the changes. Discard everything and when I already Have a branch with uh implemented feature, so just let me quickly switch to it. So I have this branch for SQS, so good. Switch Yes, so this is where This is the feature, so these are requirements, and then, yeah, I've already implemented this feature. Sure. OK, so let's fast forward. What's next? Yeah, so let's go to the presentation mode. So what we have seen is a spec-driven development and that's the main differentiating factor, right? So, uh, white coding is good and that is available, uh, like, you know, and, and multiple other tools also, uh, but, uh, and that is good for, you know, rapid prototyping and quick fixing the issue. But in case if you are, uh, you know, you need a more in-depth thinking, you need a more, uh, you know, production level projects to be built, and that's where the spec driven development comes into a picture that, uh, we have seen. But then talk about the journey that where we are right now currently that we did the MSMQ to MS and SQS. The next part that we're going to do is actually extract our, uh, microservice to. Uh, from this monolith, right, that's what we're going to work on next. So we're going to extend this notification service into its own, uh, service, again using the spec-driven development. Right Alex? Yes, let's switch to demo. So again, for the sake of time, I will show like what kind of specification was generated and how the project was changed. So I will switch to another branch. So it's with a notification service. So if I go to Kiro folder, now I have like another specification which was created with notification service extraction. And, if I go to requirements. It says, OK, these are requirements for extracting of notification services from this monolithic application into separate .NET A to microservice so I can be, I can deploy it independently. I can scale it independently. So this is the beauty of microservices. So this is the kind of intent that you provided with which it created this specification. Yeah, so, uh, now first requirement. OK, as an architect, I want notification service to be extracted into separate WebPI project so it can be deployed and scaled independently. As a developer, I wanted to expose REST API endpoints so I can send notifications, and the main applications can send notifications using HTTP. And it goes like into more details, OK, the endpoint should be exposed at API slash notifications, and so on. OK, like as a developer, I want notification API to expose endpoints to receive notifications, OK. As a developer, I want to use HTTP client to communicate with notifications API, so I don't want to do like direct references, I want to decouple it and use the uh HTTP calls in between main application and notification service. And uh yeah, as an operator, I want everything to be configured in the URL, so OK, there is a URL of notification API which can be changed based on the environment. And the last one, yeah. Like proper dependency injection, again, everything makes sense from my developer standpoint. Proper configuration files and I want existing controllers to continue working without changes. So again, this call I mean switch between in process call to the HTTP calls should be done in the lower implementation level so that the APIs are not changed. And then, uh, yeah, it created design based on this, so like design here again, it shows like the flow but this application is called an identification service, identification service is called an identification API and identification API is using the SQSQ. And it goes like into details. OK, the base controller uses like this method and so on, so again, design is like how this specification is implemented on my code base. And then it ended up with a list of tasks, OK, create this new Werepair project. Set up all appropriate like models, dependency injection, so I already like as you see, implemented all these tasks, so there is a new project created side by side with my Kantos University project, it's called notification API. It has one controller. It has like the service, the model. And then it's using the AdS SDK SQS to communicate with the queue and also it removed like the references to SQS from my main project. So, OK, where we are now. We are a bit short on time, so we'll take the questions at the end. We'll hang around even after the session is over, and so we'll take all the questions. Uh, then we have around, uh, 14 minutes left to, uh, showcase a few, uh, extra things that we have here. Uh, so we did the step 5, which is extracting a microservice, uh, from molded. So if you look from the architecture perspective, this is how it looks like now. So we are like incrementally modernizing it right now. One thing that we would like to focus now is refactoring the UI. So when you talk about the GC.NET applications, their UI, uh, is in this particular is in razor Views, for example, and we want to move it to the modern UI frameworks like React. So that's what we are going to do right now in the next step, refactoring the UI part. OK, let me switch. So again, I will just quickly switch to the branch. Where I already refered to UI. So how much time does it take Alex to do these refactoring, like, you know, so let me show first the specification actually, not, not even the specification. Let me show the tasks for this reactor migration. So you see like now the list of tasks like is really, really huge because uh what uh Kira was planning to do is, OK, set up backend API infrastructure because I'm switching from MVC controllers to API controllers. Creating like all the response models, data transfer objects, uh, create the students API controller, create courses API controller, create instructors APIA controller, departments, and so on. Then, uh, yeah, initialize direct application using like writing and TypeScript. Uh, add the reference to material UI and then, yeah. Configure API and then it started implementing the Uh, forms, one by one. So first it's APIs, OK, build students page, create student list page, create student form page, create student create page. And then same goes for departments, same goes for courses, so it's like very extensive list of tasks, and again like this of the tasks which I as a developer would need to do myself, OK, like if I get a task convert from Razor views to React application, OK, it will be, I know, 50 forms which I need to create manually, and these are the tasks which I need to do form by form like implement with new forms. And as I already implemented this task, so. Uh, back to your question, Prasad, I think it took like maybe 4 or 5 hours to like implement all these tasks. So, and again you can think that, OK, you know, maybe it's like a significant amount of time. I know working together with Kiro like for 5 hours, but I think about like if you do same migration like manually from like, you know, razor wheels to react, OK, how, how much it would take maybe in a couple of weeks for me to implement all like 50 forms, APIs, controllers, I mean everything like that. Together with chiro, it's like less than a day. And this is with Koso University UI application implemented with everything pages. Uh Components, I mean, everything, so again, structured in a very nice way. So again, this is also a way for me like to learn like, OK, what are the best practices nowadays to implement react application, for example. Yeah, and that's where the spec driven development really stands out because it just creates the specifications. Then you can go and manually edit those specifications if needed, and then, you know, as it will implement a task, revert a task if needed. You can keep guiding it and it'll keep doing it on your behalf. So when it comes to like wipe coding, uh, that's pretty straightforward, but spec driven is where actually you need to follow that specific structure. It'll help you actually implement really complex aspects of it. So, now we did uh refactoring the UI and the final part of it would be actually CD creating the CDK project. But in case if you want to look at the uh diagram, so this is how it is. If you look at the, uh, presentation layer, uh, it changes to React app and instead of MVC controllers, it is now, um, API controllers. Right? So now let's do the last part of it, which is deploying this whole modernized applications. The codebase is running locally and it is modernized locally, but let's deploy it on AWS uh by creating a CDK project. Yeah, so again, I already created a specification and I already run, uh, created the CDK project, so I think like for CDK it took me maybe like a couple of hours to create like a CDK project and deploy it and then there were like some uh small issues to fix. But again, instead of maybe a couple of days, it took like a couple of hours. So let me switch. So again, I was using spec-driven development, so this is the specification created at the CDK deployment. So from requirements perspective, I want to deploy this Kantosoest application using CDK, CDK using C because CDK supports multiple languages. We want to use like C and when it detected that the application has three components React front end, uh, main backend, and also identification service API. Also, it must provision required infrastructure, compute database, so instead of my local Posgrid SQL database, it's provisions should provision Aurora Posrid SSQL database and no supporting like resources like no application load balancer, secrets manager to to securely store my database credentials and so on. And then it ended up creating the tasks, create CDK project, create the ECI-based deployment. Deployment scripts and so on, so the output is this uh CDK project, so it has like multiple constructs, constructs for my EC2 instances for backend services, construct for a database, for front end for messaging, and then also it created a number of scripts because when it deploys it to EC2. It has to provision resources first, then get the URL of a load balancer and then update the react application with this URL of a load balancer for backend API and then like redeploy react application. So uh Kiro automatically discovered like these dependencies, OK, like the deployment must be like in these steps, like in this order, and it created it for me. So this is the application which is deployed on uh ABS on cloud front. And something like failed recently, like my load balancer died, but OK, this is the page with like courses, yeah, OK, now it's failed to load of courses, but again this is the react application connected to the uh Amazon Aurora Postre SQL database uh through the load balancer. So again, everything was deployed by the CDK project which was created by me for me by Kiiro. We can show the architecture diagram. So let's, uh, let's switch to the slides and let's look at the arch slides. So, so we did the last step, CDK project, but when it comes to the architecture diagram, so you can see the front end, uh, the React app is deployed on S3K, uh, S3 bucket, and it is frontend by Amazon Cloudfront. Uh, the web API, uh, is deployed on Amazon EC2 Linux instance with ASP.NET core API controllers, and it has, you know, in the same code which has Entity Framework to talk to Amazon Aurora Postgra SQL. So it's not just the local Postgra SQL instance, but they've deployed Amazon Aurora Postgra SQL. And then if you can see there's another service notification service, it is reported on a separate easy to instance and that talks to your Amazon SQS. So this is, uh, you know, all the components that were modernized and deployed on AWS and Alex, this is a simplified version of the architecture, right? So this is very simplified version because we like, uh, various application load balancer. It has this route-based, uh. Path-based routing path-based routing. So like I to we pay authentication service. There is also like secrets manager to connect to database and so on, but here we're just showing, OK, like we are deployment components of so you can mentally map our legacy monolithic application to a new architecture Netbias. So that's where the whole differentiation of Quiro comes into the picture, the spec-driven development of structured way of doing it, and then, you know, deploying it on AWS. But if you look at, you know, if I try and summarize of what we have achieved so far in this session is that we started from this, uh, legacySP.NET application, uh, with Razer Views MBC controller. Uh, and Microsoft components like MSMQ and SQL Server, and what we ended up is this by doing the seven steps. The first step, putting your .NET framework application to .NET. Then we actually fix the errors and, uh, and you know, like build it locally. Then we replaced SQL Server with Postgray SQL. And then we uh replaced MSMQ with Amazon SQS and then we broke them or like doing microservices, the notification service that is uh there. And then we refactored the UI to react. Uh, and then finally, you, you use CDK to deploy it onto AWS uh with all the components that is required to make it a functioning application. So that's pretty much that we have uh for today, and we do have a few resources for you to get started, uh, you know, uh, AWS transform for .NET, uh, for upgrading your .NET applications and AWS, uh, uh, uh, and Quiro to for you to actually like do this whole, uh, not only just wipe coding but also the spec-driven development. That's where the actual strength of Quiro comes into the picture. The whole AI ID comes into the picture. I'll pause for a moment for everyone to take pictures, who is, uh, yeah. And then we do have a few resources, uh, like a lot of, uh, agentic AI courses on, uh, AWS, uh, SkillBuilder. So feel free to actually, you know, like, uh, go to it and a lot of them are quite, uh, you know, uh, free, uh, available, uh, courses on agentic AI on AWS. And thank you very much. Thank you very much. Uh, hopefully you enjoyed it and we are around here for any questions. So, uh, yeah, we, we are here, uh, for the questions.