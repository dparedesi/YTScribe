---
video_id: 4juNJwolx4Q
video_url: https://www.youtube.com/watch?v=4juNJwolx4Q
is_generated: False
is_translatable: True
summary: "Hrishita Chakraborty, a Senior Technical Account Manager at AWS with nearly two decades of orchestration experience, delivers a compelling session on modernizing serverless architectures by leveraging JSONata within AWS Step Functions to eliminate the operational burden of Lambda proliferation. She opens with a powerful analogy, comparing the traditional, disjointed approach of serverless development—which she likens to the manual, multi-step process of making coffee in the 1920s involving separate stoves, grinders, and pots—to the seamless efficiency of a modern automated coffee machine. This metaphor sets the stage for her critique of current workflows, specifically using a stock trading application as a case study where developers typically deploy individual Lambda functions for simple tasks like checking stock prices, buying, and selling. Chakraborty argues that this glue code approach creates unnecessary complexity, forcing teams to maintain extensive CI/CD pipelines, manage runtime deprecation cycles, and incur higher latency and costs due to frequent service-to-service hops. The solution she presents is JSONata, a lightweight, open-source query and transformation language inspired by XPath that is now natively embedded in Step Functions. Through detailed demonstrations, she shows how developers can replace these transformation Lambdas with direct HTTPS API calls and use JSONata expressions to manipulate data payloads intrinsically. For instance, she illustrates how to perform complex analytics within the state machine itself, such as filtering transaction arrays to distinguish between long-term (held over 365 days) and short-term holdings for tax purposes, and using built-in functions like $sum and $average to aggregate financial data without ever invoking a compute instance. A key highlight is her demonstration of Amazon Q Developer, where she uses natural language prompts to instantly generate complex JSONata patterns—such as formatting inputs for DynamoDB which requires strict type annotations like S for string and N for number. This capability allows developers to test and validate transformations directly within the Step Functions console, significantly accelerating the development loop. The session further explores the frontier of Generative AI, showcasing a fully autonomous social media agent workflow. By using JSONata to construct payloads for Amazon Bedrock’s Converse API, the architecture effectively manages system prompts, model IDs, and tool use results purely through configuration, removing the need for a Lambda supervisor to manage the LLM's interactions. Chakraborty concludes by emphasizing that while Lambda remains essential for heavy computation, adopting JSONata for data manipulation allows organizations to build workflows that are not only 800 lines of code lighter but also faster, cheaper, and far more readable, effectively solving the goodput problem in orchestration."
keywords: AWS Step Functions, JSONata, Serverless Orchestration, Lambda Reduction, Data Transformation, Workflow Optimization, Amazon Q, Agentic AI, DynamoDB Integration, Low Code
---

Hello everyone. How are you doing? How's your re even going so far? All good, having fun. All right. Welcome to the session on simplifying orchestrations with Jasonnata and AWS step functions. My name is Hrishita Chakraborty. I'm a senior technical account manager at AWS. And I've been working with orchestration use cases with customers for over 18 years, and as part of this session, we are gonna be talking about how to simplify orchestrations and why does it matter, why do we need that simplification. Alright, so quick audience poll in terms of how many of you are familiar with step functions like raise your hands. Alright, I see a couple of hands over here, that's great, but just to level set, we'll do a quick introduction otherwise as well. So what are step functions? Step functions is a low code visual workflow service. Uh, it provides you with orchestration for AWS services as well as your third party APIs or your own application APIs as well. It supports common workflow patterns like parallel workflows or iterative workflows, you want to create some maps, you want to do human workflows, you want to have long running workflows, you want to do some error handling, retries, end to end monitoring, all that comes with step functions by default. It supports common workflow patterns. These were the workflow patterns that we talked about, and it simplifies automation and orchestration use cases. So think of automating ETL uh scenarios or automating security and IT automations, um, or orchestrating microservices or agentic workflows. All right, we'll not get into too much of that, but we do have a slide for that as well at the end. So let's start off with the traditional approach in terms of what step functions you would normally see. Right, and here you have a very traditional approach for step functions where you have a lambda function which you invoke to check stock price, and then uh you have a human approval to decide what to do with the stock you buy or sell, and then you have a lambda invoked to buy the stock or to sell the stock, you make a decision and then you report the results. So very traditional serverless stock trading workflow uh that you might have seen before, right? And what do we see over here, some, some of the things, we have a lot of lambda functions, right? Uh, and this is a valid architecture. But what are some of the pain points that we see with this kind of an architecture? Some of the common pain points that we see with this architecture is lambda function proliferation. We have so many lambda functions that we have to maintain all these lambda functions now, right? There's limited data transformation capabilities, uh, previously with step functions, right? You had Jason path, and then you had to juggle between input path, output path. That was not very convenient, right? And then you have maintenance challenges with all these lambda functions that you have. You have to now maintain these lambda functions. You have to maintain the CICD as well as the deprecation. Let's not forget about that, right? And what it leads to is increase in latency and cost, right? You're hopping from step functions to lambda functions, and now you've got to pay for both of them. Now how many of you are familiar with Janata? Have you heard of it? All right, nobody. All right, let's, let's enter Jasonnata. That was not a very correct English, but OK. Let Jason Arta enter. All right, so Jason A is a lightweight query and transformation language in uh Jason. It's open source. It's inspired by X path, so a lot of people might not be familiar with it, but I'm probably from the dinosaur age, so I am familiar with X path as well. So you're able to navigate adjacent objects and arrays. You can flatten out arrays very easily, and you have all these built-in operators and functions that you can use for manipulating, right? So you have numeric operators, boolean operators, string functions, a host of functions that that are there, and I'll have the references at the end, so you can look at the documentation as well. And out of these you can create user defined functions, so you can have these variable definitions and then combine all these functions together to create your own unique user defined functions that you can use. And the best part of it all. All of this has a native integration with AWS step functions, so you're not having to do anything additional on top of it. It's inbuilt, it's available within step functions itself and you can use it. Alright, so now let's get back to that same slide that we were looking at, the traditional approach, right, we had these lambda functions, and for a workflow this small, 3 lambda functions was a little too much, right? So what do we do? Let's get rid of the boxes. Should we flip it? Should I try flipping? Probably not, uh, I won't be very good at that. Alright, so let's flip that. So let's, and this is what I call the simplified approach, and as part of this simplified approach, what I have done is the first strategy is I have removed the lambda functions and I'm now making direct HTTPS API calls. We are using the transformation power of Jasonnata as we are calling, and as a result there's no lambda proliferation now. We are changing the payload using Jasonnata to fit the end system. You can get input in any structure that you want. And you're formulating that to send it to the end system using Jasonatta. Now let's add a little more complexity to it, right? Um, what if we want to use all these transactions that we are getting and aggregate all these results and send it to the, uh, report to the consumer as a report, right? It's a stock trading application, so you might want a report at the end of the day, what all you sold, how much did you earn, how much did you lose. So let's look at that and that becomes a data analysis scenario now, right? So if you look at the input over here, and let's look at the red box input, you have these transaction IDs, uh whether you want to buy or sell, the stock symbol, and then the sale price and the quantity, all of that associated with that. And at the output, In terms of what you want to send to the consumer as a report is the transaction type, whether it's a long term or a short term transaction. So what do we mean by long-term transactions for those who are you, all of us don't do stock trading, right? What is long-term transactions in the stock world? Long-term transactions are transactions that are, uh, that are held for greater than 365 days, and often they have different tax implications depending on the countries that you are from, right? So. We'll use that, but you see, but you understand the, the, the scope of this, right? We are now aggregating the data. We are doing data analysis on it. So let's look at the step functions ASL snippet that we have, and this is in YAML so that we can read it better in a little easier way. So what we are doing over here as part of this, this is a Jasonnata, we are defining these variables for long-term and short-term, where we are filtering the input depending on when the purchase was made. So we are doing that filtration at the top, we are defining these variables. And then we are mapping these into long-term and short-term. We are counting it in terms of the transactions, you know, how many long-term, how many short-term, and then calculating the sell value or the gain or loss that are associated with it. But you don't have to limit yourself to this data analysis scenario for stock trading. Think, extrapolate this and think of all other automation use cases where you might need to do all these numerical calculations or string manipulations, and think of those scenarios where you would be needing these but do not want to invest in a lambda function. You could straight away do it as part of the step functions. Alright, so coming back to that slide, now you have this output where you have the, the transaction type, the total transactions, the sell value, and the gain or loss associated with that. And this brings us to the simplified approach of the strategy number 2, where we are using optimized service integrations. In this case we are using SNS Publish for the optimized service integration, and we are again performing all the complex transformations using Jasonnata. And in this case you saw we did a lot of data aggregation as well as part of this. Now does the story end here? That would be too simple, right? Let's complicate it a little more, right? All right, let's add a, let's say we want to persist this data now into Dynamo DB. Maybe at the end of the year the customer wants all the transactions that they made and they want it to be persisted to a Dynamo DB for that. So, let's look at the input and the outputs associated with that in terms of what are Dynamo DB ones. A common problem that we have had when we have used Dynamo DB in the past with step functions is that, Dynamo DB needs this structure, this exact structure, uh, in, in terms of how it is formatted for Dynamo DB to be inserting the items, and we'll see how we do it because we have talked a lot about all this, but how do we write this Jasonnata function? Some of that sounds looks a little bit complicated, right? So let's, let's look at a quick demo in terms of how we would create it and how actually I also created it. All right. So as part of this demo, we see that uh we have the, we have the Dynamo DB order input and this is just the input from the last step that we have. And we'll open up the input structure that the Dynamo DB expects, right, that that would be the task output, but it would be an input to the Dynamo DB. And in this case we are going to be using Amazon Que, uh, and this is my Visual Studio code IDE. We're going to use Amazon Que embedded in it, and we are just gonna write a simple natural language query saying that OK, use this as the input, this is the output, and write me a Jasonnata query. Simple, right? And just one tweak, I just wanted to use single codes instead of double codes so that I can, I can just directly copy paste stuff and not have to worry about replacing all that. All right. So Amazon Que thinks about it, ponders about it, and then generates a Jasonnata query. Alright, so let's look at that. It generates this Jasonnata query. Now how do we know it did it right? Do we know that? We don't know that. Let's take it and let's see how we could test it. So we're gonna take this Jasonnata query and then we are going to go back to our state machine that we have defined, and in this case we have a sample state machine. We want to edit it. And that will bring us to the, the sample screen that we have and in this case we are going to use the batch right item and the test state button. We're gonna use that test state button and in the arguments we are going to pass in this Jasonnata that we had created, right? Because that's what the Dynamo DB expects. So we're gonna put that in and then we have the input that we were already showcasing and we use the start test. And that just creates this structure, exactly the structure that Dynamo DB expects it to use. So you saw in essence, I did nothing. It was all created by Amazon Que and we were easily easily able to do this without using any lambda function, without using anything else, and all of this within step functions itself. Alright, now let's look at this right definition in a little more detail so that we have some of the things that you might have noticed that we do not want to miss out on. So one is the stock orders. The stock orders is essentially the dynamo DB table that we are using for the insertion. And then the dollar states. input is the default input that the step function expects. Now, uh, ideally Que developer creates it using dollars. You can put in a prompt. When you put in the prompt, you can say use dollar states input. You can also use any variable if you have put the input into a maybe an input variable, you can use that variable instead of the dollar states start input uh instead of that. And the next item is the inside the item we have this unique ID which is the UU ID which is the unique ID that we can use as part of this dynamo DB insertions because we want every transaction to be, to have that unique ID, right? And it's a, it's a defined function that you already have. And then you map the other rest of the stuff as string or number and you map it out. You can use functions for, you know, the present date or time, and there are other lots of other user defined functions. So essentially you get this input to the Dynamo DB that is created within that step function task itself and then processed within that single step. So everything within step functions you're doing and you're able to process all that information. Which brings us to the simplified approach of the strategy number 3. You're gonna be making direct SDK calls, and again use JCada to manipulate the payloads. Alright. So 3 steps to simplify orchestrations. Use Jasonnata to perform complex data manipulation. Use SDK optimized integrations and HTTPS API calls where you can, and reduce the lambda dependency. Right, Jasonada can eliminate a lot of transformation lambda functions. You're able to eliminate lambda. You can use your numerical calculations, payload manipulation, everything within step functions itself. And that brings us to the simple orchestration world as we would call it, and here we are revisiting the pain points that we discussed at the very beginning, right? We are able to simplify maintenance because lambda comes with ongoing runtime maintenance. You have to maintain the CICD pipelines. You have to take care of deprecation, very important, I think with most of the customers that I've worked with, lambda deprecation is a serious pain point. So you're able to build your those IT automation use cases using this without having to worry that you would have to go back and again revisit this lambda deprecation or lambda getting the, the, the language getting replicated after a couple of years. You also get lower latency, uh, so direct calls within step functions means that you have lower latency and then lower cost because there's no additional lambda costs that you have to pay with, it's all within the same step functions. Alright, it's 2025. How can we not talk about Gen AI, right? How many of you have attended, uh, any GAI session or agentic workflow session as part of this reinvent? OK, I see some hands. All right, so let's do a quick sneak peek. We'll not go into too much detail, uh, but this is a generative AI agentic workflow that we are building using step functions. Couple of things that I want you to gather out from it. Firstly that this is definitely possible. You can build these workflows using step functions. These are autonomous workflows that you can build using step functions. For this example particularly, this is a tool use architecture where we are using multiple tools to make decisions and the LLM makes decisions associated with what it needs to do. So this example is for a social media agent that repurposes long form content across multiple social media channels, right, so maybe LinkedIn needs it in a different format versus Facebook or maybe some other social media platform, right? So it's able to, you know, summarize the content, post the content, and adapt the tone associated with what social media you are posting it to. Now what's the common point that we see across all of this based on what we have seen across all the gene, you know, all, all the lessons that we have learned so far? We are able to replace all these lambda functions that we saw using the bedrock runtime calls for converse API, right? You can still continue to use the lambda in a supervisor role, and that's a valid architecture. Using lambda is a valid architecture if, if the scope gets too complicated. But at least you should not have to go back to lambda for every single small transformation that you are thinking of doing. You should be able to do pretty complex transformations within step functions itself. So the microservice architecture pattern would still apply, uh, but at least you don't have to, like I mentioned, create that lambda function out of everything, right? So let's look at what the ASL for this would look like. You have the arguments over here. You have the model ID, the messages, the system prompt that you're defining, everything within step functions, and you can define the output that you would want the tool to be, you know, get the output for as a tool result as well with the Jason with adjacent content and exactly what you want for the agentic workflow to work seamlessly. All right So what do I want you to take away from this session? The only thing that I want you to take away from this session. Is this coffee pot that we are seeing on the screen? Well, no. Imagine what making coffee in the 1920s would have been, right? You would have to use a stove top, a pot to boil the coffee, and before that you would have to grind the coffee and then make the coffee, decant it, and then put it in. You have all these separate pieces that are associated with it. Think of this simplifying orchestrations in a very similar manner. Jasonnata can eliminate a lot of transformations that lambda functions can do. You have reduced latency and cost for data manipulation. You have improved workflow readability and maintainability, and all of this within native step functions itself. So what I want you to think of this is a modern coffee machine which can simplify your orchestration route and ease out your automation very easily using Jasonnata. And that marks the end of this talk today. Uh, I, I do have some resources for you. Uh, we have the Jasonnata documentation that you would definitely be needing if you want to make any changes with Jasonnata and also to see how much scope and how much variety it actually has in terms of functions that are already available. I have a blog link that also describes how you can go about using it and some surveillance land resources as well. And you can check out some of these other sessions as well, uh, if you have not forayed into the world of AI agents, uh, then these are some of the sessions as well as some developer productivity sessions as well that you can, uh, take a quick look. All right, uh, and thank you. Please do complete the session survey in the mobile app, and I hope this was. Thank you.
