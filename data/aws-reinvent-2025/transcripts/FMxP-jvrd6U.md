---
video_id: FMxP-jvrd6U
video_url: https://www.youtube.com/watch?v=FMxP-jvrd6U
is_generated: False
is_translatable: True
---

Uh hello everyone, um. Glad you were able to make it, uh, first day of reinvent, so long time to go. So hopefully you're drinking your liquids and getting ready for the week ahead. Um, today, uh, my name is Ritesh Desai. So today we're gonna talk about Secrets management and its journey, specifically about how you wanna build your architecture, keeping Secrets manager in mind. And with me I have Zach, uh, who will be also talking about secrets management, specifically about Secrets management manager AWS Secrets Manager and how to apply it within your architecture. But then we also have Jake with us, a customer from Acria, and he's gonna talk about their journey through the secrets management, uh, life cycle and also how the architecture enables you to build a more modern secrets management solution. So here goes. Uh, like I said, the agenda would be more secrets management overview. So I'll talk through a little bit about AWS Secrets manager, and then Zach will go into more deployments at scale, um, as I mentioned, Jake will kind of take on and talk through their journey, which I think will be the most interesting part of this presentation, and, uh, hopefully we'll close out with some of the latest launches that we have for reinvent and before reinvent so. Uh, as you know, there are many different kinds of secrets. Specifically, as you can see, there are a bunch of secrets that people think about in one sort of whole, uh, model and say this is what I want to manage right as a customer, but AWS thinks about it differently. We build purpose built services specifically for secrets that need to get managed. For example, AWS credentials. AWS IM would be the right service for that. Uh, encryption keys, KMS or key management services, the service that is enabled, but for all of these other services behind or secrets, sorry, uh, database credentials, application credentials, all of that, AWS Secrets Manager is essentially the default choice, AWS. So what is Secrets Manager? Um, I think a bunch of people have used Secrets Manager. It's a. It is a secret life cycle management service, essentially enables default secure storage. It integrates with multiple other AWS services. So for example, it integrates with AWS Cloud trail to make sure all the auditoring and monitoring is in place for every action that is taken on a secret creation, mutation, delete, all of that whole life cycle is managed. Um, it integrates with lambda. To make sure that we have automated rotation for your secrets so you can go into Secrets Manager and configure our rotation by creating a lambda function. And then scheduling it for to run like every 30 days, every 90 days, or whatever your organizational policies are. We launched about 3 years ago something called replication where Customers told us that they wanted to have a solution for business continuity where a RDS database for example fails over to another region but then a secret needs to be also be available in that region so we built a feature that will enable you to replicate your secret across multiple regions. Um, it is the most used feature of Secrets Manager at this point in time, and so replication is one of the things that people talk to us in terms of business continuity or disaster recovery point of view. Um, and then we are continuing to look at areas where we can make it easier for customers to retrieve their secrets. So when I say retrieval, it's at scale. So today Secrets Manager supports 10,000 TPS for get secret value, and we continue to enhance that and stay ahead of customer expectations, right? Like so there's no customer that comes close to that, but we continue to build more and more capabilities to enable retrieval at scale. In addition to that, we try to make that whole experience easier, so we launched Secrets Manager Agent, which is an open source. Um, it's available open source where customers can enable the retrieval of secrets by automated caching, creating a TTL, all of those configuration that you need, and that's another, uh, launch, I think it happened in late 2024 and it's been, uh, relatively taken over by customers pretty quickly, right, and we are trying to enable that kind of ease for developers as they try to manage sequences. So at a high level, this is how Secrets Manager works. And I'm, I'm sure some of you know about this, but when you go in and create any secret and secrets manager by default, it will envelope encrypted with an AWS manage key. So there is no secret that is just in plain text, so there will always be a KMS key that encrypts your secret and stores it. If you want to go ahead and create your own customer managed KMS key, that is also possible. There are many customers that try and use that that functionality. So one of the key benefits of using KMS key is that it enables you for cross account access. So there are some customers who come to us and talk to us about hey we need to create a secret in a sing all my secrets in a single account and then I have applications from different accounts trying to access the secrets and that's not possible if you have just AW Spanish key and I think Zach in the later slides will talk about how when customers think about centralized or decentralized approach of secrets management those things really matter, right? Um, as you can see, I talked about it a little bit. Amazon Cloud Watch, Cloud trail, those are one of the key, uh, aspects of compliance, and customers continue to use those to kind of build some listening agents or an ability to alarm them on an anomaly or any activity that happens happens on a secret that they need to track or alert their teams on so that is one of the aspects of it. And then I'm gonna uh let Zach talk through the centralization and decentralization aspects of it so here thanks Ritesh. So you know, like Pratesh just alluded to, uh, well first off I guess I'll introduce myself. I'm Zach. I'm a security SA and what that means is, you know, I, I focus on cryptography and our secrets management services and so. I talk to customers pretty much every day about keys and secrets and certificates and you know like Ritesh alluded to one of the first questions that we usually get are what do I do with these secrets? Should I centralize them in a single account? Should I put them across, you know, a number of accounts? I have 50, 100, 1000 AWBS accounts. How do I do this? Um, and you know, originally I've been doing this for 5 years or so. And originally we would tell customers that you should do a decentralized approach. You should put the secrets close to where, you know, your application workload is. Over time as I talked to more and more customers, I find that there are many customers that actually wanna take a more centralized approach. Maybe they're financial services customer, you know, they tend to wanna have that centralization where they have good, um, you know, strong observability and, and centralized control over their secrets, or maybe you have a specific compliance. Requirements or something of that nature, right? and so over time our our guidance has kind of evolved from hey every customer should decentralize their secrets management to it kind of depends it's gonna depend on what your requirements are and what you wanna get out of your secrets management, um, you know, system. And so there's a number of kind of areas or pillars, you know, that, that, that you should consider. One of them is creation, you know, how do your developers create their secrets or your engineers create their secrets? How do you manage those secrets? So things like how do you rotate them and how often, uh, or do you replicate them to multiple regions? How do you keep track of versions or I, you know, secrets manager keeps track of the versions, but how do you manage those versions, I guess. And also a consumption or retrieval, you know, how do you, how do developers get access to those secrets or how do your applications get access to those secrets? And then of course the through line of all of this is like observability and auditability. How do I know what's happening with my secrets and who's accessing them and when and things like that, right? And so again, you know, as I said before, it kind of depends. And I'm gonna talk through uh these pillars, both the centralized and the decentralized versions and you know think about what makes sense for you or what you already do in your own environments. So talking about creation of secrets, you can centralize that, right? So that would be, you know, your developers have a CICD pipeline that they have to use. They have like a terraform module or a specific way that they. Uh, need to generate and create secrets in all of your workloads, you know, you might do that in a centralized way. I've also seen customers that will actually create like an abstraction layer where there's their, their developers are calling an API that they create which on the back end is calling some secrets manager API, right? So there are a number of ways to kind of do this centralized approach, but that is. Again, pretty popular, especially with like, uh, financial services customers or highly regulated customers and so in this approach, you know, the advantages are obviously you have pretty consistent things or or you know, consistent policies around naming and tagging, you know how access control is done because everybody's doing it the same way through the same system. But on the other hand you also have more initial overhead because if you're building an abstraction layer you gotta write that code you gotta maintain that code you know there is a lot of setup involved in kind of configuring this whole thing before anyone actually gets started using it. Um, and then of course that overhead extends to new releases when Secrets Manager launches a new feature, a new API, you're gonna have to update that abstraction layer to support that API for your own developers, right? So there's obviously some overhead with this approach, but it does give some customers that want it a lot more centralized control over how their secrets are managed. And then when we look at this next model of decentralized creation of secrets and again when I say decentralized I mean you know putting them in the accounts closer to where the workloads live. You may, you know, this is probably the most common one I would say in terms of creation, but you know you're just gonna have your developers, maybe they have an application account that they own and they use the standard ADBS SDK, ADB CLI, the console to go and create these, or they could also do it through CID, uh, CICD as well, right? But in any case they're doing it specifically, you know, in their own account. The application developer is managing it. Um, you know, trade-offs you're seeing, you know, you can see them on the screen, but basically it is simpler to adopt. You don't have to build that upfront abstraction layer or that, you know, kind of portal that they might use to create those secrets, and they have more flexibility. They have more control if there's certain things. Your developers wanna do if they wanna name their secrets in a particular way or they have specific access control requirements typically your developer or your app teams will understand their own access requirements better than some centralized team that may or may not know anything about that application, right? And so there are obvious advantages to this, but there are trade-offs where, you know, you have additional effort to implement these controls like I said with the previous model of centralized, uh, deployments or centralized creation. You can have a pretty granular set of controls on how secrets are named, how they're tagged, how the access control works on each of these secrets, whereas in the decentralized model your developers or your app teams are kind of in control of that, so you may not get consistency across all of your different accounts and all your different apps on how this stuff is named and how the access control works. And another piece is logging, right? Uh, you're not necessarily if you have a centralized security team or something, they're not necessarily gonna have access to all of those cloud trail logs about when those secrets are created in the various application accounts unless you're, you know, you're kind of pumping these into a centralized, uh, security logging account, which by the way is the best practice and I would recommend, but not all customers do that and so you're not necessarily gonna have the same level of visibility across the account or across, um, all your secrets across all your accounts. And now when we think about life cycle management. I'm talking about again rotation and things like um you know managing different versions and things like that and in this way you can do it in a centralized model again where you have like a management account that one team controls potentially you know like a engineering team or something of that nature or security engineering team rather. And they have a set of lambdas that can be used for rotation. And even though those secrets don't live in the same account, your your rotation lambda is able to, you know, with the right permissions go in and rotate that secret on the database, rotate that secret and secrets manager, and this is something we see customers do. In fact, there's a really interesting reinforced talk from, I think, last year where, uh, one of our customers talks about how they do this centralized, um, centralized management of secrets and. Uh, you know, again, like some of your advantages here are developers don't have to worry about rotation, right? If your developers are focused on building value, building value into your applications, they don't wanna necessarily think about secrets management, and they particularly don't wanna think about how am I rotating all my secrets across all my databases, for example, so kind of offload some of that burden from your developers and some centralized team whose job it is to think about secrets and how to rotate secrets can handle that. Also, you know, your compliance team might have a very specific, uh, requirement around, hey, all of our secrets need to be rotated, and I need to see that in action. I need to, you know, that, that needs to be proven to me basically. And so this model might make that a bit easier, right, where you have all your rotation lambdas in the same place. Anyone can go and kind of examine them and see how this is being done, gets the logs around those lambdas being run in the, the rotations happening, right. I think the main trade off here is this requires pretty complex permissions to set up because you think about what those rotation lambdas are doing and some of you may or may not be familiar with Secrets Manager, but what this lambda is basically doing is setting the secret value in Secrets Manager and then logging into say a database and then changing that value to match it on the database, right? A little bit more complicated than that, but that's the basic idea. And so in order to do this from a centralized account, that lambda has to have permission both to access the secret and say this workload account one on my screen, but also has to be able to access that RDS database and log in and actually change the secret there too. So you gotta do pretty, you know, you gotta do some work to kind of set up those permissions in order to allow that lambda to do what it needs to do, and that could get complex across lots and lots of accounts. And so again kind of probably the more common model is decentralized life cycle management where your application team, they create the rotation lambda for their databases or whatever workload, um, you know, whatever their, their secrets they're managing and they're kind of able to design that and, and kind of maintain that and, uh, you know, build that lambda themselves, I suppose, right. And so they have their own control over compliance requirements. How often do we rotate? Uh, there's a feature in Secrets Manager called rotation windows where you can say, you know, I only want this secret to be rotated, say, every Wednesday at 12:00 or between 12:00. and 2:00 a.m. or something like that, right? So the your application team might have or probably has a better understanding of when their app, you know, has less traffic and when would be the best time to rotate secrets and so. They just have a little bit more control in this model of when that happens and how that happens. Doesn't require any sort of, you know, cross team permission sharing. You don't have to make sure that every single new account that gets vended, that that lambda rotation function has access to that account and those secrets in that account, much, much less complex in terms of permission management. Um, the trade-offs similar to, uh, the same thing with creation. You're gonna have a little bit less visibility because the logs around around rotation are all gonna be kind of in those specific workload accounts instead of a central place, and your security and compliance team again have a little bit less visibility into how this works. There's not just a single account that they can log into with a read-only role and say, you know, OK, I see what's happening. I see what lambdas are being used for rotation. I see the logs on how often it's happening, you know, you kinda have to, um. Either you know get those logs all into a central place where they can look at it or give them, you know, read only access roles to all of these different accounts to kind of figure out how is this, uh, life cycle management taking place. Then we go to consumption or retrieval might also call this storage where you store the secrets, um, centralized would be, you know, as it sounds, one single account, all your secrets are there, um, you know, some of the advantages of course are again you have kind of full control over all the secrets in the organization. It's in one place. If you have a central security team that's managing these, it's gonna be much easier for them permissions wise to easily view and manage all the secrets in the same account. You also have, without having to do any fancy, you know, cloud trail, uh, stuff, you already have centralized logging where every single log for these secrets are gonna be kind of in the same place and you can view those pretty easily but you know, as you might have thought about, there is also a bit of an impact radius risk here right now all your secrets are in one account in one place and if that account is ever compromised in any way. All your secrets are in there, right? So that is a potential trade-off that you wanna consider and you wanna very tightly restrict access to that account. Um, the other big one that customers don't always consider is if you have all these secrets stored in the same account you aren't able to take advantage of some of the really cool features that Secrets Manager has like managed, uh, rotation so. Very briefly, I don't have a slide on this or anything, but the, you know, we have an integration with, for example, RDS where when you create an RDS, uh, database you can click a single checkbox in the console or have a single parameter flagged in the CLI or the APIs that basically says I don't wanna manage this admin secret. You manage it for me, you rotate it for me, we'll generate the secret. Nobody ever sees it in human being anyway, and we, uh, you know, we rotate on that on your behalf. No managing lambdas, any of that stuff. And I've had customers say great, this is awesome I wanna use this, but all my secrets are in the same account and the RDS databases are getting created in another account, a workload account, right? In that case you can't use that feature or at least not maintaining the same security profile with centralized secrets because when you click that check box and create the RDS instance that secret will be created in the account where the RDS lives, right? So I've had some customers that wanna take advantage of both but end up in a situation where now you have almost all your secrets in one place except for these admin secrets for RDS where they're in the at the in the other account. So you know there's a couple of trade-offs with the centralized model. Um, and, and you know, some of the features aren't necessarily gonna work the way you intend. Um, and so again like kind of the decentralized version here is we put all the secrets in the same account or I'm sorry, in the account where the workload lives and you know they're kind of separated in a logical way for application teams, at least if that's if that's the way you do your ABS accounts, you know, a lot of customers will have a single account per application or workload and so if that's the case, your secrets live there, your databases live there, your compute lives there, it's pretty logically separated and. Uh, you know, makes access control a little bit easier and permissions management a little bit easier. And like I pointed out before, not always, but almost always I would say application teams are gonna understand their own access control requirements better than some centralized team and so in, you know, in my view it's often better to have application teams on the permissions because they're gonna be able to set least privilege permissions perhaps better than some, uh, security team that doesn't always know exactly what's going on with this workload. Uh, trade-off wise again, a little bit of less visibility and things like logs are all kind of created in that account and so you have to do some work to make sure that you're putting all those logs into a centralized security account so that you know your, uh, investigation teams or your SOC or whoever that needs to review those, uh, logs are able to get to them in an easy way. OK. The other thing I want to point out, and this is maybe more common than customers taking one approach or the other, you can kind of combine this stuff, right? You can combine these approaches into more of a hybrid model. Like this is probably the more common one I see when customers, uh, combine the approaches where maybe the creation and the management of the secret is done through a centralized account. Maybe you have a specific pipeline that's supposed to be used or again, like I said, I've seen customers use like a specific terraform module, um, that they want their uh that they want their developers to use to generate these secrets, and then they'll also handle rotation from that place as well. Uh, but the storage might be, you know, decentralized or kind of where the workload is, and there's other ways you could do this. You could do centralized creation but not management or storage. You could centralize the storage but not, you know, the creation, but I think this model makes a lot of sense for customers often because, uh, again, like your developers are creating the secrets in a very consistent way. The naming and the tagging and the permissions can be made consistent through this kind of centralized mechanism. And the way you're rotating secrets can be consistent so it's a little bit easier to, to, uh, you know, comply with internal standards or even regulations and prove that hey, all of our, all of our developers create these secrets the same way and we rotate them the same way we have the logs and we have the information on how that's all done in one place, but your application teams still are able to, you know, easily access those. Secrets from, say, you know, their ECS cluster or lambda or whatever compute they're using without having to worry about sent permissions, right, because when you have a centralized permission model unless you have a lot of automation in place, you're often gonna have to cut a ticket to a security team, say, hey, can you, can you give me access to this secret I just created, right? And that's not obviously gonna be the most agile solution for developers and so I think having a mix of kind of the centralized approach for creation and maybe rotation gives you that consistency, whereas decentralizing the storage and having them where the workload lives makes a little bit easier for developers, right? So definitely possible to combine those approaches. I don't wanna make it seem like a binary choice. I just wanna give you some examples about, you know, a model mental model to think about how some of this works. And then lastly I wanna talk a little bit about resilience and then we'll get to, uh, as Ritesh said, I think the most exciting part of the presentation where Jake's gonna talk about Aquia, uh, but you know about resilience, you know, customers will often ask, hey, I need to make sure these secrets are accessible even if something happens and I can't access a particular AWS region. And so, uh, as Ritesh mentioned earlier, we have a feature, uh, called secret replicas or, uh, secret replication. Where you create a primary secret, say, in USC East 1 or USC 2, and you're able to create replicas in as many other regions as you'd like and so it's basically a discrete secret. It has its own RN. It's, it has its own resource policy associated with it, but it is, uh, you know, the value of that secret is the same. And, and when you rotate the primary version of the secret. That change replicates to all the others as well and so you know you can see on the screen, uh, a very simple sample application where you have a lambda. It needs to get access to an RDS database to query some data, and it needs a database password to do that. And so in this model where we've replicated that secret over to in this case, US West 2, a secondary region. Um, you know, even if you're not able to access that secret in US East one in this case, you'll be, you know, the lambda in US, uh, US West 2, sorry, is gonna be able to grab that secret and use it to query the cross region read replica in this case. And so I just wanna make it clear that we have the ability to replicate these secrets so that, uh, for your resilience kind of global workloads we're able to have versions of that secret in different ADS regions so you can access them when you need them. And with that I will pass over to Jake who's gonna talk about Aquia's journey. Awesome, thank you. Uh, good afternoon, everyone. It's a real privilege to be here today with, uh, Zach and Ritesh from the AWS, uh, Secrets Manager team. My name is Jake Farrell. I'm the senior director of engineering architecture, uh, at Aquia. Uh, and over the past 12 years I've been designing and creating scalable back-end infrastructure systems that enable our customers to build some of the world's most unique websites and digital experiences. Today I'm excited to share with you some of Aqua's experiences and our secrets journey and how a close partnership with AWS Secrets Manager has unlocked new possibilities. At Aquia we believe in the power of community and giving our customers the freedom to innovate and build impactful experiences as they see it. Open source is built into our DNA. Aquia started with a focus around supporting the content management system Drupal and its community. The belief of open transcends our company and has led Drupal to be one of the most popular web content management systems for enterprises. Outside of Drupal hosting, Aquia offers companion supporting services from search, machine learning, personalization, automated marketing campaigns, digital asset management, and AI services. We're the number one contributor back to the Drupal open source project, and many of our employees are highly engaged in other open source communities. Customers build their digital experiences on Aquia because we provide the most secure, easiest to deploy, simplest to manage platform, ready for scale when the moment matters. The largest media companies trust running their digital experiences on Aquia, including NBC Sports. With over 30,000 sporting events each year, managing content can be a challenge. From golf to the Olympics, NBC reimagined the fans' experience and raised the bar. At the last Olympics, NBC Sports with Aquia. Had thousands of content and media updates with billions of total streaming minutes served and was viewed by millions of unique visitors at the food industry. Wendy's partners with us for a digital transformation to move faster and gain better customer insight for web and mobile orders, utilizing machine learning. Aquia's personalization service has helped Wendy's engaged at new levels for their customers like AB testing of their different product combinations for their website, and Moisson Coors was able to key on. Aspects of that AB testing and allow for a unique reduction of key components that allowed their marketing and branding to create flash pages on an instant reducing their total cost of ownership. Aquia is in the business of enabling companies and creating digital experiences. The largest organizations across every industry, from entertainment, retail, education, and government, trust Aquia to securely run in scale to meet their needs when it matters most. So what powers all of these experiences? A reliable cloud native platform built on AWS that meets the highest security and compliance standards for developers. Built with a Kubernetes backbone, we support managing services from the Aquia platform, which is acting as a building block for the best in class digital experiences that can be imagined. Instead of a one size fits all approach, Aquia Cloud allows customers to assemble the perfect solution to meet their unique business needs, fostering better collaboration and faster innovation across their entire organization. So what led us to leverage AWS Secrets Manager? Our our platform has scale and security at its core, and not all secrets are the same. Their visibility, their life cycle, and their behavioral patterns vary. So as we shifted to Kubernetes, we had to account for this full range. There are many types of secrets when you look at critical bootstrap configurations, database credentials, and TLS certificates that are needed to get a service off the ground and running, and then looking at connecting the remote system, environment overrides, application tuning, and general user base secrets for the application space. This complex landscape exists in almost every application in a Kubernetes environment. In scale, challenges naturally begin to emerge, and we identified four core aspects to solve for that sprawl. Managing unique secrets across different stores becomes very difficult. Without a centralized strategy, it becomes chaos. Security, you couldn't just lift and shift from an old paradigm into this new security model. We need something that would integrate seamlessly into a Kubernetes native environment where pods, service accounts, and name spaces could all be accessed and used. Automation, we wanted to make sure that we could have an automation for rotation and injection with zero downtime. And finally, compliance. Adhering to our strict FedRAM compliance and controls, we needed a fine-grain access control as well as a clear audit trail. These challenges of sprawl, security, automation, and compliance form the foundation for our strategy. This foundation and strategy is important for delivering a strong security and compliance posture to support our most data sensitive customers. As mentioned, security is at the forefront in everything we build and deploy at Aquia, and this is no different for how we interact and leverage AWS Secrets Manager. This service has become a cornerstone in supporting our use case and exceeding expectations and meeting our customers' compliance needs. To enable our customers' industry verticals and their compliance requirements, our workloads are active in hundreds of AWS accounts spanning 12 active regions. All of these infrastructures continuously deploy workloads that require secure secrets to operate and perform their necessary functions. Covering over 300,000 unique secret paths, we average about 3 or more secret types per path, and we generate between 400,000 and 100,000 Kuberneti's external seek references per cluster. As sites scale in and out and our task system executes, this creates a high pod churn rate on our clusters that approach 500 and 1000 pod events daily. This results in hundreds of thousands of AWS Secret Manager API calls per hour. Let's dig into some of these metrics and see a little bit further. Looking into a portion of our hourly API usage, we see an average of about 45,000 pods being launched every 20 minutes. Stepping back and looking at this, it's almost 3.2 million ephemeral pod events every day. With this high of a pod churn rate. We need to depend on scalable services and caching patterns to reduce our ever growing API volume and ensure consistent, predictable behavior. This predictability is evident in our usage, showing a consistent cyclical 60,000 secret manager API calls per hour as seen from Cloud Watch. Having looked at our use case and some usage patterns, let's take a look at our platform's journey and how we partnered with AWS Secrets Manager for our secret storage needs over some other competing solutions. Looking back, our classic infrastructure was a lamp stack at its core. Had a customer control plane that was managing entity state. It was orchestrated through configuration like services like puppet, and we had a homegrown task system that configured and scaled each component independently. Deployments were through self-managed services like Gluster clusters for our file system and Precona clusters with tungsten for replication for MySQL databases. Each service was stood up independent on its own set of EC2 instances with secrets stored within the control plane that were injected in the customer's sites and configuration at runtime. As we began to modernize our stack and move to Kubernete's leveraging AWS EKS, we also shifted our thinking due to the availability of new managed service offerings like Aurora and EFS. This enabled us to focus more on our customer features and less on the underlying services and their maintenance. This was a huge win, but it came with a new set of challenges as services work amazingly out of the gate. But when you multi-tenant at our scale, the glue that AWS provides around connectivity, authentication, and authorization becomes difficult to leverage as they are. And this is where AWS Secrets manager stepped in and it brings everything together as a vital part of our ecosystem. Remember how I said that not all secrets are created equal? We recognize this behavioral difference and intentionally guard against it in our APIs, so each application's most sensitive data is stored in a purpose-built fashion. This ensures that when a user lists their application's custom environment variables, they're not also viewing the back end database credentials or other service connectivity information that the platform provides. To our customer, this is obfuscated away, and only the secret data that they have provided is accessible. The same goes for our platform. Just because it's a trusted platform doesn't mean that we should have full access to achieve all of the data. This guarantees that customers run within their environment and a least privileged access boundary is maintained, so environments only see what is intended to. So how do we make this a reality? By leveraging AWS Secrets Manager and some powerful open source integrations. We created a fronting API service that contains the key business logic managing these types of secrets mentioned, catalogs, what the secret is for and how best to group and protect them and controls the RBAC around each type. As an example, we don't want these services to be able to list or retrieve, and each token is scoped to a specific set of types, so customers can be validated and against the key string formatters, and custom rules can be provided like auto rotation or expiry for that type of secret. This ensures that our secrets are classified and filtered and security is grouped on understanding of that type and the use case of that specific secret. This enables the secure client behavior that we mentioned a minute ago, so the customers store for their third party APIs, their configuration and their environment variables is all at one layer. Our service to service communication is then all at a different level, and we're starting to see a rise of a third class which is actually a mix of both of those for AI agents which need a little bit of the user space and a little bit of the platform space. So having looked at this running API, let's consider the delivery side of things and how the platform behaves. Aqui appreciates AWS's commitment to the open source ecosystem. AWS Secrets manager has created a first class secret storage CSI driver. This assists with secrets delivery, uh, to the application and into Kubernetes and leverages a very similar aspect to what we use today. This is known as the external secrets operator. This came before the CSI driver but shares a lot of similarities in the patterns in their youth, both. Read from AWS secrets manager's robust APIs and inject into the runtime as a Kuberneti secret. This provides flexibility in the delivery of secrets and provides the runtime an option for injecting environment variables, templated config files, or flags that can go into the pod's runtime command, and we encourage anybody that's interested in using Kubernetes. On AWS uh to take a look at the secret store CSI driver or the external secrets operator to simplify their usage of Secrets manager. So to bring this all together, customers and their internal secrets can be created and provided to secrets through the product key service, which includes a type classification. This service acts as a first class consumer API and tags those secrets into their varying layers and saves them into Secrets Manager. The external secrets operator is able to pick up these secrets and store them into Kubernetes as external secrets object. Applications interact with these Kubernetes secrets, and the external secrets operator keeps these secrets and pods synchronized and up to date as things change in the environment. So, taking a step, what have we learned from this journey? There's really a need to focus on simple usage interaction patterns. Indirect access is a key to security. Customers' untrusted code is brought to us on a daily basis like AI agents, and you don't wanna grant them full open permissions. Isolating workloads and operating in the least privileged fashion is a must. Structure is critical. Clear naming conventions and hierarchy has to be defined and thought of up front to ensure the varying layers and the way that you pull the secrets, uh, can be unique, for each type, and a well organized structure is easier to manage, rotate, and audit. And for this, the key security and operational sanity can be maintained because you know where things will be. And at scale API usage is going to have an overhead and this impacts performance but also it's gonna have cost implications. So how do we solve this? Understanding usage patterns and implementing smart caching can drastically reduce the number of direct APA calls that are being made and can improve your performance overall and help lower your total cost. This journey highlighted an important reality. IM is a backbone of AWS security, but it has its limitations, and where IM fell short, AWS AWS Secrets manager fills this gap, uh, for interconnecting different AWS services, and we didn't see this as a replacement, but we saw this as a companion to work with IAM and help us solve our multi-tenant capabilities. Oh, going back. What's next? So looking forward we're really excited to have a collaborative partner like AWS Secrets Manager as we dive deeper into the possibilities of what an eugenic world looks like. Building from the ground up, we've established an AI gateway which acts as a central interface and sits in front of all their model invocations to providers like AWS Bedrock. This ensures we have a single observability and monitoring point for all our Agenic actions. We've standardized on a set of AI frameworks which has enabled teams to quickly create agents and deploy them in a secure fashion. We call this the Aquia factory, and it provides teams with a repeatable robust way to focus on functionality and quickly ship agentic capabilities from here leveraging these core infrastructure pillars, the AI gateway and the Aquia agent factory, we have the ability to interject. Secure information stored in AWS Secret Manager for agents to interact with, enabling us quickly and to securely adapt as new AI capabilities, functionality, and use cases arise. Our close knit partnership with AWS Secrets Manager has paid off immensely, allowing focus and delivery of innovative solutions by integrating Secrets Manager so deeply, we've streamlined our infrastructure and reduced our operational maintenance and. Overhead that is translated directly into real performance gains and cost savings. Most importantly, it's also made a secure and resilient platform for our customers and to us this is much more than a vendor relationship. AW Secrets manager. And the team has been a true collaborative partner. Thank you. Thank you. Uh, uh, thank you. Um, we have been excited to work with Aquia as well, and, um, in their journey where I think I've been part of Sequence Manager for about 6 years now, and I think I've been with Aquia for most of it and talking through solutions, talking through paths that we can, uh, we can help solve for Acquia as well as for other customers. So, um, I'll end up, end with a few recent launches that we had for Secrets Manager. You heard from Jake, um, about use of what we call the secret store CSI provider. We launched that open source capability a few years ago, but if you have used it, it does take a bit of doing. There's Elmchas to build this. There's manual work to get done. So when we started looking at how can we make it easy for customers to use these solutions, especially when they use AWS services like AWS EKS, so uh if you've not heard EKS add-on is an interesting functionality you can actually now. Launched the AWS Secrets Mager CSI provider as part of EKS add-on and essentially automatically installs configures, so all of the heavy lifting that we call customers had to do for CSI provider um that goes away. So, um, I talked a bunch of about it before the slide but essentially it is a simple one click installation we just launched it last week. To be honest, uh, and as customers start to use, uh, as similar to Aquia, uh, more and more container by, uh, deployments, right, like he was talking about hundreds of thousands of parts, and essentially everyone's moving towards more containerized development actually, to be honest, Amazon EKS is the most. Used service from a consumption point of view, from a compute point of view and so this now enables customers to use. Secrets manager behind the scenes while delivering the secrets at scale. Through their community clusters, so I was pretty exciting about the launch this new thing we just launched a few days ago, uh, one of the things Jake pointed out and we started this journey about. Let's say 3 years ago or so, 3-4 years ago, is we wanna create a situation where when you have a cloud, an AWS solution, or when you run your workloads in AWS, the security or the behind the scenes, your secret storage by default should be secrets manager so. We used to call it eliminating any human visible secrets within AWS, so we integrated with all AWS services that manage customer secrets. To essentially take away any of the Decision making the customers had to do, where do I store the cigarettes? How do I make sure it's secure? How do I make sure it's rotated? So the point about hey one click rotation, for example, for RDS admin secrets, all of that came from that journey. So we. Integrate with 55+ services that manage customer secrets behind the scene and enable rotation as a one click functionality so taking away another thing what we call the custom lambda function that we created so we wanna take that further. And Think about it from an external or non-AWS secret point of view, so we launched managed external secrets last week. Which essentially enables any third party secrets. So for example, if a customer has a Salesforce secret. Before this was launched, what you would have to do is create the secret and secrets manager and then create a custom lambda function for your Salesforce secret to get rotated on a regular cadence to meet with your compliance expectations. What now you can do with this launch is you can create a secrets, uh, sorry, a sales force secrets and secrets manager and with a one click button behind the scene the secret gets rotated at the source as well as in secrets manager. So essentially taking away any of that, um, kind of heavy lifting and also the big concern for customers was hey if I rotate my secret. In secrets manager but doesn't get rotated at the source then we have an availability risks. So all of those uh kind of concerns, especially related to non AWS secrets which before this launch were not solved this launch solves that, uh, so we're really excited about it. We, we are going to do a lightning talk with another customer as well, uh, in the next few days. So you should probably come see that as well. So, um, this talks a little bit about the detail about how you do it. So maybe I'll walk you through the idea about uh one specific customer. So for example there's an IS ISV that you work with. That's for example take Salesforce. You can work together and determine a specific format that the secret gets stored into Secrets Manager. So this journey kind of talks through, hey, now that a format is created, you can now store that secrets in Secrets Manager. Right? Using that workflow. Once you have that in secre manager, what you get from the partner is a rotation code or a module or a function that we behind the scenes execute when you set up the rotations as a configuration within acre margin. Now one of the things that to note is you can go into Secrets manager and update the rotation schedule. You can make it 90 days, 30 days, whatever. Uh, your organizational policies adhere, uh, ask you to adhere to, and we will take action as per those configurations. So, but you would not have to build any custom lambda function that you would have to manage. So this kind of work flow talks about, hey, you're the exact same thing you store the secret and secrets manager, but it is now a different type of secret called managed external secret and for this specific partner. And it'll just rotate the secret because earlier you would have to create all those lambda functions for each of that partner. So for salesforce or X Y Z A B C, every other partner. So you would have hundreds of lambda functions. Now I'd have a single way of managing and rotating the sequences. So I'll end with key takeaways. Uh, AW Secrets manager, as I say, continues, uh, to better itself as we listen to our customers to enable the new work flows, enable easy access, enable caching, enable cost optimizations, enable integration with third parties as well as AWS services, and, and ensures that it is the. It meets all customer expectations from a secret management life cycle perspective. Um, and of course Aquia close collaboration with AWS, not just AWS Secrets Manager, and I think it's a whole journey, uh, and we talked about Secrets manager here, but I'm sure there are other discussions that we have, uh, with Acquia and other AWS services as well. And then I think the last takeaway I, I will ask you to take away from this is the third party or the manage rotation now extended for non-AWS secrets because we have done a fairly good job I would say, uh, for AWS secrets. I want to extend that to third party secrets as well so. Thank you. Uh,