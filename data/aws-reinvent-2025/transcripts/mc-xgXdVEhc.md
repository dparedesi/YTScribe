---
video_id: mc-xgXdVEhc
video_url: https://www.youtube.com/watch?v=mc-xgXdVEhc
is_generated: False
is_translatable: True
---

Cool. Welcome to Reinvent. I, we're bright and early or early enough on a, on a Monday, so very flat that you all showed up here with us, uh, on this Monday morning. So thank you. Yeah, so I'm Sean Kendall. I am a principal solution architect at AWS, uh, specialize in service and generative AI. Been with AWS for just over 6 years, uh, working out of Calgary, Alberta in Canada, um, and, and, uh, thanks Brian. Wanna introduce yourself? Yeah, so my name is Brian Zambrano. Uh, I've also been around for a bit. This is gonna, it's gonna be about almost 7 years, um, at AWBS. So I've, I was a solutions architect like Sean for many years, uh, developer background, and I currently work in. In a group called the Generative AI Innovation Center, has anyone heard about us, Gen AI Innovation Center? No one? Oh my God, OK, you need to, uh, because what we do right now is we are building generative AI, uh, call them proof of concepts, more like MVPs, frankly, for customers for free. So if you have an AWS account team and have some idea of how G AI could help you and your organization, you should definitely talk to your account team, uh, because that's what we do again, it's, it's a pretty awesome deal for, for all you in the audience, the customers, um, but yeah, so I'm building GAI solutions right now in the innovation Center. Awesome, thanks. Alright, so today, um, we're gonna be talking about accelerating building your service applications with Quiro and MCP servers. Um, now, show of hands here, who's heard of Ciro in the room? Quite a few people. OK, no, that's pretty good. Who has used Quiro? OK, less hands, um, so yeah, we're gonna be focusing on that technology. Q is just our, our gentic AI that enables you to build a lot faster, um, and then of course we are gonna be focusing on Servius here today, another show of hands, who's building Servius apps here in the room today? Cool. A lot of, a lot of show hands. So that's good because we're not gonna be focusing too much on the servalist side. Uh, we are gonna be building erless apps and showing you how to build those a little bit better, um, using Quiro and faster using Quiro, um, but yeah, we're not gonna be focusing too much on those er list patterns and whatnot. Um, now what you're gonna get out of here today is we're gonna go over a developer tool overview first and then a target architecture on a tic tac toe game. That's what we're gonna be building here in this code talk. Uh, we've already built the front end of the Tic Tac toe game because we figured we don't want Kiiro to sit there building too much stuff within this short period of time. Uh, so we've built that, we've deployed it. There's an open API spec that's available on, on the, uh, the UI just so that, you know, to kind of help the back end and, and Quiro figure out how to build it a little bit better, uh, faster. Um, I'm gonna show you some prompt engineering. So what's the prompt that I'm gonna use to actually build the back end, uh, so that prompt's gonna be provided to Quiro so we can go ahead and do all the things with AI. Um, and then after I show you that, then we're gonna get into the coding. So you're gonna see myself. I'm gonna be using the Quiro CLI, which I'll tell you more about here in a bit, um, and within that Quiro CLI you'll see how I can build that back end, and then I'll hand it over to Brian who's gonna use the IDE version of Quiro, and so you can kind of see both flavors of Quiro. So for the developer tool overview, um, the first thing we're gonna be using here today is Amazon Quiro, and with an Amazon Quiro we have the Amazon Quiro CLI. So now this is my preference when I'm building. Um, there's no real right or wrong here, but the Quiro CLI allows me to open up a terminal and type in my prompt. I can actually just chat to if I really want to, uh, but it allows me to be extremely hands off. I give it a prompt. I hit enter, and I just let it go, and it doesn't have to bother me at all. I don't have to use a UI. Uh, that's, that's what I prefer. Um, then the other way of doing it is the Quiro IDE. So if you prefer a nice IDE experience, then this is another option for you. We're also going to be talking about MCP servers, um. Another show of hands, who here has heard of MCP? Most of the group that's really good. Who's using MCP today? Wow, OK, who could explain what an MCP server is to their friends? Oh, I got you on that one. OK, we got one. OK, that's great. That's great. So we're gonna get into that, yeah. What's that? Like they're 5, exactly they're 5. That's good. Um, and I'm gonna be showing you some of the serverless, um, MCP servers that we have within AWS labs today. So after the session, if you want to go use these on your own, there's a, a full library of MCP servers, basically tools you can use to help with your development. So the first thing we're gonna focus on here is the Amazon Quiro CLI. So what you're seeing up on the screen right now, that, that's basically what it looks like if you're using the CLI, you'll type in Quiro-CLI, uh, and this is how it opens. So you get this nice little graphic. Um, within here, you can basically just start typing prompts and it'll respond within the terminal. The other way of using it is the Cro IDE and also hand it over to Brian here so we can kind of talk through how this one works, yeah. And before I get into this, just a couple of things we forgot to mention. One, this should be interactive. So as we're coding, as we're talking about this, feel free to raise your hand, shout out a question, and we will do our best to answer it. So we have our first one, yes. So here's something that took me by surprise because when I reserved this session was called uh building serverless up with Amazon Q and MCP server. So Quiro has replaced Amazon Que in this session. Is the same going to happen to the service? So that, so that was my second point. So that was step, step one is ask me questions. Two is you segued perfectly into it. Who here has heard about Amazon Q? Most people, OK, so Q as a, as a brand we're is moving to Quiro now. So what Sean's gonna be talking about, what I'm gonna be talking about, the, the CLI is went from QCLI to Quiro CLI. They're basically from a functional standpoint it's the same thing, um, do you have anything else to add on that one? Well, actually, so there, there's, there's a progression here. So has anyone here used code whisper? OK, a lot, a few less people. All right, so it actually started as Code whisperer, which was like the agentic AI that then turned into Amazon Que Developer, um, and now that has turned into Quiro. So we just keep renaming things. That's all it is, um, whereas, you know, you were using Q yesterday on the, on the CLI, for example, you would type Q hit enter, which I loved, by the way. Now you type Quiro CLI, which is a little more annoying, but. Um, is there, you, you have a follow up question? Yeah, I have a follow up since this session is gonna have a uh. A key to ID card. So, uh, does all the features and practices that you are gonna show on hero ID applicable to the Amazon Q, uh, for instance, extension on visual code. Those are different things, so the, you're, you're asking about the VS code plug-in. Yeah, so they're gonna be they're gonna be different. I'll try as we get into this, I think it should become obvious or more obvious, and I'll try to talk through it a little bit, um, yeah. I have a question regarding, uh, how we. Because in Kiro, uh, some time ago, it went from regular payment option into a separate, you know, subscription. And now when the Q has been grounded into Kiro CLI, I wonder whether the same. So I think for yeah for let's hold that for after the talk. So we wanna get into the the technical parts of this and then for any questions we'll be outside and we can do our best to answer things like that, um, but let me just go through this real quick. So Sean talked about Kiro CLI. So this is the IDE. So it, it, it, it, this is like, you know, other if you've used things like cursor. Um, it's a, it's a fork of VS code, um, and so it's gonna look very similar if you're using VS code. So a couple of things here to call out on the left there's a little ghost, the, the hero icon. Um, and when you click on that, other things start showing up. So at the top there's something called specs. Uh, I'm not gonna talk about that today unless we have extra time, but if you've heard about spec driven development, that is something that is from my knowledge is unique to Quiro. Um, it's pretty interesting. And then there are the section called, um, agent steering docks. I will talk about that. And then finally the MCP server configuration down there at the bottom. And on the right is where you have your interface to talk with your, your agents, your coding assistants, and again, here again, this is, this is unique to Kiro, at least as far as I'm aware, um, you can do a what's called a vibe session which is just what you're used to chat with your, your, your agent and tell it to do something and then on the right there's spec driven, um, chat, which is a little bit different, which we won't get into. Um, so let's just get in at a, this is a very high level about what is an MCP server. So what it stands for model context, uh, protocol, and so if you think about you as developers, you're gonna go and interact with an agent to go and do something, right? Like build me a react UI, go and update my service application to do this, whatever. So you're interacting with some agent. And the agent has, there's a model behind the scenes, it's gonna have some internal knowledge based on whenever it was trained, right? New things pop up. There are other pieces of data that could be really useful for your agent to know about, but it doesn't know about, or you might want to enable it to actually perform actions on your behalf. And so you do that by integrating with other systems. So here as an example, you could be integrating with a third party API or your own company's internal API, right? Like, we were talking, uh, this morning. Shawn's customer was having, uh, building a POC to actually have an agent place an order for their customer, um, for their customer, his customer's customers, and so there are all these things and information and and features, um, that you would like your agent to be aware of and actually have access to and so how do you do that? And the answer for that is now these MCP servers and so think about MCPs servers as a common interface. Two back end systems to either get new knowledge to perform actions, but it's a standard interface. It's a, it's a, it's a protocol, um, and so you could literally build an MTP server like is shown on the screen to do these things right, interact with my third party API. Go and figure out, uh, go and read the business logic of my, my internal application or reach into the, to a database and go read information or write information so you could do that, um, but I think what we're seeing over and over now is that there are purpose-built MT MTP servers. That have specific duties that do one thing or a set of things that are all wrapped around a given job. So for example, there might be a database MTP server that is going to be running database queries for you, um, and you can see on and on how this goes. But the idea is the overall idea here is, you know, as you leave, think about this as MCP servers are a way to actually next slide. Um, so MCP servers and connections are a way to give the models access to, to new up to-date information, and it's something that information that they don't know about inherently. So that's, that's the big thing there. OK, you wanna take this one, John. So some examples, yeah, so some examples of MC MCP servers that you might see, um, so one and, and one that we're gonna be using here today within the actual coding session is up to-date AWS documentation. So of course the models you're using when you are vibe coding and you're building these solutions through AI, they understand AWS. They understand the documentation, but only up to a specific date of when that training ended. So now adding in the AWS documentation MCP server, it's gonna be able to reference the latest documentation, uh for example, all the new features that are coming out this week, uh, you'll be able to build those as they get released and as they get published out onto the documentation. So that's another one of the good use cases for these, uh, MCP servers and a good example of what we use today. Now if you're developing production apps that are now gonna connect to MCP servers, um, up to-date stock prices would be another good example, weather data, anything to do with any API integrations, right? So now you can just have an MCP server, uh, execute those integrations for you through AI, um, and then basically any of your company's internal API or internal documentation as well. Um, so really any, any types of data lookup that you need in real time without using the model's training data is a really good way to see that. Um, now today within the coding session, here's some of the MCP servers we're gonna be using. So the first one is the AWS Servili MCP server. This MCP server deals with SAM integration so it understands SAM and it understands all the commands of how to use SAM, and it'll, it'll, it'll actually execute those for you within your own, uh, environment. It can do local testing and it gives you erless guidance. So for any erless app, this is a really good one to add into your coding agent. Then we have the AWS CDK MCP server, which is a personal pref personal preference of mine, and that's because I like to build everything within, uh, CDK. I like to write all my own code in Python, uh, and so this will allow it to now write my applications within that Python code in CDK. Uh, one of the things I also get out of this is when you're using the AWS CDK MCP server, it will actually add in a library called CDK Ng. And within CDK NG it makes sure that whatever I'm building is secure. Uh, it'll actually fail a build if it's not secure. And one thing that you, you might find your agent doing is it might say, well, allurless apps must have WAF enabled, right? Um, but then it might say, well, I'm not going to add WAF. You're just building a demo, so it'll put an exception in there, and then you can view those exceptions. And if you really wanted it to have WAF, you can remove the exception manually. And then tell the uh the agent say well no please add WAF back into it and it'll go and add that uh to make sure it's not an exception. So I really like that about the CDK MCP server because it does make it more secure. I have seen a lot of people build very insecure things using AI. So that's one thing to, to, to really watch out for, um. It will also integrate power tools. So if any of you are building things with lambda today and you're using the, the power tools library, it has all knowledgeable power tools. So we'll be able to add that in there as well to make your things like your observability a little bit better and um all the different patterns that come with the uh the power tools. Then we have the AWS core MCP server. I would say this is a really good one to have pretty much all the time. It has prompt understanding inside of it. So if you're not the best at prompt engineering yet, um, and, and I would say like when I first started, you know, you don't really know how to create a prompt. You just kind of talk to the thing and hopefully it's good and over time I got a lot better. Well, the prompt understanding will take your input and it'll turn into something that's a little bit better for building software on AWS so it is tailored towards that. Um, so that's what comes with the AWS core MCP server, but as well it, it has a router for other MCP servers. Um, I don't personally use it because I like to be very specific on the MCP servers I use, but there's an environment variable you can pass in to the AWS core MCP server, uh, for, for a persona, so I can say I'm a developer persona or an architect, and for those personas it'll add a set of other MCP servers with it. So if you don't know which ones to use, that's another good way to get started. The AWS documentation MCP server, that's what I was referring to before. It has basically access to all up to-date information on the AWS services, best practices, limits, APIs, all that kind of stuff. And then finally a non-AWS MCP server I'm gonna be using today and this is the MCP server fetch which is an anthropic MCP server basically it just gives you the ability to reach out to the Internet and and load a page. So within our Tic Tac Toe application what we'll be building today, the front end has an open API spec. Attached to it that you can actually visualize within the UI and so I'm going to tell my prompts to basically go and pull that MC that pull that open API spec and make a back end that matches it, uh, so that's how I'm gonna be using the fetch MCP server today. Any questions before we, uh, go forward on here? Yeah, uh, you might cover this in a second. Uh, when you're using Kro CLI, do these things you just already have them, or you have to opt in? Yeah, so, with within actually both experiences, so Kiro Kiro CL or the, the Quiro IDE, I believe comes prepackaged with fetch. Is that correct? I think fetch is in there. You have to enable it. It's disabled. It's disabled, so you have to enable it. If you create a brand new project in Quiro, um, that there'll be one MCP server there that's disabled, which is Fetch, and so you can go in and you can remove it completely. You can enable it globally. You can do whatever you want. Yeah, so then, yeah, everything else basically you have to add it, and so there's a website I'm gonna show you what it looks like. It's a, it's a GitHub page that we maintain all of our MCP servers on, uh, which of course you can use the all the AWS ones, uh, but you can use any MCP server from anywhere. Like if you purchase some SAS software, a lot of SAS solutions are now coming out with their own MCP servers. You just have to download whatever definition they give you and put it into the IDE. OK, so the target architecture we're looking for today. Is something like this, right? So this is and just full transparency, we built the app. Um, I, I actually use Quiro to build the app, and then I told it to generate a diagram because there is a diagram MCP server as well which I can show you later if you, if you want, and this is the diagram it came up with. So first it built the code, it deployed the code, and then it built this diagram, and so today I mean like I'm not actually gonna feed this diagram. Into the prompt I could, but I'm not going to. I'm gonna let it kind of figure out whatever it wants to do by itself. If I really want to stick to something like this, then I would actually give this, uh, to the agents, and I would say, you know, follow this image, see how I want the architecture, and build this exact architecture, and it would just give it a little more guidance to follow exactly what this is. Uh, now the one thing that you won't see us building today is the, the left hand side of this, right? So the cloud front with the urgent access control with the S3 bucket, that's just hosting the website. So I want to show that on the diagram, but everything on the right hand side is, uh, what we'll, we'll be building here today. And just one quick shout out to the serverless part of this. Uh, good luck doing this with Kubernetes in 45 minutes, right? Honestly, and so, you know, kind of our pitch here is that Servius you can go really fast. Servius with AI tooling and MCP servers you can go really, really, really fast, so. It's crazy how fast Sean and I were able to, to do this. So we were even talking before this about what if we finish early, what are we gonna do next, because we can go so fast with this. So just again a shout out to the serveless parts, uh, you know, of this talk. OK, prompt engineering. So this is the prompt I'm gonna be feeding in to the, at least the Quiro CLI piece of this. Uh, it's probably gonna be different from the prompt that Brian's gonna use on the Quiro IDE. Now again, this is from me working for months. It's almost a lifetime in, in ages of AI, um, in learning prompt engineering. So the first thing I tell it is build and deploy a workingerless back end for the tic tac toe tic tac toe game hosted at. And then a URL. So this is a deployed URL that we already have that I'm gonna be plugging in here, um, now you'll notice I say build and deploy, and I, and I actually put that in here because I wanted to build all the code and deploy it without coming back to me because usually what I do, and I don't know if my wife likes this or not, but before bed I think of an idea. I write a prompt, I hit go, and then I go to bed and it goes and builds my thing overnight, then I wake up with a fully built application, um, so that's why I'm always saying build and deploy. The next piece of this is I'm actually guiding it to use that Fetch MCP server to view the website and then open the API spec and then I give it the direct URL with the URI to the open API spec, right? So I'm giving it a little more guidance here. I'm even guiding it to use the, the specific MCP server so it doesn't have to guess that as well. I'm now telling it to build the code deploy um to my default AWS account. Now I put this in there because I've learned that if I don't tell it that it says, well, I don't know where to deploy it and I, I do have a AWS account preconfigured on my laptop, so I wanna make sure that it understands that it's allowed to use that. And if I don't put that in there, I find it just doesn't do it. It'll build everything, it'll come back to me and say, OK. What do you wanna do? So this stops it from doing that. Um, I also tell it to test the API because of course when this thing's building I'm probably sleeping, so I wanted to make sure it deploys and it comes back and it runs all the tests to make sure what whatever it did deploy is working and it's working as expected. On this next section that you see here, uh, I'm just gonna call it a few things. Handle the courses headers. Now I find it with this AI stuff, it never handles cos headers. It's probably the biggest issue I always see coming back where it can't actually communicate with my back end because the headers were not added correctly, uh, and in fact, I, I tested this a few times this morning and even though I put this in there every once in a while it still doesn't do it. So that is some guidance that, that, uh, I do give it and I also always tell it to handle taking so I take all my projects with a project name. Um, so you see there I see project equals, and then it's gonna come up with a project name. I'm not, I'm not even gonna give it a project name. It'll figure that out by itself. And then auto delete false, and this is just kind of a internal AWS thing on all of our internal AWS accounts as employees. We have a script that runs every night and deletes all of our resources if we don't take it with this value, um, so I do that so everything doesn't get, uh, deleted overnight. And then this final paragraph, this is something I don't actually usually include in a lot of my prompts. However, I've built this thing so many times I've identified certain places where it could potentially fail, and I wanna make sure it doesn't fail. So I add these few items in here just to make sure that it really understands, um, a few things that it, it, it continuously fails on. And so you'll find as you're building in the future your applications, if there's certain things that the AI is just not able to do, you'll probably come up with some of these items yourself, and as you're building apps, you'll just kind of natively put those in. At the bottom of your prompt. Any questions? OK. So let's get to coding. So let me switch over to. This one here Of course it didn't load the right screen, but that's OK. I can fix that. OK, so what you're seeing here, this is the tic tac toe game that we built, right? So very simple. Right now you can't really see anything on the screen. There's no tic tac toe board because nothing's configured. But I actually do have a previously configured game. Um, a back end that I have not yet deleted. So let me push this in here to show you what it, what should work, right? So this one, if I put this URL in here, this is the URL to the back end deployed to API gateway, um, driven by lambda functions. So when I add that in here. I can register a player. And there you go, so it, it works. There's no errors on here. I can start a new game. And then I can start playing and I'll let the computer win this time. There you go so that's basically the entire thing that it does now that back end was built through AI now I'm gonna show you how I built that through AI, um, and let's clear this so that when we get our new game it's just nice and empty in here. OK, so here is my, uh, basically the CLI, and the first thing I'm gonna do is I'm, I wanna add some agents into here. So those MCP servers, I, I already have a pre-built agent. I'll show you kind of how I built that. Once you install Quiro, you're gonna find what you have is you have a file located inside of, so let's open this up in Quiro. So Quiro, it's in your .kiro. So it's in your home directory.kiro, there's a directory that'll be placed inside of there. And then there's an agent's subdirectory. Um, and then within that subdirectorory they're gonna give you a sample JSON file and that's like a, a, a default agent that you can build yourself. Um, I've created one here called Reinvent, so I'm gonna open that one here, um, just so you can kind of see how I built it. A lot of this stuff will come out of the box, so the, the schema, for example, that'll already be there. You're gonna wanna give it a name of something, um, so whenever you wanna call this agent, this coding agent, that's how you're gonna refer to it by. So right now whenever I start my. My hero CLI, I'll always say that, uh, minus minus agent is reinvent. I give it a description. This is really just for me. So this is basically saying that this agent is able to build AWS Servius back ends, um, using best practices, and then I give it a prompt, and the prompt is a system prompt. So just imagine, you know, every time you wanna build something, this system prompt is gonna be there to guide the, uh, the AI to build in a certain way. So maybe make it like one font bigger, one font bigger here, let me blow that up there. Is that better? I'll get rid of this, uh, yeah. Yeah, it's probably better, yeah. That you guys have There is, there is a, so for most of this config, as soon as you install Quiro, you're gonna get that template file. So I would say just like take that template file, just keep copying and pasting it for every agent you want. I think right now I have about like 10 agents. Like I have one that uses the AWS Canvas MCP server for like generating images for me and stuff like that. I split my agents like that, um, so I would just say like, yeah, once you install a Quiro, just copy that example multiple times and then just keep making new agents based off of that. Um, there is also, I don't know this off the top of my head, but there is a kiro CLI command that is, it, it can generate the agent for you, and then it'll generate this whole spec, um, so once you're in, sorry, once you're in QOCLI, you can also run that, the, the, the generate agent, uh, command. Um, and I will show you, so there is a repo here. So you can see here like I, I do have, uh, different MCP servers. So I have the core MCP server that we talked about. I have the Fetch MCP server, the AWS documentation MCP server, and, and so far that's it. And now you, you already know that I want to add a few more in here based on that list I was showing you. Uh, so I'm gonna add those in. Um, there's, there's a few other things in here. So like there's, there's things like, uh, like allowed tools, right? This allowed tools list. Uh, one thing that Kiro is gonna do is it's always gonna come back if it wants to run a command, and it's gonna say, do you want to run this command? Um, and I would say if you're doing anything in a sensitive environment, keep that on so that every time something comes back to you to make sure it's not doing like an RM minus RF on a directory you wanna keep, uh, you'll have to actually allow that. Um, everything I work on is kind of demo purposes, so I always start QOCLI with a minus 8 flag, which means just like allow everything and never ask me. Um, I would just say, you know, be a little wary on that one. If you're doing anything that could potentially damage your AWS account or your machine, you probably want that permission placed in there. Um, and then there's tool settings. So when you start adding MCP servers and tools, um, when you read the documentation for those MCP servers, a lot of times it'll come back and say like within documentation it'll say, well, you can have, you know, time out. So there's, there's a, there's a bash timeout, for example, on execute Bash, which is a tool. I can say, well, you have a time out of 300 seconds. So that's one thing that I've added into mine. So that's where you would put it, uh, within here. Now I'll show you how to add a different MCP server. So now of course this is more of the uh the the CLI way which I think is actually similar anyways to the IDE way. But there's an uh a GitHub, AWS Labs GitHub. Um, I'm gonna show you guys all a QR code at the end where you can link to this, but basically this has all of the AWS MCP servers and of course there are thousands of MCP servers out on the internet. These are just the ones that AWS has curated. Um, so in here I'm gonna search for Servius. And I have this AWS Servius MCP server. Once I come in here, I can um quickly add click these buttons. So if I wanna add it to cursor or VS code, I can do that from here now because I'm doing it on the CLI way, I'm simply gonna copy the JSON from in here, come back into my IDE, scroll up to my MCP server list and paste it. Um, and because I use a default configured profile, I'm just gonna delete this environment stuff because that's where, where I can add a specific profile or region if I need that and if I get rid of that. It'll use my default one. So the next thing I'm gonna do. Is coming here, um, so right now I'm sitting within a directory on my machine that has nothing inside of it. So if I show you here it's all I have is a prompt. text, and that's just so I can easily access that prompt I showed you. So there's nothing else in here and that this is the directory where I'm gonna start building everything, uh, so I'm gonna start with Quiro CLI. Uh, now I, I use a command chat, which means I can use additional flags. So this is giving me the ability to use this minus a flag which says just do anything, never ask me for permissions, um, and that's because I'm eventually gonna hand this off to Brian so my computer can keep working and then his can start building on the IDE, um, and then for the. Oh, bigger, yeah. Thanks for that. Alright, and then minus minus agent and then I type in reinvent that is the name of that agent that I created within that JSON file. Now, as soon as I open this here, you're gonna see it's gonna load my different MCP servers. And it's validate. I did have 4 in there. So the core MCP server. Servius, fetch and documentation. So yeah, that is correct. Um, now within here there are a whole bunch of commands you can run. So if you type slash, um, you can see there's, there's all these different commands. So for one, if you want to manage your agents, if you do have multiple agents, you can do the slash agent command which then has that generation feature inside of it, um. But the other thing you can do is just start typing your prompt, right? So if I open up my prompt here, which I have saved over here and you can see I've prefilled in the website address to our Tic tac toe game. I'm simply just going to push this in here. And that's really it. Now I am using some experimental features within the Kiro CLI. So if you ever type slash experiment, you'll see there's about 6 different features in there. One of them is a to do list, and you're gonna notice after it starts loading, uh, like right now it's actually fetching out to the Internet, loading that website, saying now I understand the requirements, um, and now I created that to do list. So that's actually an experimental feature. So if you wanna use that, I, I find it's really good because it gives it more of that chain of thought process to build an application. Uh, and I, I actually personally enable all experimental features. There's things like checkpoints in there, so it's kind of like almost a, a, a get commit, but it's local to Quiro. Um, anyway, so we're gonna let this build. It's gonna go off and do everything that it needs to do. Now we'll switch over here to Brian so he can show you how to build it within the IDE. Is there any questions while we're just switching, uh, laptops here? Is that persistent outside of the workings and made progress 3 out of. For the day. my work. OK, so, so, so the question is, is, is it persistent? So it's actually, it's actually using a git repository, uh, behind the scenes. That's what the tool is actually doing. So it is persistent. So if you were to exit out of Quiro and then come back in, and whenever, whenever you come into the Quiro CLI a second time after leaving, you use a minus resume flag, and then that resumes back from where it ended. And then it'll pick up on those checkpoints, um, and also the, the conversations are stored in a directory within that doc hero, uh, in, in your home directory, uh, so your conversation history is all stored within there. So every time you type minus minus resume in a folder that you're currently in, it loads your conversation from there. So everything is persistent in there, uh, now I'll pass it over to Brian here, OK, so here we go, um, so this is the Kira IDE. So real, real quick tour, um, just like VS code or any other, you know, IDEs stuff up navigation on the left here are my, uh, my files, my file system, um, and then in the upper right click on that and that is our chat interface to our agents. Um, and like I said, at the beginning over here on the left there's this kiro icon. If you click on that, and is this that, is that large enough? Can you guys see this OK? Yep, OK, um, so there's these spec things on top which we will, we'll get into if we have time. Agent hooks, we also won't cover this, but I can talk to that. And then agent steering docs, which I'll show you how to create something there, and then the MCP servers down here on the left. So you can see I already have 4 of these that are, um, set up and so if I click on this icon that it says open MCP config, um, there are 2 parts to this. One is the user config, so this is. Uh, laptop-wide, um, so like Sean said, the documentation MTP server enable that one globally. I mean there's no really no reason to have that per project, so you can see in here, uh, the second one, well, the first, there's two of them, there's Knowledge MTP and the, uh, AIS documentation MTP server. So that's under my user configuration. So whenever I'm logged into my laptop, those two things are gonna be enabled, um, all the time. And then the workplace config and actually I, I changed directories so that one's empty so there's nothing, so the things that you see on the left now are on my laptop no matter what project I'm working on um so to enable and I'll just do it real quick, uh AW AWS MCP so I'll do just what Sean did I make this bigger serverless. That guy And then we're gonna copy this. And then all I'm doing is I'm pasting it in here and this is, this is the workspace specific configuration. So this will only be enabled for this one workspace question for, so for the workspace they go, is this gonna live within the rebuild so my team of developers all get this. Is this a per machine configuration that they have to do for them? Yeah, so you can see right in here, um, so this is in a directory, a dotkiro directory in this, uh, in this project. So as long as you commit that and as long as everyone's using Quiro. Yeah. And now here I need to put in. This, and this is just the name of my. My profile I'm gonna save that, and as I save that, now you'll see it's spinning over here on the left, and assuming I got the typing correct, that should be enabled next. OK, so while that's going, I'm gonna talk about, yeah, so that one's working now. So I'm gonna talk about real quick about steering docks. So, um. So Sean has his set up for the the Quiro CLI. So a steering dock is something that the agent will reference back to whenever it's given a task, and you can tell it to look at these steering docks based on file extension. And frankly I don't know all the different ways to configure it, um, in terms of, you know, telling the agent when to look at it, but I'm gonna create a couple of steering docs that informs the agent how to build this application. So these are really tips and tricks to help guide the agent when it's doing some work. And uh I'm gonna do that by clicking this uh this literally changed I think last week so this is a little bit new to me um I'm gonna create a Syrian document from scratch and it it says here it only applies within this specific workspace so that's what I want, um, and I'm just gonna call this AWS SAM. And so you can see here it says, OK, I'm gonna include this always and there's a link to which I haven't read but you guys should definitely read this, um, but these are some rules about what to do, um, again while the agent is working so I'm gonna delete this stuff real quick and I have something on my clipboard. Which is is this one not your that credit card number on there that's definitely that's that's the one where you hit like star on allow all that was the credit card uh I let me go and find it real quick sorry. Yeah, AWS Sam. That's what I want. You copy. Whoops. OK, OK, So if you look here, this is, this is pretty, this is pretty terse. There's not much here, such as says, hey, this is a project built with Python 313 and ADBS SAM. Um, here's some instructions to test the build, run this, to deploy it, run this. If there are any code changes, you can run SAM sync. So it's really sparse. There's not a lot here. The code here is literally all I did was I ran um Abu Sam Eit. So I said Eit, it's a Hello world application, it does nothing other than print out Hello world, but it does deploy. But that's all I did. I mean, it took me 2 minutes. Um, so what I'm gonna do now, and this is, I, I think a nice feature of the, of the IDE is you'll notice there's this refine button in the upper right. So I'm gonna click that, and what that's gonna do is, it's gonna ask the agent, take this, take this prompt here, the steering document is also is also gonna look at the code that I have in the project and it's going to refine or improve my steering document, um, and so that's what it's going through now. So there we go. So now we are, we are done, um. But if you look at it now, it's much more verbose, uh, it's a little bit more thorough, and, uh, it's, it's more complete, um, so again I, I mean I'll just pick some random stuff. So here it's saying like what to do with sync, uh, the project structure, so it looked at the file system, so it realizes the template is the template for the SAM app. The source directory contains all the function code, great, um, and there's some other things in here oftentimes. And what I have found is that Oftentimes you with a small project like this, a lot of the work is involved is telling it what not to do. So if you don't tell it, uh, skip the unit test, skip the integration test, don't worry about that. Oftentimes these agents will start creating a lot of things that you don't want or need. So that's just one thing that I've noticed over time, um, so be aware of that. Uh, so I created one, so now in the steering documents we have one which is AWS SAM. I'm gonna, uh, copy another one which is the product. PB copy. All right, so I'm gonna add another one, I'm gonna call, say this product. And it's that. OK. So same thing, there's not a lot here, but these are just some tips. Um, Sean mentioned cores, right? We, we saw that that the agents didn't get that right. So there's a a specific instruction on there to, to handle it. Um, I've got something specific for lambda power tools, and I say I want you to use lambda power tools, but install it as a layer. So I will hit refine and then answer your question. Yeah. Will this feature uh. Way to From the agent to not, uh, for instance, read environment variables like from secret credentials or. Is it a better way on keto to Premer. So the question is, are steering documents a good way to. Have the agent not read environment variables or not, yeah, I would say yes. I mean these are the steering documents are a way to guide the agent to behave how you want it to behave. So if you don't want it to do something that's absolutely what you, what I would recommend putting in in here. I would assume that all these instructions, well, they go on each request that we make to the underlying model and hence they consume tokens tokens. Yep, yeah, and if you look here, here it says inclusion always, right? So in this case, yeah, every, and you'll see, let me start this and then I'll, I'll move on to the next question. So, um, just to, to bring us back, so I have two, I've got my MCP servers configured. I've got two, agent steering, uh, documents, so that's great. I'm gonna close these and now I'm gonna get my prompt. Which is gonna be PB copy. It's also fairly short, so I'm gonna create a new session here. I could create, go on with a new session, but I think it's easier to do just to do this. So this is, this is not a spec driven prompt. This is gonna be a vibe, which is just a regular prompt like what Sean's doing. So I'm gonna paste this in here. So I need to help, uh, to implement a serviceless tic tac toe back end that abides by the open API spec which is hosted here. Build this back end for me using the ABISSA application in this repository. Make sure to keep the implement implementation simple. I do not need unit tests or integration tests. So that's all I'm gonna say. So I'm gonna hit enter. And then uh I'm gonna switch over here so we can see the. Files that's creating and then I will answer the next question. Yeah, yeah. Been, uh, hero CLI and the ID, basically what I'm trying to say is that I saw the recline option which maybe it's available as part of Hero CLI. So whatever you can do with hero CLI and the ID. Uses the same underlying infrastructure. So I can actually do with yeah, so, so the question is, are the CLI and the IDE at parity? Um, the, the, the short answer to that is right now they're not right. So there, there are features that are starting to come to both, um, the, the intent is in the future and I don't have a timeline for this, but they will be at parity. Uh, one thing we noticed this morning is within, within my experimental features on the CLI, right, so there, there was what, which feature was it that just came to the IDE. Uh, the, the checkpoints, checkpoints, right, so checkpoints just came to the IDE recently. That's been, um, in the CLI for a little bit and it is actually still experimental in the CLI. So they are coming to parity. The underlying service is the same, however, right? Like you are using the same models. They're using the anthropic models, um, by default they all use a, a router to get to the, the best model for whatever you're trying to do, or you can actually specify an exact model. Uh, the models do have different tokens that they take. So if you're gonna use the anthropic cloud 4.5 sonnet. I think that's like a 1.3 multiplier. Don't quote me on that exactly, but it's something like 1.3, whereas if you use sonnet 4, it's only, uh, 1, like it's a 1 times multiplier, right? So you, you use more tokens on the higher ones, and of course tokens then. Cost money, right? So when you, when you purchaseuro this maybe comes back to the other question from before on like the, the, the pricing, right? You can use Quiro for free, right? You can use a builder ID to sign up for free. Um, you can use an enterprise license, and they all have different token limits and of course on enterprise license, actually I think on any license you can continuously buy more tokens or more credits. I may have that kind of nomenclature messed up a little bit. This all this all this stuff is quite new, but anyways, short answer is yes. They, they will eventually come to parity, not today, but. A new feature is introduced to the CLI first or? So far it's been kind of there's there's been no one place where it starts. I think there's different teams working on them, so whoever kind of gets to the features first, it gets released first, yeah, like the steering docks right now is only within the IDE. Um, however, some of those other experimental features were, were only available on the CLI up until just recently. Uh, question may not be available on CLA. Yeah, and if you think and so the, yeah, the, the comment was the refined feature in the ID is really nice 100%, and I think it really depends on what you prefer in terms of your I mean, I'm old. I like using Vim and, you know, uh, and, and a terminal, um, but I like that. I like just clicking a button. You can do the same thing in, in, in the CLI. I mean, because all really at the end of the day all it's doing is it's giving it a prompt. It's giving the model some information and saying go and do this for me, um. But then including it whenever you're running the, you know, the, the, the, um, a task, um, there's just some niceties. It's, it's more of like a quality of life thing. It just depends on what your, uh, your experience, what you want to look like. So it seems like the MCP servers that you're using are local MCP servers. Are they remote? These are all remotes, yep, yep, yeah, so in there there are different ways to, to, to interact with an MTP server. Most of these are using a command called UVX, which runs the, the UV tool, which is a Python thing. I don't know if you know that, but, uh, the, the folks who make Rough, um, and UV. UVX is just a way to it's kind of like NPX. It's a way to run a command locally without having to install the package. But yeah, it's just running a command and then it connects to the remote system. It it does support remote and local MCP servers. So, um, like I, I do a lot of MCP development and I always run it just locally because I have the code local and I register it locally and then it just all stays on my laptop, um. Yeah, it does support both so pretty much anything that's just an MCP. It'll support. Now I, I did notice, so about 5 minutes after I think I typed my prompt here, uh, it finished, right? So I'm gonna show you kind of what, what it ended up doing and then we'll test it just to make sure it actually works. Mine finished too, just saying, just saying. There we go. Does yours tell you how long it took? No. Oh, I think mine does. OK. So you'll see here like it, it's very chatty, right? So like here's basically all the, the, the output it's given me, you know, that to do list, it was showing me a lot of the, the, the code it's writing. Uh, I'm just gonna keep scrolling through this here. Um, it did actually finish the deployment and then it ran tests itself, so you can see here it's actually running get commands, uh, using Curl. So it decided that on its own. I, I didn't tell it what to do with testing. It's running its own tests without actually writing a unit test. I could have also told it to write a unit test if I really wanted to replay that a bunch of times. Um, and here I see it's even testing, you know, make sure I get, uh, you know, different errors when I need them for when I expect them out of the application. Um, and then finally, let's scroll all the way down. There we go. My to do list, it shows it's completely done. Um, it gives me an endpoint URL so I'm gonna copy that, um, and then it tells me it took 5 minutes and 11 seconds, so. I don't think we're gonna be able to get that out of yours, but hey, that's fine. Mine was 5 minutes and 10 seconds. Yeah, I don't know about that. All right, so I'll go back to the app here. Uh, I'm gonna configure it, and this, this may fail. We'll see, um. In a registered player. Hey, it worked. Here we go. I've done this a few times this morning, by the way, and this is the first time I worked on the first try. It's been giving me those cores errors every other time for some reason, so there we go. So I just came up with a validation error. Um, and I actually like that it failed on something. If it didn't, then you probably would have thought that I was faking it somehow. So I'm just gonna take that error. I'm gonna post it into my CLI, and then, uh, literally I, I didn't even get any, any context here, right? So all I'm doing is I'm just giving it the error message. It's gonna know that's an error message, um, and you can see already it says, oh, there's a, there's a validation error. It knows the issue. It found the issue that fast. It's now rewriting the code. Um, and it looks like, yeah, it's gonna write that code down to a file. It's gonna deploy it. It's using SAMBuild and SAM deploy, so it did build it using, um, AWS SAM, and, uh, and then once this is done, it, it may or may not rerun these tests. This is the one thing, this is all undeterministic, so it does whatever it wants, which again is why you gotta be safe with that minus A flag because when it does whatever it wants, it might do something you don't want. Um, and then once this is done we'll test it again. In the meantime, I guess we can answer another question. I can try mine too, but yeah, answer a question while I switch over. When you mention Sam, automatically takes care of the gateway as well, or gateway we have to mention it separately. On the. Should be configured to the full. The gateway and routing it to the Oh you mean like, like API gateway or yeah, so, so it's, it's building it in SAM, right? So it's using the SAM specs to build all the infrastructures code, then it's using the SAM CLI to actually build and deploy the application as well. So it's, it's just, it, it selected you. Oh yeah, it, it, it did everything. Yeah, it built the gateway, it built all the lambda functions. It wrote all the code for the lambda functions and it deployed it. It did the whole thing right and usually I would guide it to use CDK. I, I, I didn't wanna do that this time, um, because usually with CDK it takes a little bit longer, um, there's just a lot more code that it'll write, but, um. Oh look, yours mine failed too. This worked in 5 minutes yesterday, honestly. Well, here, I'm gonna switch back and see if uh. OK, you do your air thing. So see, it might not always be a single shot. A lot of times I can do things in a single shot, but, uh, not 100% of the time. So there we go. I'm back on mine here. It fixed the error. It gave me the same endpoint name. So I'm just gonna, I, yeah, it's, it's tracking the percentage. So I see 22 now. That is my context window. So that's another experimental feature. So, so the question was there's a percentage being tracked on the CLI. That is my context window. It is, is managing that as it increases above the threshold, it will, yeah. So, so, so as the context window reaches 100, it will autocompact it, um, and then I can. It's yeah it summarizes it, yeah, and so the problem with summarization is sometimes I lose some of the context I wanna give it so I do notice that if I'm doing a lot of coding and it summarizes I do have to go back and give it a little more information that it may have lost, right? um. OK, let's just quickly test this and see mine was Coors even though I, I was very clear, hey, this is how you should handle Coors. It was a Cors issue, was it? yep. Oh there we go so it's, it's working it's not that, is it that smart? No, it's not that smart, so. Right now it's pretty much just I think randomly placing. Yeah it's, it's not this smart so I, I would now probably go back and say, OK, I keep winning the game you're not placing your turns where they should be, um, improve your algorithm that would be almost my next step here um, in fact, here, let me just quickly do that improve the computer. Oh. It's impossible for me to win. Um, there's a question over here. Uh. Yeah, so the So the question is, does it store the infrastructures code somewhere? um, the, the, the answer to that is I, I hope so. So I, I, I don't think I actually told it. To do that, um. No, yeah, it, it, it, it did, well, let's see, did I write everything in here? There's just the SAM stuff template. Oh, yeah. So because it's using SAM, it's just a template. yaml. So in here you're, you're gonna see I have my Dynamo DB table. I have my er list functions. So that's gonna be a lambda function. Um, so yeah, everything in here is infrastructure is code. Uh, now again, like usually with the apps I like to build, I'll tell it to use CDK, then it'll do a whole CDK and NIT, and it'll write all the Python files and all that. It just takes a bit longer for that, but. Um, that is all in there. Does yours work now? It's deploying right now. His is deploying, yep. For your, for your steer like uh. One of the things I've, I've seen practice work really good is having some. More generic snippets that go along with the architecture, are you guys seeing the same for your steering files, or is it really just kind of giving the high level of just like directory structure of where to find things and guiding it that way? Are you, are you saying that like you, you like to give it code snippets of, yeah, right, like, uh, maybe not so much from the surplus angle, but like, uh, you know, here's how we write API and the documentation that goes along with it. Here's an example of. OK, if it needs to drill into it. Then giving it, you know, the link to the additional documents so I can then go to that. Yeah, so, so the question is, you know, do you, within the steering docks do you give it a little bit more context? Maybe it's code examples or links to a website that has better code examples, maybe a GitHub repository, something like that, uh, that, that is something I do with more complex projects. So I write a lot of code to build myself agent core services. Does everyone know what Agent Core is? Who knows what Agent Core is? Not that many hands. OK. Agent Core very quickly is a new AWS service, uh, that was released months ago. It's, it, it, it is a service you can use to build and, and host your agents. Well, the problem with it is there's not a lot of documentation today within these models. They don't really understand it. So a lot of times I will create some, some, uh, steering docs, and, and you, you can actually add steering docs within the CLI. They're just, you put them in as read me files, um, within your project. Um, or you can put them within your, the agent config, but yeah, a lot of times I will put code examples in there because I know it doesn't know about this service yet. It's too new, right? I almost have to wait for like the next set of models to come out so it understands it a bit more. Um, there's even no great MCP service for today, so I, I do sometimes give it some code examples like, here this is how you do this, so you can continue doing all the stuff that you know how to do. And uh and I'll I'll give a little bit of guidance with that uh and I usually only do that after I find out that the agent cannot build something so I always let it try the first time. Yes, uh, you, you added 4 MCPs. No. Is it like necessary that all 4 should be added or only core is necessary and Yeah, so, so the question is, you know, I added 4 MCP servers. Do I, do I need all of those, um, or are they all optional? I mean, really, all MCP servers are optional, right? But if you're building something, um, and you need reference to, let, let's say if you, if you were building this in CDK for, yeah, so for this example, like the CDK one, I probably could have removed. In fact, I don't even know if I included it actually. I, I know I had it in my slide, but I don't know if I actually included that because I'm not building CDK. But if I was gonna now build this in CDK, I would add that back in to make sure it can do that. So, so be very prescriptive over the MCP servers you're using. Every MCP server you add with all the tools that come with that MCP server, it does add tokens to your context, so it becomes a little more expensive to build. And the more MCP servers you have, uh, the, the dumber it gets, right, because it has too many things to, to look at, too many things to decide. So curate it for kind of what you need. Yeah, a question over here. Specific to view of ID, um, you, you showed early, uh, Jason definition of an agent. Uh, is there a way in the hero ID if I'm working on a project to, to select like I want to use this agent and therefore I configure all the SCP servers that I will need for that use case. So your question is, so these things over here were the um the MCP configs. Yeah, but but that's a configuration of the ID that can be done for the user and for the workspace now is there a way that we can have. Something outside like the agent file that you showed early where where I can have for instance uh an agent for Python applications, an agent for no GS application and whenever I work on a on a no GS project I can somehow use that agent instead of having to. I see. Adding it one by one, yeah, so your question is, yeah, is there a way to have specific MCP servers used in specific situations like a front-end application, a Python backend application, node back. I don't know of a way of doing that like for your, you know, for your entire system where it's really specific like that for the for the MTP servers. The, the resolution that I know about here is either it's for your user or it's for a workspace. Those are the two that I know about. But since, uh, I think the CLI has uh. Uh, a special command agent that you can use to manage all the agents that that you have created. I was wondering if something like that also exists for the ID. Yeah, I'm not, I'm not aware of anything like that, yep. Maybe one day if it's not there already because I'm not aware either. Um, all right, coming up to the last minute here. These are the QR codes to get to all that documentation I was talking about, um, so you have the QO CLI, the QO IDE, and that MCP server repository. Um, one other thing I will say is that I just tested. The change I made and now I'm not able to win my tic tac toe game so it did fix the algorithm and mine worked too. It was something it was something silly but yeah and mine, mine is really dumb like I can beat it. um, I did this one time and it used what's called the min max algorithm and it was unbeatable so you just again nondeterministic you get different things depending on the day. Yeah, one last quick question. This About the MC Thank you. Diagram MCP server. Well, so if, if you go to that link of the MCP, I won't be able to show it because it does, it probably takes a few minutes here, but, um, what I would do is, you know, go, go to that site. There is a diagram MCP server on there. It's just the same JSON definition. You would put that in and then you literally just tell it generated a diagram, and it'll generate an AWS, um, nice formatted diagram for you. And then last reminder, please fill out the session, uh, survey. It really, really, really helps us, um, if you like this or even if you think something could be better, uh, please give us feedback we really appreciate it. Thanks a lot. All right, thanks everyone. have a good reinvent.