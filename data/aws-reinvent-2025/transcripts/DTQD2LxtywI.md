---
video_id: DTQD2LxtywI
video_url: https://www.youtube.com/watch?v=DTQD2LxtywI
is_generated: False
is_translatable: True
---

Hi everyone. Thank you for joining us today. I hope you're having a great reinvent. So, uh, my name's Kevin Kennedy. I'm a senior marketplace solutions architect covering APJ. I'm joined by my colleague, Doug. Hi, I'm Doug Bayer. I'm a senior partner solutions architect at AWS. Uh, I support ISVs in integrating with AWS services. Great, thanks Doug. So, as I say, thanks everyone for joining us today. What we're gonna talk about today, as the title suggests, is code to market. So we're going to demonstrate, and Doug's gonna do some um demonstration in, in the code of how to build and then launch an AI agent on AWS Marketplace. So we're gonna start quite simply by building an agent locally, and then we're gonna demonstrate how to first take that uh to Agent Core at run time. And then from there, we're gonna actually look at how you can take that to market, take that globally, take it to an audience by listing that on Adaris Marketplace. And I'm gonna come with the different options for AWris Marketplace and again show you uh some ways of integration. So. Quick, uh, overview in terms of the agenda. First of all, we're gonna talk about what is Bedrock um Agent C. So if you've not heard of Amazon Bedrock Agent Court, Doug's gonna cover that quickly, so everyone's on a level set. Then we're gonna do a demo, we're gonna, as I mentioned, we're gonna demo an agent locally, and then take that into agent call. Uh, then I wanna cover for you what is Marketplace. If anyone's not familiar with AWS and Marketplace, we're gonna cover what that is. Uh, then I'm gonna cover the delivery models that's available. And then we're gonna jump into a demo as well. I'm gonna deploy some listings on Marketplace and then deploy an integration into, uh, various different ways of metering and license manager. And finally we'll just cover off the next step, so first thing I'm gonna hand over to Doug. Doug's gonna start off talking about um Bedrock, Adrian Corr. Thank you. Um, so, let's talk about what is Agent Core. Um, but before we do that, I just wanna do a survey. How many of you have you have heard of Agent Core? Quite a lot of hands. How many of you have deployed it in production capability? A few hands. So good. Um, so, what is Agent Core? Um, it's a set, it's a set of services, uh, um, uh, um, from AWS, um, uh, it provides the infrastructure for you to deploy, run, and scale your gente architecture. Uh, it was built to be modular, such that, um, it's a bunch of services that we combine together to allow you to operate your agentic application. Following the best practice in terms of security, uh, workload isolation, auto scaling, etc. Um, so, today, we are going to discuss, uh, we are going to deploy an agent, uh, from our local computer, uh, to agent, uh, core runtime. So, agent core runtime sees as the compute, uh, portion of the infrastructure. That's where Your agent runs, um, and, and, and, and it's operated in a way that the workloads are isolated with micro VM VMs and so whenever a user starts a session with your agent in core, it's isolated in a micro VM so to, to provide that layer of security. Um, but agent core, while the runtime itself is uh at the center of it, as I mentioned it before, it's modular, so, so that, uh, we have other services that are That we put together because we know that that's what you need to operate your agenttic system at scale. Um, so, we have services such as Gateway. A gateway really is a way for you to extend your agenttic system to other existing tools within your organization. or outside of your organization. And so the gateway supports MCP, for example, which is a protocol to allow uh uh your agenttic to gain more uh uh context by calling tools, but it also supports lambdas. If you already have a lambda function that you think would be better to integrate it with your agentic. Then you use Agent Core. And we have other services like agent core identity, and, and, and that's to provide the security level um and authentication, authorization. Uh, we have memory to provide that consistent conversation uh level when your user interact with your application. OK. So, um, This is the, the, the architecture. Um, I just talked about uh agent core around time. That's where your application runs. And then you have um uh you have uh any multiple other tools around it to operate your agentic system. Um, you have an agent called browser, for example. So if your agentic system needs to go to the web and acquire some data from a web page, you use that tool, and then you use the gateway for tooling, extending it, and you use memory to provide a consistent. User experience, um, and then you connect it to model of your choice. Um, so that's what the architecture looks like in, in general. And then the red part in the middle is what we are going to deploy. Uh, and we are going to do it, uh, uh, live with uh a demo. Um, so, before we move forward, I wanted just to talk about the portfolio that AWS has in terms of uh agentic capabilities. So, um, you can see the top of the stack is those applications that are ready to use. Those agentic applications that are ready to use. You just come and plug in your data or just augment it with your context and then you can use it right away. Uh, and then when you go one layer down, this is where our agent core sits, you start getting some infrastructure and services capabilities that allows you to deploy, to build and deploy your own agenttic system. Here, we assume that you know your business and you know your customers better than we do. So we provide you with the infrastructure, the services. To allow you to build your, your application and then make it available to, to the marketplace. And so, you can see that there are two square in red here. What we are going to show you today is how to deploy your Argentic platform and then bring it up one stack layer in the marketplace. So that your user can now go and then start using that application without having to code anything. And so, further down the stack to the bottom of the stack, that's where you really need low-level access to build your, your own agentic system. Either you want to fine tune, train, access GPUs and accelerations, that's when you go further down the stack. Perfect. So we talked about Agent Core. This is the core of our demo. This is what we're going to show you how to deploy. An agent that's running on your local machine to the um uh to the agent core runtime. And so, what is agent core runtime really? Uh, it's just a platform um uh that allows you to, to give you the flexibility to deploy your own um coding SDK. So, you, you are not locked to any specific language or model. You can call any models um uh via API. You can develop it using any framework really. Uh, and, and it's just a, a runtime environment. It's uh provide uh um isolation, session level isolation using micro VMs, um, and it supports uh uh any model or any SDK. So this is what we are going to deploy today and then you can see that we are packaging the application, converting it into a docker, pushing it to a repository, in this case, Amazon ECR and from there, the application, the, the, the, the, the container will really be deployed on Agent Core. Before we move forward, just briefly, let's talk about the value. Um, the first value is really time to value, right? Because now you, you no longer have to worry about operating, uh, the infrastructure that powers your agentic system. You are laser focused on developing your agentic system, your code, and then the logic, the business logic solving your customer's problem or your, your organization's problem. We remove that management operational layer for you. And so that's one of the values. So then, because you're laser focused on developing your, your gentic uh application, you become more productive and you become also cost efficient in that. And the flexibility, as I mentioned earlier, you are, you can use any model, uh you can also use any language framework to deploy your application. Um, and, and, and, and trust, of course, we've baked in all the security-based practices that we've learned over the years. We've baked into the, the, the, the modularity of the application, the platform, uh, in Agent Core, and therefore, um, when you start deploying your application, you have all those security toolings and, and services that allows you to just operate it faster at scale and at production level. And then briefly, uh, for this, the, the, this demo we'll be using strength agents. Um, Strength agent is just an open source SDK, um, I mean, it takes a, a, a model-driven approach in developing agents. And what it really does is it, um, allows you to build an agent with just a few lines of code. Uh, remember, when you are building an agent, especially if you are going to expose that agent to tooling, you need to build logic into it. If, then do this, use this tool, etc. But when you're using a, a, a, a, a dedicated agent like uh um with a strength agents, um, all that is done for you. So your agent is a Intelligent enough to know that this question requires me to access this particular tool and then it's only going to call that tool without you telling the agent that I want you to use this tool. And so it's, it's a very uh powerful um library. You can use this or you can use any other gentic library that you are familiar with. Perfect. Uh, I'll switch over to my uh laptop and then just start uh doing some demo. It's Hopefully this is not too small. Um, so this is a, an, an agent that I have developed that runs on my local machine. Um, so you can see that I'm importing this trends agent I just talked about, uh, to build my gentic application, and then also some tooling because I'm gonna, uh, have my gentic system access some tooling. And then, so, then you have to define your tools, right? Uh, any, any other import is just, uh, um, really to, to, to help with the application. But really the most important are, um, the agent that we're going to initialize and the tool. And then also we're importing some built-in tools. So, Strength agent has some built, built-in tools. They are mostly just, uh, uh, for reference and then if you have your own tool, you can just bring it in. Um, and then, so, for example, here, we are taking what is a regular function with a dummy response. It just returns, uh, sunny, uh, uh, and, and, and what we're doing is we are decorating it with a tool, uh, from, from, from strands. And when you decorate it with a tool, it automatically converts your function, any Python function. When whenever you decorate it with a, a tool, it becomes a tool. And so we have a set of uh tools here. We have one tool that gives the weather it's a dummy uh answer, another tool that gives financial advice, and another one that gives you information about your AWS spending. Uh, and then in addition to those three, we also have two others, a calculator and a, a, a, a, a file reader. Um, so, what we're doing here is we are initializing our agent, um, um, by, by passing a model to it. If you don't pass a model, it will just pick a model for you from Bedrock by default because we are using the Bedrock, uh, initialization, right? From strength that model, you import Bedrock. Uh, let's say you wanted to, you, you, you, you use OpenAI. What you do is you import OpenAI. So, It's just to help uh and, and accelerate the development. And so, because we are specifying a Bedrock um model, if you don't specify the model that you want, it's gonna use selected default for you. So, in this case, we're specifying the anthropic cloud 3.7 sonnet. And then we are passing, we, we are now initializing our agents, passing in the model, and then uh the tools. So, this is where we are passing multiple tools. Why are we passing multiple tools? Just to show you that your agent will be intelligent enough to, to, to select the right tool based on the user prompt, the user's question. And then this is the function that um takes the user prompts and then pass it to the agents and then uh process the return. And then, yeah, that's it. If you wanna uh run this application, you can run it. I have a streamlet um running here so you can ask it a question, um uh what is my AWS pending, um, just any question to see if it's gonna recognize what tool to invoke. And then give us the answer. So Doug, quick question, so you've called this a local agent, so this is running locally on your machine at the moment, is that right? So, but it's making a call to the model. That's obviously elsewhere, is that correct? So it's, it's not all local, just the agent itself the building is local, but it's making calls to a model externally. Correct. So, the agent, uh, is running on my local computer and then it's calling Bedrock through the STK through the API. Um, I could have done it with a local model as well. Um, but because we're going to deploy it to, to, to AWS, it makes sense to have a model that's accessible over APIs. So, yeah, it runs on my computer and then it answers my question. I just ask it a question about billing, it selected the right tool, and I can ask it a question about, uh, give me some financial advice and then um. It's gonna detect the intention and then it's gonna look through the tools and see, oh, I have a tool that can provide financial advice. I'll use that tool. And then, and, and it returns um. The, the financial advice essentially. Um, yeah, so now we have an agent, it's run, it's running locally, but how do we convert that agent so that we can deploy it into agent core. So, I'll come back to my application. So, my application is called local agent. What I would do is I just copy it and then call, call it uh hosted agent. OK. Now, I have an hosted agent application that I'm gonna pull up. It's exactly the same application. We're just gonna convert it to an agent called ready application. So, the first thing that you do is, um, you import the runtime. So, I'll do from um Bedrock agent core. Um, That run time And then I'll import um my Bedrock app. So, this is a Bedrock application, right? So, that's really the first thing that you do to convert a code that runs locally into an agent core capable. And the second thing that I would do is initialize my, my application. So, I'll do app, um, eco, Bedrock. And so that's the 2nd code that I'm adding to initialize uh the application. And so, all my tools will remain the same. Right? Here. And then the only thing that I would change, remember this is our entry point, right? This is the function that we are calling when we were using it uh on the, on the, the, the stream leads, right? It's called this function. So, in order to operate it in on agent core, you need to tell agent core what is your entry point. And by doing the, the way you do it is you again use a decorator. And then you call the app that we just initialized and then you say entry points. By decorating my function, uh, I'm telling Agent Kre when it's deployed. I want you to use this function when I'm calling the endpoint with uh entry points. And so by default, entry point is your default uh API. By default, it's gonna execute this function when it's running on agent core. So, this is the third line that we've added. Um, and then because it's going to become an API, Agent Core is gonna just convert this application to an API. We no longer need all of this. All we need is to initialize our application. And then we sit up that run. So, here, you can specify a port, uh, by default, it's gonna use 8080. Um, but you don't need to know that port from the standpoint of a user trying to, uh, interact with it because all you need is called the agent core endpoint. And so we no longer need all of this because this is just for our local application. Um, yeah. So, you can see that we've, we've essentially 4 lines of codes converted what was a local uh um agent into an agent code capable. Um, then, and then so, before we move forward, let's review, um, Our requirement file. So, we're importing strength agent, Bedrock, agent core, um, of course, we're using both of those um to initialize the app. But then also Take a look at this Bedrock agent called starter toolkit. This is very important because what this does is it provides you either an API, uh, I'm sorry, a CLI or an SDK for you to deploy your agentic system quickly. In this case, we're going to use it as part of a, a, a CLI command line. Uh, but I, I, I strongly encourage you to use the starter kit because it speeds up your development and deployment and testing. And, and, and I'll show you what I mean, uh, in a moment. And then all the other are mostly just supporting tools here. OK. So, I'm gonna go back to my um Uh, hosted. So now that I have, uh, uh, updated to be capable of, uh, running on agent core, it's still a local agent. I can still operate it locally. Uh, uh, if I run it, it's just gonna deploy an, a, a web API locally, and then I can just interact with that web API. But the goal here is really to push it to, um, uh, to, to push it to an agent core. So, the first thing that I would do is I'll just say, um, agent core. Um, I need to be on a terminal. So it's agent score and then configure. And then, and then I pass it to my application, the ones that I just prepared to deploy. In this case we call the application hosted agent. And so, that's the first thing for you to start preparing your application to deploy it on Agent Core. Remember that my CLI is configured with my AWS credentials. However, you, you, you do it temporary credential, permanent credential, we usually recommend using STS for this. And so, what I would do is I'll just gonna start configuring my application. And then, for the purpose of this demo, I'll, I'll, I'll just go with the default uh settings. Um, so, it's asking me to provide a role or create one by default. I'll go again and then just auto create one. And then it's asking me to specify a repository where the docker is gonna be pushed to. And then I'm gonna also ask it to autore for me. Um, and then, um, it has detected that I have, I have a requirement file locally, which I just showed you this requirement file. And then so it's asking me if this is going to be part of the, the, the deployment, um, and then I'll say yes, use that application. Um, so I just enter. And then authorization configuration. So, how, how do you want your user to access the application? Do you want them to use off or do you want them to use any other credentials? For this purpose, we'll just go with um the default uh IAM um um but in production you wanna Especially if multiple users will be using it. Using an off-setup is um is a good way to do it because then uh it uh every user has different level of authorization, that authorization will follow them as they execute your agentic system. And then, um, I'm not gonna add any um um uh or restrict uh any access to this for the purpose of this demo. Um, but essentially, you will do that if uh you want to restrict uh access based on uh the, the network. Right? And then so it test configured my agents locally still, and then it's created a few files. It created a Docker file. Um, this is the file that's gonna execute to actually package my Docker, but also it has created um. A Bedrock agent configuration. So this is the configuration. It's a snapshot of how my agent will be looking, uh, and so you always refer to this one to see what are the configurations, and you can edit that configurations and push it. So, um, briefly, so, this is where we are, right? We, we are packaging, it's, we are going to push it to the repository on ECR and then deploy it on gent core. Perfect. So, now that we have configured it, we now need to push it. And then all you need is type agent, core. Launch. That's all you need. Enter. And what it's doing is it's converting this application into a Docker file, putting it into a repository on ECR, and then once it's done, it's gonna just pull that application into agent core and that's it. It becomes available for you to operate and to start running in fairness on it. So Doug, quick question, so while you're implementing there. What we've shown here is Adrian Core, and it looks pretty simple to take from local to migrate to Adrian Core. With the run time, what's the alternative? So if someone wanted to take that agent they built locally and run that. On a de breast or on that anywhere, what do they need to do instead? Yeah, so you, you have the option to use Agent Core. Of course, Agent Core has all the set of tools and services ready for you. So it's, it's just helpful and it's a managed service. But if you think that you have the expertise and then you want to deploy self manage it and deploy it, uh, you, you, you could, first you can use, uh, the SDK in, in addition to the CLI you can use cloud formation or, or cloud development kit to push it to agent core. But then if you wanted to self-operate it, you can also run the same agent on an EC for instance, or you can run it on a containerized environment such as EKS or ECS. So and that agent called one time, that's Servius, is that correct? Yes, it is a surless infrastructure. So it's, it scales as you use it. I remember I said that it's a micro VM uh, a session level isolation. So, each user that start interacting with the application has an isolated micro VM and then that scales based on the number of users that you have. So, it's auto-scale up and down for you. Uh, but to be clear, there's no infrastructure to manage for the customer. They're not managing virtual machines, are they? No, you're not managing any infrastructure. You are given a monitoring platform that integrates with AWS services, and then that's what you do. You plug into your monitoring system, but essentially this is operated for you. You only pay for what you use, etc. That's it, yeah. We can see that our application is deployed on gent core. And so, now, we may need to invoke it and um and and test it. So, let me try to test it. Uh, the same uh command, agent core. And then in book. OK. And then you have to pass it HSN. So what I would do is uh uh So our our our ouracity prompts. OK, um. And then that would be my question. Uh, so, let me see, um, can you give me some financial advice? Same question we ask it. And, and so, now that the agent is deployed uh on, on um Agent core, we are invoking it directly from it and then it becomes an API essentially. Um, all right, just making that my prompt is correct and then I'm gonna run it. The dog that's now cool in the container that's hosted in agent core one time. Yes, so we are at that layer where now I'm the user, and then, uh, I have an application. Uh, your user will not not directly interact with the agent core API. You build an application on top of it like my stream leads application, for example, and then that's the API that will be called. And and so you can see that the agent has replied with uh the financial advice that I have asked for, uh, the same one I got when I run it locally. Uh, and then I can even go to my um My agent called um. Actually I have it here. And so you can see that uh I, I now have it running here. There's multiple agents but Remember we name it uh um hosted agent, and it's right there. And if you don't specify a name, it takes the name of the Python file and then that's gonna be the name of your, your agent. So, we are in runtime, bedrock, runtime, and then you see all the hosted um uh agents here. And so this is the agent, you can browse it, look at it, you can even interact with the agent from the terminal for the purpose of testing. Um, etc. So, uh, just to recap, we package a local agent with a few lines of code, right? And then we convert it to Docker. Once it's on the ECR repository, it's there, it can be reused, it can be redeployed multiple times, right? So, if you are an ISD, you wanna sell a product. You can either offer it, uh, and Kevin is gonna talk about it. You can offer it as a SAS, means it's hosted on your accounts and then they can access it via API, or you can also, uh, just, uh, have them deployed in their own accounts, and Kevin is gonna go over those, uh, options with you. But yeah, just in general, we took what was a locally running agent, we converted to a hostile agent, uh, with essentially 4 lines of codes, and then we were able to execute it from agent core. Uh, yeah, and that's it. And so, uh, if I, I, uh, I wanna finish my testing, I'll just do agent core. Destroy. And then if I enter, it's gonna clean up everything from my local machine, but also it's gonna remove everything from agent agent core runtime on AWS. And I'm not going to destroy it because Kevin may wanna reuse it. So, um, yeah, thank you very much. This was just how to push it to, um, agent's core runtime. Now, I'll pass it to Kevin. He's gonna talk about the marketplace, uh, aspect of it. Great, thanks Doug, that's really good. So just to recap, Doug's built an agent locally, then he's migrated to Agent Core with just a few commands. So that's great, but it's running your environment, so if you wanna take that to market, and you wanna productize that, you need to think about how you can either deploy that into a customer environment, or as Doug mentioned, you may have a SAS component where you charge the customer there. So we're gonna cover a bit of that at the moment. So we're gonna take it a step further. We're gonna look at how, how you can productize it. How you can firstly list the product on Marketplace, and this will enable you to take that, that product globally, but before I go into that, I just wanna level set, so can I just get a show of hands who here is aware of Adibus Marketplace? Yeah, quite a few of you. So just as well, who, who has either listed a product on Marketplace or purchased a product via Marketplace? OK, less of you. OK, that's great, so we're, we're gonna cover that today, um, and, and if there's any questions I can cover those off at the end as well. So. Let's see, 8 of us Marketplace, so for anyone who's not too familiar, our vision for Marketplace is to be the best place for customers to find, buy, and deploy third party software. Professional services and data, so we look at here is the everything store for software. Here's some stats we've got available, um, it gives you a bit of an idea. We've got over 30,000 transactable listings on Marketplace today. We've got over 70 categories, and recently, uh, in I believe July of this year, uh, we introduced categories for AI agents and tools. Uh, we have over 3 million subscriptions, and, uh, a really important one as well is millions of visitors per year to AWS Marketplace. So, if you're an AI agent today and you're looking to take it to market. It's a really good place to take your product and it reaches a global audience, so. What I'm gonna talk about today, we're going to focus on is the AI agent delivery models. So let's discuss a few of those now. Right, so In the AWS marketplace, each product has a different product type, so I think it's alludes to, you can, you can categorize those based on whether you would like that product to be. Deployed into the buyer's account, so we see a few here, we've got an AMI containers, machine learning images, they will be um er purchased by a buyer, and they get deployed into that buyer's account. So they would then look to then manage that, the resources for that product in their account, but you can charge them, for example, a licensing. On the other hand, you've got the seller account with the SAS product, so if you've got a product that runs in your account and you want to provide access to that product, say, via a license, and they can sign up um to your product, have certain entitlements to that, that can typically be a SAS product, but the definition would be, is it going to run in your account as a seller versus is it going to run in the buyer's account? And the thing we're going to focus on here is if you see down the bottom, we've got compatible um containers can deploy now an agent called runtime. Um, we also have API based SAS, uh, AI agent and tools. So one, as I say, would be agent call runtime deploys as a container in a buyer environment. An API based SAS, AI agent and tools would be a SAS product that deploys in your account, and you provide access to the buyer as an API endpoint. Both of those, and we're gonna go into these in a minute, go through uh upfront contracts, um and also pay as you go pricing, so that applies to both. And really the decision you need to make really, which one you choose, is really the the um understanding what your buyers um are looking to purchase and understand how you'd like to take your product to market. So that's really a business decision on which one you prefer to do. So Let's have a little bit more look into this one here, the two options that we see Kevin container base agent and tools on that left there. Kevin, a quick question. Um, what are some of the factors that, uh, customers need to take into account when deciding the listing model or the pricing model? Yeah, sure. So, so the pricing model, if, if you're deciding that, um, we're, we're gonna cover that in a moment about the difference between contracts and, and pay as you go. But ultimately, um, the first decision you need to make is how you wish to deploy that product, um, and that, that make a decision first, so. Is infrastructure going to run in your environment and you give entitlements to a buyer versus, are you happy to if you go back to what Douglas created and known as container to package that up, then the buyer will go and access that. So that's the two different models, but we're going to cover off a couple more in a moment, which will be a contracts versus pay as you go. Um, and again, that will just come down to really the buyer preference, um, and whether they're comfortable purchasing it as a pay as you go product versus purchasing it with a contract where they purchase entitlements in advance. So We're just going to move on and look at how it gets deployed and I'm going to do a bit of a demo into the code as well. So what Douglas showed you earlier is how to deploy that agent, we've got, there's a docker file, it's gone onto the ECR repository, and that's all in your environment today. So if we bring it into Marketplace, what we're gonna then do is create a marketplace listing. And then if it's a container, we create a container listing and then we take that um container which is in your private ECL repository and bring that across into a marketplace ECL repository that applies to your listing and then you publish that, so it's very simple. So we're gonna, let's go and have a look at that now and I'm just gonna do a deployment. So I'm gonna show you how that's gonna look. Alright, so First of all, if we, if we're looking to do a deployment, you can either deploy it via a marketplace portal, so it's kind of a click, click mix, and you can do it to deploy it, or you can templatize it, so you can create a JSON file with the the parameters you want, with the content that's required, and then what you'd do is you'd call the Marketplace catalog API. So I've created some of these here um in advance and you can look at um we've got some examples that you can do yourself, so if you, if you're looking to deploy multiple products I'd recommend doing this as as a JSON file. Um, and then just deploying it in a way called a marketplace API. So let's look through what, what we've got here. So we've got a logo that's required for your product, and we've added a few categories, um, and then we've just given the product a title. So you'll just give it a title that's appropriate for your product. There's other things you'll need to include in it such as a long description, and that really helps with the search engine optimization and really helps with the buyer experience to understand your product. And a few of those here, such as highlights, but the things I want to highlight to you here. Is the dimensions, so. When you publish a product or a list of products on the marketplace, you create what is called dimensions. That's really the pricing for your product. So in this case we've got a standard. And a premium product. So this one here is a pay as you go subscription product, so it's going to be externally metered. And we've, what we're gonna do, when a user signs up to use that product, they can be either charged a standard price for a standard query or a premium price. And what you sit here for the dementia is entirely up to you, and it really depends on your products, it's very product dependent, but you'd unders you'd usually align this to how you're charged for your product today. So you, if it's a an AI agent and you're looking to charge customers, what I've done here, it's a standard and premium depending on the query they um send in. And then once you're happy with that, you'd create the repository that would go into Marketplace, you're giving it a repository name and that just gives it a unique name. And then once we're happy with that, and we set that price in, so we put a price for standard, and then you can set a price for premium, and then you're ready to go. So what we're going to just do here. I'm going to generate a list in here, and that's just given me the command I need to run. And I'll run that, and that's gonna call over to Aidwards Marketplace, so if the syntax is correct, we get back what we've got here, which is a change set ID and a change to ARN that that shows me the syntax for what I put from my Jason file is correct, it's got the content required. So the next step for that, before we move across. You can now see here, all being well, we should see 22 or 3 requests that come through to create new listings, and as we can see it here, we've got 3 new listings that's been created, they're under review at the moment. That takes about 10 to 15 minutes, so it gives you an idea that it takes a little while. Once they get approved, then they get published onto AWS marketplace, and that'll be your listing ready to go. But let me just show you one I created earlier in the interest of time rather than waiting in 15 minutes. So we'll just have a quick look here. I created a container contract product earlier. And what I've done, what are the details we saw on that Jason file. And pricing information, so this is a contract based one. And we've got a simple and advanced, and I also created one for pay as you go as well. So and then we would create the repository, so pretty straightforward there. So let me just move back. All right, so now we've got the listings and Marketplace. The next step. He's deciding. The pricing model, as Doug mentioned earlier, so we're focusing today on the container products, and SASS would be a separate one, but we're going to focus on the container pods. So there are going to be two we're going to look into today. One is with license manager. So essentially every request will trigger a license checkout because we call him license manager. So what's gonna happen is um someone will go and purchase a product to purchase those dimensions, and then once they've um run a query, they'll check out a license against that, we'll show you that. And if there's no license available, then they'll get an invalid license error. So this model, they're essentially pre-purchase licenses, and then it'll draw down against that with license manager. So think of it as an analogy, if you were going to buy coffee and you purchased 10 of those in advance, and you can use that to purchase those. Alright, so, and the other one we're gonna um I'm gonna show you here, here's some of the code that you'll see, uh in terms of the parameters that get called. So the examples of syntax that need to be provided to, to check out a license. And the other one would be contract pricing. Um, so we're gonna go through and demo that afterwards. So let me firstly go back. I'll show you how it looks for contract price first. So we've got a contract price here, so we go across that one. OK, so we've got a contract for agent here. So the main thing is what we've taken across, we've advanced what Doug's put in his code. Doug has got, um, he's added the, the Bedrock agent. Now we've added in license manager, so we've add in, quite simply, it's gonna use um the client for license manager, so we need to call upon that. I've added in the product ID and that product ID relates to the listing new crates. And then quite simply I've added in some stuff here for licensing and check out, so what I've specified here is for each time a cruise run. To check out one license, and that's based on the dimensions that you've set. So we've got some of the components here and if it's successful, take out one license. So how we've done that, determined it, we've determined a simple is going to be based on a simple query and then advanced. If it meets any of these keywords such as deep analysis or detailed analysis, any of the ones I've falsified here may be advanced. It's quite simple, but you can put the logic into your application for that. And then the agent endpoint, as Doug explained earlier, so the main difference we've added here is the ability to call license manager. So I'm gonna show you this one here, so in this one I've I've deployed this into Agent Corre much the same way that Doug has created, but it's running locally in my account at the moment as a test. So I'm just gonna do um a quick test of this one, so Agent Care invogue simple finance advice. And this will come back, and then if everything's all OK, it'll come back, as you see here. Dimension's simple and it's consumed one license and then um you get a unique ID so each time you run that it'll draw down a license from a license manager. So the alternative would be, as I mentioned before, is. Is, uh, yeah, the, the alternative would be metering. So if we went down the path of pay as you go, uh, the main difference we would see here is it would actually use the marketplace metering service. So if you think of it as pay as you go, you're going to buy a coffee, you're paying for that coffee each time. That's exactly what you're doing here, and each time a query is run, it'll lead to that, and then based on your dimensions and your, your charge type, then um there will be a charge to the user. So that's essentially how that works, it records the actual consumption in real time. And the customers only pay for what they're using per their bidding request, and um it and similarly I'm going to show you it will detect, If it's a simple or advanced query, it's much the same way, but except using License Manager, what we're going to use here. Is the meter in API. So if you flick down to here. I've set this one up earlier as well, so if we run, we go through the code on this one, very similar, we've um we've difference here, the client rather than being license manager, we've called them the Meter Marketplace. So we've called that one here. We've set in here the product code, so that's unique to your product listing as well. We set those dimensions as standard and premium. And the same logic as we had before. We've put in place that if it meets any of the keywords. And it would be premium, otherwise it'd be standard, so for each of those keywords, if it comes over there'd be premium, otherwise it'd be standard, and then we'd get the output. So very simple and straightforward, and then we run this here, I'll do a prompt. I'm going to ask it for simple finance advice, same query as before, but except for drawing down from the licensing, from the license manager, what we're going to do here is it's recorded a query and it's given it, say we've used a unit of standard. And here's the metering record, and each time you run that it's gonna have a unique metering record. The main difference is you're not drawing a gown against licenses, and every time you run this, you can continuously run this and you just pay as you go, depending on the uh the price per the unit. So that's pretty straightforward there, so the next bit I'm going to show you afterwards. Would be the customer experience. So let's have a quick look here from the customer view. So Once we go over to here. You can see I've gone on to a different account now, so I've gone into a customer account, so this is what a customer would see. So they've seen a product I've created earlier. And they could have got the option to purchase that, so in the interest of time, I've already done some things in terms of purchasing earlier, but let's let's go through the process. So you can subscribe to that product. And this would be a public offer, and what we've got here, we've signed up here for one month. And you've got advanced and simple dimensions. What I've done here is I've purchased 40 of advance and 40 of simple, and there's a price against each of those, and we've, we've done that earlier and it's been subscribed to, and now I can just launch the software. And because this is Bedrock Agent Core, and it quite simply ploy it into my environment, so I can now set up hosting on Agent Care. So if I click on that it's gonna take me through to Agent Core run time. And this would be the buyer experience, so we've got, we've got buyer. Agent As we go down here, we just decide we're going to host this agent. This one I'm showing you an example of is a contract pricing. And what we're going to need to do once it gets deployed is give its permission to call the license manager. This will start deploying here I'll just go through here to the version it's created, and as Doug showed you earlier, it is a service roll, so if I click on that roll. I can see it's got the ability to execute agent call runtime. It hasn't got anything at the moment for license manager, so let me add that one in here. So we've got a license manager consumption policy. We'll add that in. And that's going to allow us each time it runs to connect to license Manager. So what I'm going to do, as you see, this is a new one that we've deployed, so if I go back to. This particular one here. This creates a unique run-time ARN so I'm gonna copy that. And what I've done I've just created some Python code here. And this is from a a buyer experience, but I think as Doug mentioned earlier, most, most likely you'll create this as a web application, but you, the buyer can call this um agent from Agent Corp directly from um the console directly from the command line here, so what we're gonna do, I'm gonna update this. I'm gonna provide it in here. The ID of the agent that has been subscribed and what it's going to do. We're going to run a command against that. It's going to invoke the agent that's just been purchased, so it is in the buyer account. And that's invoked that successfully and we can see here the dimension here is used as a simple license. It's consumed one license here and that's the token. What we can also check. I actually, this is from a bi perspective, how many licenses they've got available still. So we do it in a couple of ways, we can just run that via the command line. and we can see here. I've got In terms of usage, I've got a simple, I've got 39 that have been consumed. Out of 140 because I've been testing it earlier, so if I was to run another. Come on down. That would hit the 40 mark, and then what we see is if it goes above 40, you won't be able to run any more commands. So we run that one here. So we should now have hit 40, so now we've got an error that's come back, and it's checkout failed, an error's occurred, there's no entitlements available, so, and then if you're go back and check. All 40 have been consumed, so what that means is, as a buyer, they can then decide to go and purchase more licenses. So it's a great way to take your product to market and let buyers consume a certain amount of licenses as a contract pricing, and if they consume all of those, they can come back and purchase more. And the alternative which we showed before is that pay as you go model, and, and really the difference is that pay as you go, if they're comfortable with that, they just pay as you go on those continuously. So really what you can do if you're looking to take a product to market, you can actually list that in two ways, you can have one as a contract and one as pay as you go and give those users the option there. So I was going back. OK, so we've showed you how it looks like here. And this was how it looked when it integrated, so we just did the demo of as a pay as you go. So that, that's pretty much how it gets deployed, and that's from the, the buyer experience, and you can see how simple it is to take that as a container product. The alternative would be if you were looking to provide that as a software as a service, um, and really what you'll just look to do there is you'll take that agent that Doug created earlier and rather than taking that as an agent, you deploy into the customer environment. You would have that run in your own environment. And then you'll sell that as a software as a service, provide access as an API endpoint, um, and then the, the users would be able to access those APIs and then you'd be able to charge them based on their, the usage of the product, so again you can go down the contract model or, or you can use uh pay as you go. The difference is that the metering records you'd be in charge of understanding what metering the customer is using, and you would send those to AD Press once per hour and we'd have um those metering records and send that back and charge the customer. So that's, that's really the two differences. So that's pretty much towards the end of the talk there. Um, what we've got in terms of next steps, so there's a couple of workshops, if you'd like to get involved and then to build an agent yourself and then sell it on Adais Marketplace. We've got a session tomorrow that starts at 1:00 p.m. till 2:00 p.m. in Caesar's Forum. And there's also some published labs as well, so we've got Agent Core um based on AI agent and tools, and we've also got a a lab if you wanted to do a SAS model as well, so SAS API based AI agent and tools. So really if you're looking to get involved in these and you've got something you want to take to market, I'm encourage you to look at the labs and you can follow through and publish those. Um, yeah, I think that's about it in terms of what we've got, so thank you for your time. Happy to answer any questions anyone's got.