---
video_id: DML9s_6nDyw
video_url: https://www.youtube.com/watch?v=DML9s_6nDyw
is_generated: False
is_translatable: True
---

Hi everyone. Thanks for coming to my session today. I really appreciate it. Uh, I'm James Chatmus, Principal Solutions Engineer at Octopus Deploy. Genuinely excited to be here today. Uh, today we're diving into a challenge that every bank on the planet is wrestling with. How do I deploy software faster? Without breaking compliance and without failing my audit. My session is all about building CICD pipelines that are both genuinely fast and 100% compliant, which is a true North Star that most banks are looking towards, uh, in this current day and age. In my role at Octopus Deploy, I work with some of the largest banks in the world, helping them automate their CICD pipelines. So everything that we're going to be looking at today is based on patterns that I've seen time and time again. All right. Great. All right, so here's the game plan for the next 18 minutes. Uh, we're gonna start by talking about why supply chain attacks are the number one risk for banks in 2025, uh, and why all automated software delivery pipelines are susceptible to them. Uh, then I'll fire up a live demo. Uh, I'll walk you through a true zero trust. Deployment pipeline end to end uh using GitHub actions and Octopus Deploy, which is the exact pattern that a lot of banks are moving towards uh to deploy their production workloads. And then finally, uh, we'll look at how Octopus deploy enforces governance around things like verifying attestations, uh, checking S-bombs, and validating vulnerabilities at deploy time. So let's set the stage with a statistic that's uh pretty eye-opening. 75% of enterprise organizations, that's 3 out of 4, have experienced some sort of supply chain attack in the past 12 months. Pretty wild, right? Um, and I mean if I'm an attacker, it kind of makes sense. I could spend time trying to, you know, hack into a hardened production environment. But why would I do that? Why wouldn't I just slip some malicious code into the CICD pipeline and let my target just deploy it out to production themselves? And what if you're a bank or a payments processing company or some other regulated financial institution, uh, all of a sudden that malicious code that makes it out into production could turn into eight-figure fines for your company, uh, could turn into your CISO or CEO on the evening news. Not a great look. So that's exactly why supply chain security has quickly bubbled up to the top of the list of priorities for organizations over the past 12 months. So let's talk about the true reality of modern. Pipelines You kick off a build, uh, your unit tests run, uh, you code scan your repo, uh, your artifacts get created, get pushed out to your package repository, uh, and you're ready to deploy, and then nothing. The artifact just sits there, you know, sometimes for hours, sometimes for days, uh, and in a lot of the companies that I've spoken with recently, uh, those artifacts just sit there for weeks before they get deployed. And that time gap between the build and the deploy, uh, that's called the drift window or as I like to call it, that's the danger zone. And a lot of things can happen in there, um. Anything from a configuration drift, uh, you could have a new zero day published, or in the worst case scenario, a bad actor decides to replace the artifact with one that has malicious code in it. Point being, the longer that drift window exists, the bigger the blast radius, uh, for any sort of changes. The scary part though, is that most organizations have multiple drift windows within any release cycle. So, uh, you know, you've deployed to dev, you're waiting for your QA team to promote it out to their environment before they can test it, could be a few days. Maybe you've made it to your stage environment, but you're waiting on cab approval to go to production. That could be weeks, uh. And I've worked with some companies that get everything approved, they're ready to deploy to production, but they only do deployments once per quarter, so you're sitting around, that artifact is just sitting there essentially going stale, uh, during that drift window, um. So how do we make that drift window something that's safe and, and not something that's, uh, a constant risk as when it exists? So we can make that safe with, uh, by putting together three key pieces that work in harmony to kind of. Make that drift window safer. The first one, software bill of materials. You might have heard the term S-bomb. This is the ingredient list of what went into building our artifact. So it's a complete list of the third party libraries and components that were used to create the application. The second piece is our provenance. So this is the who, what, when, where and how of that artifact getting created. Um, so everything from the commits that are in it to the, the workflow file that was used to build it to, uh, the runner that the build was run on, uh, everything around the creation of that artifact is the Province, and then finally the third piece is our attestation. This is the, the cryptographic glue that kind of holds everything together. It's a signed statement or a certificate, uh. That's saying, hey, this S-bomb belongs to the package that I created, and this is the provenance that was used to create it. And ideally, all three of these are generated automatically, uh, and they're verified at each stage of your software delivery life cycle. When these three work together in unison, that's how you get a drift window, uh, that doesn't rely on luck to be safe. Uh, you're putting controls in place to, to make it a safe time. So the Zero Trust pipeline only works with a clear separation of duties and a clear segregation of responsibilities. Um, so let's talk about who does what. On the left we have GitHub, uh, exactly where it should be with our code, uh, and that's doing everything on the CI side of the house. So, uh, we're building our code, running our unit tests and scans, generating our S-bomb and attestations, scanning for vulnerabilities, and then ultimately we're publishing our artifacts out to our package repository, that immutable artifacts. Once the CI process is complete, uh, that's when Octopus comes into play. Now think of Octopus deploy as your, uh, single source of truth for everything deployment related and kind of the final gatekeeper when it comes to, uh, deploying your applications safely. So octopus, what are you responsible for? Verifying our S-bomb, validating our attestations? Enforcing any sort of policies that your organization has, uh, maybe around approvals or vulnerability checks or uh configuration drift. Once those quality gates pass, then Octopus carries on with the rest of the deployment process out to EKS or ECS or, you know, serverless, EC-2s, what have you. Um, on top of that, we kind of keep, uh, a rolling audit of everything that's happened, uh, leading up to the deployment, uh, and Octopus makes it easy to roll back when necessary. Perfect. Slides are done. Uh, I've got a real pipeline ready to roll here. Uh, let's fire it off real quick and watch this whole, uh, zero trust flow in action. Perfect. So we're gonna start uh in GitHub where our code lives. Uh, the project that we're gonna be working with today is our account registry project. Um, it's a containerized application that we're deploying out to EKS. So I'll hop open, I'll hop over to my actions tab and uh We have 2 actions workflows ready. Uh, so we're gonna be focused on the supply chain, verified, build pipeline, GitHub actions workflow. So I'm gonna click on it. Uh, this workflow is doing a ton behind the scenes, and I'll kind of walk you through that, but let's, let's kick it off and, uh, get it going. So we'll run the workflow, refresh the page, and take a look at this, uh, this GitHub action in action. I'm not gonna walk through the YAML file, not a lot of value there, uh, but we will kind of look at this, uh, GitHub graph around what's happening. So, first piece to point out, this pipeline's built for speed, right? We're not, uh, we're trying to deploy software faster while keeping it safe. Um, after our pipeline initialization, uh, we're running a couple of steps in parallel. So we're scanning our repo, uh, at the same time that we're building our image, uh, and publishing our S-bomb. So that, that repost scan is a quality gate that takes about 20 seconds, not a huge time sync, but it's running in parallel with our docker container build anyway. So we're not losing anything in our total time, uh, of the workflow running. We're also building our container, we're scanning it, uh, and we're publishing that S-bomb, that list of ingredients, uh, that we'll use later in the deployment process. Once both of those quality gates pass, uh, we're publishing our GitHub release, uh, and then we're signing and generating our attestation. Uh, on the CI side of things, this is kind of the, the critical piece of this workflow. So, uh, when we're signing and generating the attestation, uh, we're tying that S-bomb and uh our Docker container together, uh, and we're essentially getting signed metadata that we'll use in the deployment process to validate, hey. The container that I'm about to deploy is the exact one that I built earlier in my, uh, pipeline. And then finally, uh, back to that separation of duties that we talked about, uh, this is where we're handing off the deployment to Octopus Deploy, uh, to kind of continue with the CD part of our CD CICD pipeline. So let's hop over to Octopus now and, and see what that looks like. So this is the Octopus deployed dashboard for those of you that haven't seen it. Uh, it's a single control plane, kind of like your air traffic control tower for everything deployment related, uh, in your organization. We have a list of our projects or our applications, our services down the left side, our environments across the top, and we can see exactly which version has been deployed out to which environment. So as you can see, our uh account registry project uh has already started deploying to development that happened automatically at the end of our GitHub actions workflow. So I'm gonna click on, click on this deployment, uh, and it's gonna bring me to our task log. We'll take a look at the task summary screen. So, there's a lot going on as far as the Kubernete's deployment is concerned, but, uh, as far as this presentation is concerned, we're going to focus on the 1st 4 steps and how they relate to the zero Trust pipeline. So, uh, step one, we're grabbing our packages, we're grabbing our S-bomb, uh, grabbing our build information from GitHub and, and kind of gathering that all together for the subsequent steps. Uh, step two, we're verifying that S-bomb, so we're looking through that list of ingredients, uh, and cross-checking it with what was in GitHub. We're making sure that none of those ingredients have changed, uh, and that, that software, that software bill of materials is still sound. Now step 3, talked about that critical stage in our GitHub actions workflow. This is that critical stage in our deployment process. So we are taking Our S-bomb, we're taking our container, we're calculating the SH 256 hashes for each of those, and then we're comparing them to what GitHub says they should be in the Adi station. If they match, uh, we know that the container that we're about to deploy is the exact one that we built. Uh, if there is something off between them, we know that there's been some sort of tampering along the way in our pipeline. So I've mentioned attestations a few times. Quick detour back to GitHub, uh, and if we scroll down a little bit, uh, for those of you, of you that haven't seen, uh, GitHub Advanced Security, uh, we'll take a quick look at our attestation, uh. Real quick, so top section, uh, we have our provenance. Remember this is all the build information, our commits, our workflow file, so on and so forth. Uh, the middle section has a number of, uh, certificate keys that are used to, to verify, uh, but. The key of this attestation that we're working with are subjects down at the bottom. So you can see our Docker container in our S-bomb file along with their subject digest. So when we calculate those in octopus, we're comparing those to these values and making sure that they match. And then finally, step 4, we're checking GitHub for open vulnerabilities using the GitHub API. Doesn't make a ton of sense on this automatic deployment to development because we just built it, you know, 3.5 minutes ago, but if you remember that drift window maybe that artifact's been sitting there for 3 or 4 weeks. Always a good idea to do a final scan, uh, of our repo to make sure nothing's been published, no 0 days exist, uh, no vulnerabilities have made their way into what we're about to send out to our production environment. From there, uh, we're kind of continuing with the standard Kubernetes deployment, creating our name space, config maps, so on and so forth. So that's what that zero trust pipeline looks like. Uh, a few other pieces that I'll, I'll key in on just, uh, when we're talking about deployments for regulated industries. Uh, you notice this top, uh, steps says apply compliance policies. I clicked on that. Um, in Octopus, we have the ability to, uh, define. Policies using Rego uh that span across your entire instance. So, uh, this allows platform teams to standardize, uh. The governance around all deployments in their organization and uh create standards, uh, for any deployment that goes out. Other piece that we'll key in on is our Kubernetes tab over here uh in the upper right. So, uh, we're deploying to EKS, uh, and at deploy time, Octopus is pulling back a snapshot of all the different Kubernetes objects that are getting deployed. Along with their status, uh, so, uh, first off, if any of these were unhealthy, we would see that here in our, our object status screen, uh, but as a developer, maybe I don't have access to direct access to my cluster. This is a great way for me to figure out, hey, what is going on in my cluster, uh, without having to get into the, uh, you know, the hardened environment or without having to give out access to, uh. To a wide array of people. Last piece we'll look at is our build information. So we're pushing this build information to Octopus from GitHub, and it's kind of a, a, a sanity check, an extra length that goes back to our build, uh, where we can get at, uh, those S-bomb files, our attestations, uh, our provenance, and so on and so forth. So back to the dashboard, uh, That's our zero trust pipeline, uh. Signed by GitHub and verified and deployed with governance through Octopus Deeploy. Head back here. So, Kind of things, uh, what did we accomplish today? Um, we established a chain of trust from build to deploy. Uh, GitHub generated the S-bomb, the Provenance, and the attestation, uh, and Octopus verified all of those before anything was deployed. Second, we enforce deployment governance. Uh, so, uh, our deployment went through policy evaluation, it went through vulnerability checks, it went through validation of the attestation. Uh, all these controls are exactly what. Uh, regulated financial organizations need when deploying out to production, uh, and then finally we verified our artifact integrity. Um, we verified that the artifacts that we deployed were the exact ones that we built, uh, and that they hadn't been tampered with. So thank you for coming out. I, I really appreciate you. 5 o'clock, end of the first day. Thanks for coming out and joining me. Uh, again, we're at booth 678, kind of right there, right in front of Q Qualcomm. Happy to, uh, chat with you, answer any questions, uh, yeah, and continue the conversation. Thanks so much.